{"pages":[{"title":"About Me","text":"欢迎来访鸭！( *・ω・)✄╰ひ╯","link":"/about/index.html"}],"posts":[{"title":"CV-Source","text":"CV学习资源（三维与二维） study-source-CVer-CV-学习资源 1.paper switch code 和 cv state-of-the-arthttps://paperswithcode.com/sota 2.人脸识别https://github.com/ChanChiChoi/awesome-Face_Recognition 3.CV2019 https://github.com/amusi/CVPR2019-Code https://github.com/extreme-assistant/cvpr2019 4.3D深度学习1.3D-Machine-Learning3D-Machine-Learning Datasets 3D Pose Estimation Courses Single Object Classification Multiple Objects Detection Scene/Object Semantic Segmentation 3D Geometry Synthesis/Reconstruction Texture/Material Analysis and Synthesis Style Learning and Transfer Scene Synthesis/Reconstruction Scene Understanding 2.A Tutorial on 3D Deep LearningA Tutorial on 3D Deep Learning 3.3D Convolutional Neural Networks — A Reading List3D Convolutional Neural Networks — A Reading List","link":"/2019/05/24/CV-Source/"},{"title":"C++ 笔记1","text":"第1~4章 基础 1～4基础 浮点运算的速度通常比整型运算慢， 对于标量运算float和double都不了没有明显差别 对于适量运算double比float慢得多 运算符重载（operator overloading）：使用相同符号进行多种操作 1.C++内置重载 9/5 int ； 9L/5L long ； 9.0/5.0 double ； 9.0f/5.0f float 2.C++扩展运算符重载 int guess(3.9832);结果：guess=3; 将浮点float转换为整型int时，采用截取（丢弃小数部分），而不是四舍五入 将一个值赋值给取值范围更大的类型通常不会导致什么问题，只是占用的字节更多而已。 列表初始化(使用大括号初始化)不允许窄缩（float--&gt;int）。 (long)thorn; long(thron);强制类型转换不会改变thorn变量本身，而是创建一个新的，指定类型的值。 auto让编译器能够根据初始值的类型推断变量的类型。 C++的基本类型 整数值(内存量及有无符号)： bool,char,signed char,unsigned char,short,unsigned short,int,unsigned int,long,unsigned long,(新)long long,unsigned long 浮点格式的值：float(32位),double(64位),long double（94～128位） 复合类型：数组；字符串：1.字符数组char array 2.string类；结构：struct；共同体：union；枚举：enum；指针：int* ,long*数组（array）123456short months[12];int yamcosts[3]={20,30.5};double earning[4]{1.2e4,1.6e4,1.4e4,1.7e4};float balances[100]{};//初始化全部元素值为0//字符串char boss[8]=\"Bozo\"//后面四个元素为\"\\0\"空字符 using using namespace XXX;这是指示 引入名称空间内所有的名称：将XXX名称空间，所有成员变成可见，作用域和using声明一致；例：using namespace std; using XXX;这是声明 引入名称空间或基类作用域内已经被声明的名称：一次只引入一个命名空间成员;using std::cout; 类之于对象，类型之于变量对象和变量都是用来描述一段内存的。 变量更强调的是变量名这个符号的含义，更强调名字与内存的联系，而不必关注这段内存是什么类型，有多少字节长度，只关注这个变量名a对应着某段内存。 而对象的描述更强调的是内存的类型而不在乎名字，也就是说,从对象的角度看内存，就需要清除这段内存的字节长度等信息，而不是关注这个对象在代码中是否有一个变量名来引用这段内存。struct结构 struct和class的区别 struct能包含成员函数吗？ 能！ struct能继承吗？ 能！！ struct能实现多态吗？ 能！！！ 既然这些它都能实现，那它和class还能有什么区别？最本质的一个区别就是默认的访问控制，体现在两个方面：默认继承访问权限和默认成员访问权限 1）默认的继承访问权限。struct是public的，class是private的。 2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。 做个总结，从上面的区别，我们可以看出，struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。 共用体union 它能够存储不同的数据类型，但只能同时存储其中的一种类型。 这种特性使得当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。 使用场合：1.对内存的使用苛刻，如嵌入式系统编程 2.操作系统数据结构或硬件数据结构 枚举 enum 提供了一种创建符号常量的方式，这种方式可以替代const。 它还允许定义新的类型，但必须按严格的限制进行。123456789101112enum spectrum{red,orange,yellow,green,blue,violet,indigo,wltraciolet};//对应整数值0～7（声明定义）//在不进行强制类型转换的情况下，只能将定义使用的枚举量赋给这种枚举的变量。spectrum band；//声明定义band = blue;//初始化（赋值）//枚举量是整型，可悲提升为int型int color = blue;//设置枚举量的值；enum bits{one=1,two=2,four=4,eight=8};enum bigstep{first,second=100,third};//first=0,third=101//枚举的取值范围bits myflag;myflag=bits(6);//强制类型转换（整数值），保证bits()输入的参数小茹bits的上限，上限=(2^n-1)&gt;max,max在bits中等于8 指针和自由存储空间1.使用常规变量时，值是指定的量，而地址为派生量。指针与C++基本原理1.编译阶段：编译器将程序组合起来 2.运行阶段：程序正在运行时–》oop强调的是在运行阶段进行决策 考虑为数组分配内存的情况，C++采用的方法是：使用关键字new请求正确数量的内存以及使用指针来跟踪新分配内存的位置2.处理存储数据的新策略刚好相反，将地址视为指定的量，将之视为派生量*运算符被称为间接值运算符或叫解除引用运算符（对指针解除引用意味着获得指针指向的值）。 &amp;地址运算符 注意：int * p1,p2;p1是指针，p2是int变量；对于每个指针变量名，都需要一个* 定义与初始化12345int h = 5;int *pt =&amp; h;//或int *pt;pt = &amp;h; 应用*之前，一定要将指针初始化为一个确定的，适当的地址。就是说一定要初始化，否则*pt 将值会赋给一个未知内存。否者都还没引用，又怎么接触引用呢？ 要将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型。1pt=(int *)0×B8000000; 使用new来分配内存变量：在编译时分配的有名称的内存。 指针的真正的用武之地在于，在运行阶段分配未命名的内存以及存储值，（C++中使用new运算符来实现）在这种情况下，只能通过指针来访问内存—&gt;所以new的出现都会有指针。 12typeName * pointer_name=new typeName;//使用new分配未命名的内存* pointer_name=1000;//对该未去命名的内存赋值 new从被称为堆（heap）或自由存储区(free store)的内存区域分配内存。delete pointer_name;//释放指针pointer_name指向的内存。释放pointer_name指向的内存，但不会删除pointer_name指针本身。例如，可以将pointer_name重新指向另外一个新分配的内存块。不要创建两个指向同一内存块的指针 对于大型数据对象来说，使用new，如数组、字符串、结构。 1.静态联编（static binding） 如果通过声明来创建数组，则程序被编译时将为它分配内存空间，不管程序最终是否使用数组，数组都在那里。它占用了内存，所以必须指定数组长度。 2.动态联编（dynamic binding） 意味着数组是在程序运行时创建的，这种数组叫作的哦你太数组。 使用new创建动态数组–&gt;Vector模板类是替代品 1234//创建int * psome =new int[10];//释放delete[] psome;//方括号告诉程序，应释放整个数组。 指针和数组等价的原因在于指针算术 将整数变量加1后，其值将增加1， 将指针变量加1后，增加的量等于它指向类型的字节数。 指针与数组之间的转换 数组：arrayname[i]等价于*(arrayname+i) 指针：pointername[i]等价于*(pointername+i) 因此，很多情况下，可以使用相同的方式使用数组名和指针名 const char *bird ='&quot;wren&quot;bird的值可以修改，但*bird值不可以修改。其实应该说是不能使用bird指针来修改！！！ 常量指针：const修饰的是“char * bird”，里面的值是不可以改变的。可以使用指针bird访问字符串“wren”但不能修改字符串。 char * const p =&quot;wren&quot;; 指针常量：const修饰的是指针“p”，指针的值是不能改变的。使用new来创建动态结构运行时创建数组（结构）由于编译时创建数组（结构） 创建一个未命名的inflatable类型，并将其地址赋给一个指针。 1inflatable *ps=new inflatble C++有三种管理数据内存的方式（不是说物理结构） 自动存储 静态存储 动态存储–&gt;有时也叫自由存储空间或堆 线程存储（C++11新增–&gt;第9章） 自动存储：自动变量（函数内部定义的常规变量）通常存储在栈中 —&gt;随函数被调用生产，随该函数结束而消亡 —&gt;自动变量是个局部变量，作用域为包含的代码块（{…}） 静态存储：使变量称为静态 1.在函数外面定义它 2.在声明变量是使用static关键字 static double free = 5650; 动态存储：使用new和delete（可能导致占用的自由存储去不连续）对数据的生命周期不完全受程序或函数的生存周期不完全受程序或函数的生存时间控制。 如果使用new运算符在自由存储（或堆）上创建变量后，没有调用delete。则即使包含指针的内存由于副作用或规则和对象生命周期的原因而被释放（将会无法访问自由存储空间中的结构，因为指向这些内存的指针无效。这将导致内存泄漏），在自由存储空间上动态内存分配的变量或结构也将继续存在。 类型组合数组名是一个指针 要用指向成员运算符123a_y_e trio[3];trio[0].year=2003;(trio+1)-&gt;year=2004; 1234567//创建指针数组const a_y_e *arp[3]={&amp;s01,&amp;s02,&amp;s03};std::cout&lt;&lt;arp[1]-&gt;year&lt;&lt;std::endl;//可创建指向上述收集自的指针：const a_y_e **ppa =arp;//麻烦//可以auto，让编译器自动推断auto ppa=arps; 数组的替代品 1.模板类vector–&gt;是一种动态数组–&gt;可以在运行时设置长度–&gt;它是使用new创建动态数组的替代品。 vector类自动通过new和delete来管理内存。vector&lt;typeName&gt; vt(n_elm); typeName:类型,vt:对象名,n_elm:个数：整型常量/变量 2.模板类array（C++11）–&gt;与数组一样，array对象长度也是固定的，也使用栈（静态内存分配），而不是自由存储去，因此其效率与数组相同，更方便，更安全。 12array&lt;int,5&gt;ai;array&lt;double,4&gt;ad={1.2,2.1,3.4,4.3};//列表初始化 C++的vector、array和数组的比较（都使用连续内存,而list内存空间是不连续的）在C++11中，STL中提拱了一个新的容器std::array，该容器在某些程度上替代了之前版本的std::vector的使用，更可以替代之前的自建数组的使用。那针对这三种不同的使用方式，先简单的做个比较： 相同点： 三者均可以使用下标运算符对元素进行操作，即vector和array都针对下标运算符[]进行了重载 三者在内存的方面都使用连续内存，即在vector和array的底层存储结构均使用数组 不同点： vector属于变长容器，即可以根据数据的插入删除重新构建容器容量；但array和数组属于定长容量。 vector和array提供了更好的数据访问机制，即可以使用front和back以及at访问方式，使得访问更加安全。而数组只能通过下标访问，在程序的设计过程中，更容易引发访问 错误。 vector和array提供了更好的遍历机制，即有正向迭代器和反向迭代器两种 vector和array提供了size和判空的获取机制，而数组只能通过遍历或者通过额外的变量记录数组的size vector和array提供了两个容器对象的内容交换，即swap的机制，而数组对于交换只能通过遍历的方式，逐个元素交换的方式使用 array提供了初始化所有成员的方法fill vector提供了可以动态插入和删除元素的机制，而array和数组则无法做到，或者说array和数组需要完成该功能则需要自己实现完成。**但是vector的插入删除效率不高（从中间插入和删除会造成内存块的拷贝），但能进行高效的随机存储，list能高效地进行插入和删除，但随机存取非常没有效率遍历成本高。 由于vector的动态内存变化的机制，在插入和删除时，需要考虑迭代的是否失效的问题。 基于上面的比较，在使用的过程中，可以将那些vector或者map当成数组使用的方式解放出来，可以直接使用array；也可以将普通使用数组但对自己使用的过程中的安全存在质疑的代码用array解放出来。","link":"/2019/05/23/C++笔记1/"},{"title":"C++ 笔记5","text":"第11章 使用类 11使用类运算符重载 运算符重载或函数多态—定义多个名称相同但特征标（参数列表）不同的函数 运算符重载—允许赋予运算符多种含义 运算符函数：operator op(argument-list)示例： 1234567891011//有类方法：Time Sum(const Time &amp;t)const;//定义：Time Time::Sum(const Time &amp; t)const{Time sum;sum.minutes = minutes + t.minutes;sum.hours = hours + t.hours + sum.minutes/60;sum.minutes%=60;retrun sum;} 返回值是函数创建一个新的Time对象（sum），但由于sum对象是局部变量，在函数结束时将被删除，因此引用指向一个不存在的对象，返回类型Time意味着程序将在删除sum之前构造他的拷贝，调用函数将得到该拷贝 运算符重载，只需把上述函数名修改即可Sum()的名称改为operator+()1234567//调用：total=coding.Sum(fixing);//运算符重载后调用1. total=coding.operator+(fixing);2. total=coding+fixing;//t1,t2,t3,t4都是Time对象t4=t1+t2+t3; 重载限制下面是可重载的运算符列表： 运算符 分别 双目算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于) 逻辑运算符 ||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，&amp;(取地址) 自增自减运算符 ++(自增)，–(自减) 位运算符 | (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移) 赋值运算符 =, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，-&gt;(成员访问)，,(逗号)，[](下标) 下面是不可重载的运算符列表： .：成员访问运算符 .*, -&gt;*：成员指针访问运算符 ::：域运算符 sizeof：长度运算符 ?:：条件运算符 重载的运算符(有些例外情况)不必是成员函数,但必须至少有一个操作数是用户定义的类型.这防止用户标准类型重载运算符 使用运算符时不能违反运算符原来的语句法则,例如,不恩那个将秋末运算符(%)重载成一个操作数。 不能创建新的运算符 不能重载下面的运算符 sizeof：sizeof运算符 .：成员运算符 ::：作用域解析运算符 ？:：条件运算符 typeid：一个RTTI运算符 const_cast：强制类型转换运算符 dynamic_cast：强制类型转换运算符 static_cast：强制类型转换运算符 reinterpret_cast：强制类型转换运算符 下面运算符只能通过成员运算符函数进行重载 =：赋值运算符 ()：函数调用运算符 []：下标运算符 -&gt;：通过指针访问类成员的运算符 友元函数C++控制类对象私有部分的访问。通常，公有方法提供唯一的访问途径。 C++提供了另外一种形式的访问权限：友元 友元函数 友元类（15章） 友元成员函数（15章） 友元函数：通过让函数成为类的友元，可以赋予该函数与类成员函数相同的访问权限。 问：为何需要友元？为类重载二元运算符是（带两个参数的运算符）常常需要友元函数。将Time对象乘以实数就属于这种情况之前我们有运算符重载： A = B * 2.75;//Time operator*(double n)const; 如果要实现 A=2.75 * B;//不对应成员函数 cannot correspond to a member function 因为2.75不是TIme类型的对象。左侧炒作书应是调用对象 解决： 告知每个人（包括程序员自己），只能按 B * 2.75这种格式编写。 非成员函数（非成员函数来重载运算符），非成员函数不是由对象调用的，它所使用的所有值（包括对象）都是显式参数。 有函数原型： 1Time operator * (double m,const Time &amp;t); 使用： 1A=2.75 * B;或 A=operator *(2.75,B); 问题：非成员函数不能访问类的私有数据，至少常规非成员函数不能访问 解决：友元函数（非成员函数，但其访问权限与成员函数相同。）创建友元函数 将其原型放在类声明中，并在原型声明前加上关键字friend* 声明：friend Time operator * (double m,const Time &amp; t);。该原型声明意味着下面两点： 虽然，operator* ()函数是在类中声明的，但它不是成员函数，因此不能使用成员运算符来调用； 虽然，operator* ()函数不是成员函数，但它与成员函数的访问权限相同。 定义：不要使用Time::限定符，不要再定义中使用关键字friend 12345678Time operator*(double m,const Time &amp; t){Time result;long totalminutes=t.hours*mult*60+t.minutes*mult;resut.hours = totalminutes/60;result.minutes=totalminutes%60;return result;} 注：不必是友元函数（不访问数据成员也能完成功能) 1234Time operator * (double m,const Time &amp; t){return t*m;//调用了Time operator*(double n)const} 重载&lt;&lt;运算符常用友元：重载座左移运算符 第一种重载版本 使用一个Time成员函数重载&lt;&lt; 1trip&lt;&lt;cout;//（trip是Time对象）这样会让人困惑 通过使用友元函数，可以像下面这样重载运算符： 1234void operator&lt;&lt;(ostream &amp; os,const Time&amp; t){os&lt;&lt;t.hours&lt;&lt;\"hours\"&lt;&lt;t.minutes&lt;&lt;\"minute\";} 该函数成为Time类的一个友元函数（operator&lt;&lt;()直接访问Time对象的私有成员），但不是ostream类的友元（从始至终都将ostream对象作为一个整体来使用）第二种重载版本按照上面的定义，下面语句会出错：1cout&lt;&lt;\"Trip Time:\"&lt;&lt;trip&lt;&lt;\"(Tuesday)\\n\"//不能这么做 应该修改友元函数返回ostream对象的引用即可： 12345ostream&amp; operator&lt;&lt;(ostream &amp; os,const Time&amp; t){os&lt;&lt;t.hours&lt;&lt;\"hours\"&lt;&lt;t.minutes&lt;&lt;\"minute\";return os;} 按照上面的定义，下面可以正常运行： 1cout&lt;&lt;\"Trip Time:\"&lt;&lt;trip&lt;&lt;\"(Tuesday)\\n\"//正常运行 类继承属性让ostream引用能指向ostream对象和ofstream对象12345#include&lt;fstream&gt;ofstram fout;fout.open(\"Savetime.txt\");Time trip(12,40);fout&lt;&lt;trip;//等价于operator&lt;&lt;(fout,trip); 类的自动类型转换和强制转换有构造函数Stonewt(double lbs);可以编写下列代码： 12stonewt mycat;//创建一个对象mycat=19.6；//使用了Stonewt(double lbs)构造函数创意了一个临时对象 上面使用了一个Stonewt(double lbs)构造函数创建了一个临时对象，然后将该对象内容复制到了mycat中，这一过程（19.6利用构造函数变成类对象）需要隐式转换，因为是自动进行的，而不需要显式强制转换。 —&gt;只接受一个参数类型的构造函数定义了从参数类型到类类型的转换 注意：只有接受一个参数的构造函数才能作为转换函数，然而，如果第二个参数提供默认值，它便可用于转换int 1Stonewt(int stn,double lbs=0); explicit这种自动特性并非总是合乎需要的，因为会导致意外的类型转换。 新增关键字explicit，用于关闭这种自动特性，也就是说，可以这样声明构造函数：1234567explicit Stonewt(double lbs);//关闭了上面的隐式转换，但允许显式转换，即显式强制类型转换Stonewt mycat;mycat =19.6;//错误代码mycat = Stonewt(19.6);//这里是调用构造函数mycat =(Stonewt)19.6;//这里是前置类型转换 总结 当构造函数只接受一个参数是，可以使用下面的格式来初始化类对象。1Stonewt incognito=2.75; 这等价于前面介绍过的另外两种格式：(这两种格式可用于接收多个参数的构造函数)Stonewt incognito(2.75);Stonewt incognito = Stonewt(2.75); 下面函数中，Stonewt和Stonewt&amp;形参都与Stonewt实参匹配 12345678void display(const Stonewt &amp; st,int n){for(int=0;i&lt;n;i++){cout&lt;&lt;\"WOW!\";st&gt;show_stn();}} 语句display(422,2);中 编译器先查找自动类型转换中42转Stone的构造函数Stonewt(int) 不存在Stonewt(int)的话，Stonewt(double)构造函数满足这种要求因为，编译器将int转换为double 类的转换函数 构造函数只用于某种类型到类类型的转换，要进行相反的转换，必须用到特殊的C++运算符—转换函数 转换函数必定是类方法 用户定义的强制类型转换，可以向使用强制类型转换那样使用它们。 123Stonewt wolf(285,7);double host = double(wolfe);//格式1double thinker=(double)wolfe;//格式2 也可以让编译器来决定如何做： 12Stonewt wolf(20,3);double star =wells;//隐式转换 创建转换函数opeator typeName(); 转换函数必定是类方法 转换函数不能指定返回类型 转换函数不能有参数 例如：转换函数为double类型的原型如下 1operator double();//不要返回类型也不要参数 如何定义 头文件中声明： 12operator int() const;operator double() const; cpp文件中定义： 123456789Stonewt::opeator int() const{return int (pounds+0.5);//四舍五入}Stonewt::opeator double() const{return pounds;//四舍五入} 二义性C++中，int和double值都可以被赋值给long变量，下面语句被编译器认为有二义性而拒绝了。 1234long gone = poppins;//注：poppins是Stonewt对象//但是还是可以进行强制类型转换long gone = (double)poppins;long gone =int (poppins); 避免隐式转换 方法1：C++98中，关键字explicit不能用于转换函数，但C++11消除了这种限制。因此，在C++11中，可将转换运算符声明为显示的：1234567class Stonewr{...//conversion functionsexplicit operator int() const;explicit operator double() const;}; 有了这些声明后，需要前置转换时，将调用这些运算符。 方法2：用一个功能相同的非转换函数替换转换函数即可，但仅在被显式调用时，该函数才会执行。也就是说，可以将：1Stonewt::operator int(){return int(pounds+0.5);} 替换为 1int Stonewt stone_to_int(){return int(pounds+0.5);} 这样下面语句为非法的： 1int plb=popins; 需要转换时只能调用stone_to_int()： 1int plb =poppins.stone_to_int();","link":"/2019/05/24/C++笔记5/"},{"title":"C++ 笔记4","text":"第10章 对象和类 10对象和类 类声明：以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述公有接口–&gt;C++程序员将接口（类定义）放在头文件中 类方法定义：描述如何实现成员函数–&gt;并将实现（类方法代码）放在源代码文件中 细节： 使用#ifndef等来访问多次包含同一个文件 将类的首字母大写 控制访问关键字：private public protected C++对结构进行了扩展，使之具有与类相同的特性。他们之间唯一的区别是：结构的默认访问类型是public，类为private 通常，数据成员被放在私有部分中=&gt;数据隐藏；成员函数被放在公有部分中=&gt;公有接口实现类成员方法成员函数两个特殊的特征： 定义类成员函数时。使用作用域解析符（::）来标识函数所属的类； 类方法可以访问类的private组件。 123456789101112131415161718class Stock{ private: char company[30]; int shares; double share_val; double total_val; void set_tot(){total_val = shares * share_val;} public: Stock(); Stock(const char * co , int n = 0 , double pr = 0.0); ~Stock(){} void buy(int num , double price); void sell(int num , double price); void update(double price); void show() const; const Stock &amp; topval(const Stock &amp; s) const;}; set_tot()只是实现代码的一种方式，而不是公有接口的组成部分，因此这个类将其声明为私有成员函数（即编写这个类的人可以使用它，但编写带来来使用这个类的人不能使用）。 内联方法， 其定义位于类声明中的函数都将自动成为内联函数。因此Stock::set_tot()是一个内联函数。 在类声明之外定义内联函数 1234567891011class Stock{private:...void set_tot();public:...};inline void Stock::set_tot(){total_val = shares * share_val;} 内联函数有特殊规则，要求每个使用它们的文件都对其进行定义。确保内联定义对多个文件程序中的所有文件都可用的最简便方法是：将内联定义放在头文件中 如何将类方法应用于对象？（对象，数据和成员函数）所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员。但同一个类的所有对象共享一组类方法，即每种方法只有一个副本。 要使用类，要创建类对象，可以声明类变量，也可以使用new为类对象分配存储空间。 实现了一个使用stock00接口和实现文件的程序后，将其与stock00.cpp一起编译，并确保stock00.h位于当前文件夹中 类成员函数(方法)可通过类对象来调用。为此，需要使用成员运算符句点。 类的构造函数和析构函数构造函数原因：数据部分的访问状态是私有的，这意味着程序不能直接访问数据成员（私有部分数据）。程序只能通过成员函数来访问数据成员，因此需要设计合适的成员函数才能将对象初始化。—类构造函数 声明和定义构造函数12//construtor prototype with some default argumentStock(const string &amp;co,long n=0,double pr=0.0);//原型 原型声明位于类声明的公有部分。 构造函数可能的一种定义 1234567891011121314Stock::Stock(const string &amp;co,long n,double pr){company = co;if(n&gt;0){std::cerr&lt;&lt;\"Number of shares can't be negative;\" &lt;&lt; company &lt;&lt;\" shares set to 0.\\n\"; shares = 0;}elseshares=n;share_val=pr;set_tot();} 注意“参数名co，n，pr不能与类成员相同.构造函数的参数表示不是类成员，而是赋给类成员的值。 区分参数名和类成员：一种常见的做法是在数据成员名中使用m_前缀 string m_company;;另外一种常见的做法是，在成员名中使用后缀_ string company_;使用构造函数 显式调用 1Stock food = Stock1(\"World cabbage\",250,1.25); 隐式调用 123Stock garment(\"Furry Mason\",50,2.5);//等价于Stock garment= Stock(\"Furry Mason\",50,2.5); 每次创建类对象（甚至使用new动态分配内存）时，C++都是用类结构函数。 1Stock *pstock= new Stock(\"Electroshock Games\",18,19.0);//对象没有名称，但可以使用指针来管理对象 默认构造函数未提供显示初始值是，用来创建对象的构造函数。例: 1Stock fluffy_the_cat;//use the default constructor 当且今当没有定义任何构造函数时，编译器才会提供默认构造函数。 为类定义了构造函数后，程序员就必须为它提供默认构造函数 如果提供了非默认构造函数（如Stock(const string &amp;co,long n,double pr);），但没有提供构造函数，下面声明将出错（禁止创建未初始化对象）1Stock stock1; 如何定义默认构造函数：方法1：给已有构造函数函数的所有参数提供默认值 1Stock(const string &amp;co=\"Error\",int n=0,double pr=0.0); 方法2：通过函数重载来定义另外一个构造函数—一个没有参数的构造函数 1Stock(); 为Stock类提供一个默认构造函数： 12345678//隐式初始化所有对象，提供初始值Stock::Stock(){company = \"no name\";shares = 0;share_val = 0.0;total_val = 0.0;} 使用默认构造函数： 123Stock first;//隐式地调用默认的构造函数Stock first = Stock();//显式地Stock * prelief=new Stock;//隐式地 然而不要被废默认构造函数的隐式形式所误导： 123Stock first(\"Concrete Conglomerate\");//调用构造函数Stcok second(); //声明一个函数Stock third； //调用默认构造函数 析构函数 对象过期是，程序将自动调用该特殊的成员函数。析构函数完成清理工作 如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。 什么时候调用析构函数？这由编译器决定，不应在代码中显示地调用析构函数 如果创建的是静态存储类对象，其析构函数将在程序结束时自动被调用。2 .如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时（该对象是在其中定义的）自动被调用。 如果对象是通过new创建的，则它将驻留在栈内存或自由存储区中，当使用delete来释放内存时，其析构函数将自动被调用。程序可以创建临时变量对象来完成特定操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数。 总的来说：类对象过期时（需要被销毁时），析构函数将自动被调用。因此必须有一个析构函数。如果程序员没有提供析构函数，编译器将隐式地声明一个默认构造函数。 C++列表初始化只要提供与某个构造函数的参数列表匹配的内容，并用大括号将它们括起。 123Stock hot_tip = {\"Derivatives Plus Plus\",100 ,45.0};//构造函数Stock jock {\"Sport Age Storage,Inc\"};//构造函数Stock temp{};//默认构造函数 前两个声明中，用大括号括起的列表与下面的构造函数匹配： 1Stock(const string &amp;co,long n=0,double pr=0.0);//原型 因此，用该构造函数来创建这两个对象。创建对象jock时，第二和第三个参数将默认值为0和0.0。第三个声明与默认构造函数匹配，因此将使用该构造函数创建对象temp。 const成员函数1void Stock::show() const;//promises not to change invoking object 以这种方式声明和定义的类成员函数被称为const成员函数。就像应景可能将const引用和指针作函数参数一样，只要类方法不修改调用对象，就应该将其声明为const this指针有的方法可能涉及两个对象，在这种情况下需要使用C++的this指针（比如运算符重载） 提出问题：如何实现：定义一个成员函数，查看两个Stocl对象，并返回股价高的那个对象的引用。 最直接的方法是，返回一个引用，该引用指向股价总值较高的对象，因此，用于比较的方法原型如下：1const Stock &amp; topval(const Stock &amp; s) const;//该函数隐式地访问一个对象，并返回其中一个对象 第一个const：由于返回函数返回两个const对象之一的引用，因此返回类型也应为const引用 第二个const：表明该函数不会修改被显式访问的对象 第三个const：表明该函数不会修改被隐式访问的对象 调用： 1top = stock1.topval(stock2);//隐式访问stock1，显式访问stock2 this 指针用来指向调用成员函数的对象（this被作为隐藏参数传递给方法）。 每个成员函数（包括构造函数和析构函数）都有一个this指针。this指针指向调用对象 如果方法需要引用整个调用对象，可一个使用表达式*this。 实现： 1234567const Stock &amp; topval(const Stock &amp; s) const{if(s.total_val&gt;total_val)return s;elsereturn *this;} 创建对象数组123456Stock stocks[4]={ Stock(\"NanoSmart\",12,20.0), Stock(\"Boffo Objects\",200,2.0), Stock(\"Monolothic Obelisks\",130,3.25), Stock(\"Fleep Enterprises\",60,6.5)}; 类作用域回顾： 全局（文件）作用域，局部（代码块）作用域 可以在全局变量所属的任何地方使用它，而局部变量只能在其所属的代码块中使用。函数名称的作用域也可以是全局的，但不能是局部的。 类作用域 在类中定义的名称（如类数据成员和类成员函数名）的作用域为整个类。 类作用域意味着不能从外部直接访问类成员，公有函数也是如此。也就是说，要用调用公有成员函数，必须通过对象。 使用类成员名时，必须根据上下文使用，直接成员运算符（.），间接成员运算符（-&gt;）或者作用域解析符（::） 作用域为类的常量下面是错误代码 123456class Bakery{private:const int Months=12;//错误代码double cots[Months];} 这是行不通的，因为声明类只是描述了对象的形式，并没有创建对象。因此在创建对象之前，并没有用于存储值的空间。 解决： 方法一：使用枚举123456class Bakery{private:enum{Months=12};double costs[Months];} 这种方式声明枚举并不会创建类数据成员。也就是说，所有对象都不包含枚举。另外，Months只是一个符号名称，在作用域为整个类的代码中遇到他时，编译器将用12来替换它。 方法二：使用关键字static123456class Bakery{private:static const int Months=12；double costs[Months];} 这将创建一个名为Months的常量，该常量与其他静态变量存储在一起，而不是存储在对象中。因此，只有一个Months常量，被所有Bakery对象共享。 作用域内枚举（C++11）传统的枚举存在一些问题，其中之一是两个枚举定义的枚举量可能发生冲突。 12enum egg{Small，Medium,Large，XLarge};enum t_shirt{Small,Medium,Large,Xlarge}; 这将无法通过编译因为egg Small和t_shirt Small位于相同的作用域内，他们将发生冲突。 新枚举12enum class egg{Small，Medium,Large，XLarge};enum class t_shirt{Small,Medium,Large,Xlarge}; 作用域为类后，不同枚举定义的枚举量就不会发生冲突了。 class也可以用关键字struct来代替 使用： 12egg choice = egg::Large;t_shirt Floyd=t_shirt::Large; 注意：作用域内枚举不能隐式地转换为整型，下面代码错误 1int ring = Floyd;//错误 但是必要时可以进行显式转换 1int Floyd = int(t_shirt::Small); 抽象数据类型ADT(Abstract Data Type) 以抽象的方式描述数据类型，而没有引入语言和细节","link":"/2019/05/24/C++笔记4/"},{"title":"C++ 笔记7","text":"第13章 类继承 13类继承基类和派生类的特殊关系 1.派生类对象可以使用非私有的基类方法 2.基类指针（引用）可以在不进行显示转换的情况下指向（引用）派生类对象（反过来不行）；基类指针或引用只能用来调用基类方法，不能用来调用派生类方法。 3.不可以将基类对象和地址赋给派生类对象引用和指针。 派生类构造函数要点1.首先创建基类对象；2.派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数。3.派生类构造函数应初始化新增的数据成员。注意：可以通过初始化列表语法知名指明要使用的基类构造函数，否则使用默认的基类构造函数。派生类对象过期时，程序将首先调用派生类的析构函数，然后在调用基类的析构函数。 1234RetedPlayer::RetedPlayer(unsigned int r,const string &amp; fn,const string &amp;ln, bool ht)//:TableTennisPlayer()等价于调用默认构造函数{rating = r;} 虚方法 经常在基类中将派生类会重新定义的方法声明为虚方法。方法在基类中被声明为虚的后。它在派生类中将自动生成虚方法。然而，在派生类中使用关键字virtual来指出哪些函数是虚函数也不失为一个好方法。 如果要在派生类中重新定义基类的方法，通常将基类方法声明为虚。这样，程序根据对象类型而不是引用或指针类型来选择方法版本，为基类声明一个虚的析构函数也是一种惯例，为了确保释放派生类对象时，按正确的顺序调用析构函数。 虚函数的作用：基类指针（引用）指向（引用）派生类对象，会发生自动向上类型转换，即派生类升级为父类，虽然子类转换成了它的父类型，但却可正确调用属于子类而不属于父类的成员函数。这是虚函数的功劳。 派生类方法可以调用公有的基类方法在派生类方法中，标准技术是使用作用域解析运算符来调用基类方法，如果没有使用作用域解析符，有可能创建一个不会终止的递归函数。如果派生类没有重新定义基类方法，那么代码不必对该方法是用作用域解析符（即该方法只有在基类中有）。 静态联编和动态联编函数名联编（binding）：将代码中的函数调用解释为执行特定的代码块。 在C语言中，这非常简单，因为每个函数名都对应一个不同的函数。 在C++中，由于函数重载的缘故，这个任务更繁杂，编译器必须查看函数参数以及函数名才能确定使用哪个函数。 静态联编(static binding) 在编译过程中进行联编，又称为早期联编 动态联编(dynamic binding) 编译器在程序运行时确定将要调用的函数，又称为晚期联编什么时候使用静态联编，什么时候使用动态联编？ 编译器对虚方法使用静态联编，因为方法是非虚的，可以根据指针类型关联到方法。 编译器对虚方法使用动态联编，因为方法是虚的，程序运行时才知道指针指向的对象类型，才来选择方法。（引用同理）效率：为使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针和指向引用对象的对象类型，这增加了额外的处理开销 例如，如果类不会用作基类，则不需要动态联编。 同样，如果派生类不重新定义基类的任何方法，也不需要动态联编。 通常，编译器处理函数的方法是：给每个对象添加一个隐藏成员–指向函数地址数组的指针(vptr) 使用虚函数时，在内存和执行速度上有一定的成本，包括：a.每个对象为存储地址的空间；b.对于每个类，比那一期都将创建一个虚函数地址表（数组）vtbl；c.对于每个函数调用，都需要执行一项额外的操作，到表中查找地址。虽然非虚函数的效率比虚函数稍高，但不具有动态联编的功能 总结： 在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类（包括从派生类派生出来的类）中是虚的。 如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不是用为引用或者指针类型定义的方法。这个成为动态联编或者晚期联编。这种行为非常重要。因为这样基类指针或引用可以指向派生类对象。 如果定义的类将被用作基类，则应该将那些在派生类中重新定义的类方法生命为虚的。 虚函数细节 1.构造函数不能是虚函数，派生类不能继承基类的构造函数，将类构造函数声明为虚没什么意义。 2.析构函数应当是虚函数，除非类不用作基类。 1.当子类指针指向子类是，析构函数会先调用子类析构再调用父类析构，释放所有内存。2.当父类指针指向子类时，只会调用父类析构函数，子类析构函数不会被调用，会造成内存泄漏。（基类析构函数声明为虚，可以使得父类指针能够调用子类虚的析构函数）所以我们需要虚析构函数，将父类的析构函数定位为虚，那么父类指针会先调用子类的析构函数，再调用父类析构，使得内存得到释放。 3.友元不能是虚函数，因为友元不是类成员，只有类成员才是虚函数。 4.如果派生类没有重新定义函数。将使用该函数的基类版本。 5.重新定义将隐藏方法不会生成函数的两个重载版本，而是隐藏基类版本。如果派生类位于派生链中，则使用最新的虚函数版本，例外的情况是基类版本是隐藏的。总之，重新定义基本的方法并不是重载。如果重新定义派生类中的函数，将不只是使用相同的函数参数列表覆盖其基类声明，无论参数列表是否相同，该操作将隐藏所有的同名方法。 两条经验规则 1.如果重新定义继承的方法，应确保与原来的原型完全相同，但是如果返回类型是积累的引用或指针，则可以修改为指向派生类的引用或指针（只适用于返回值而不适用于参数），这种例外是新出现的。这种特性被称为返回类型协变（convariance of return type），因此返回类型是随类类型变化的。 123456789101112//基类class Dwelling{public:virtual Dwelling &amp; build(int n);}//派生类class Hovel:public Dwelling{public:virtual Hovel &amp; build(int n);} 2.如果基类声明被重载了，则应该在派生类中重新定义所有基类版本。 123456789101112131415161718//基类class Dwelling{public://三个重载版本的showperksvirtual void showperks（int a）const；virtual void showperks（double a）const；virtual void showperks（ ）const；}//派生类class Hovel:public Dwelling{public://三个重新定义的的showperksvirtual void showperks（int a）const；virtual void showperks（double a）const；virtual void showperks（ ）const；} 如果只重新定义一个版本，则另外两个版本将被隐藏，派生类对象将无法使用它们，注意，如果不需要修改，则新定义可知调用基类版本： 1234void Hovel::showperk()const{Dwelling::showperks();} 访问控制：protected 1.关键字protected与private相似，在类外，只能用公有类成员来访问protected部分中的类成员。 2.private和protected之间只有在基类派生的类才会表现出来。派生类的成员可以直接访问基类的保护成员，但是不能直接访问基类的私有成员。提示： 1.最好对类的数据成员采用私有访问控制，不要使用保护访问控制。 2.对于成员函数来说，保护访问控制很有用，它让派生类能够访问公众不能使用的内部函数。 抽象基类（abstract base class）ABC-&gt;至少包含一个纯虚函数 在一个虚函数的声明语句的分号前加上 =0 ；就可以将一个虚函数变成纯虚函数，其中，=0只能出现在类内部的虚函数声明语句处。 纯虚函数只用声明，而不用定义，其存在就是为了提供接口，含有纯虚函数的类是抽象基类。我们不能直接创建一个抽象基类的对象，但可以创建其指针或者引用。 值得注意的是，你也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。但此时哪怕在外部定义了，也是纯虚函数，不能构建对象。 派生类构造函数只直接初始化它的直接基类。多继承的虚继承除外。 抽象类应该注意的地方 抽象类不能实例化，所以抽象类中不能有构造函数。 纯虚函数应该在派生类中重写，否则派生类也是抽象类，不能实例化。 抽象基类的作用 C++通过使用纯虚函数（pure virtual function）提供未实现的函数。纯虚函数声明的结尾处为=0， 1virtual double Area() const=0;//=0指出类是一个抽象基类，在类中可以不定义该函数 可以将ABC看作是一种必须的接口。ABC要求具体派生类覆盖其纯虚函数—迫使派生类遵顼ABC设置的接口规则。简单来说是：因为在派生类中必须重写纯虚函数，否则不能实例化该派生类。所以，派生类中必定会有重新定义的该函数的接口。 从两个类(具体类concrete)（如：Ellipse和Circle类）中抽象出他们的共性，将这些特性放到一个ABC中。然后从该ABC派生出的Ellipse和Circle类。 这样，便可以使用基类指针数组同时管理Ellipse和Circle对象，即可以使用多态方法* 友元 就像友元关系不能传递一样，友元关系同样不能继承，基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。 继承和动态内存分配(todo) 只有当一个类被用来做基类的时候才会把析构函数写成虚函数。 当基类和派生类都采用动态内存分配是，派生类的析构函数，复制构造函数，赋值运算符都必须使用相应的基类方法来处理基类","link":"/2019/05/24/C++笔记7/"},{"title":"C++ 笔记6","text":"第12章 类和动态内存分配 12类和动态内存分配 动态内存和类 –&gt;让程序运行时决定内存分配，而不是在编译时决定。 —-&gt;使用new和delete运算符来动态控制内存 ——&gt;在类中使用这些运算符将导致许多新的编程问题。这种情况下，析构函数将是必不可少的，而不再是可有可无的。 ——–&gt;有时候还必须重载赋值运算符。 C++为类自动提供了下面这些成员函数 1.默认构造函数，如果没有定义构造函数；记得自己定义了构造函数时，编译器不会再提供默认构造函数，记得自己再定义一个默认构造函数。带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值。 2.默认析构函数，如果没有定义；用于销毁对象 3.复制（拷贝）构造函数，如果没有定义；用于将一个对象赋值到新创建的对象中（将一个对象初始化为另外一个对象）。用于初始化的过程中，而不是常规的赋值过程。 每当程序生成对象副本时（函数按值传递对象，函数返回对象时），编译器都将使用复制构造函数 编译器生成临时对象是，也将使用复制构造函数默认的复制构造函数的功能---&gt;逐个复制非静态成员（成员复制也叫浅复制,给两个对象的成员划上等号），复制的是成员的值；如果成员本身就是类对象，则将使用这个类的复制构造函数复制成员对象,静态成员变量不受影响，因为它们属于整个类，而不是各个对象 浅复制面对指针时会出现错误，在复制构造函数中浅复制的等价于sailor.len=sport.len;sailor.str=sport.str;前一个语句正确，后一个语句错误，因为成员char* str是指针，得到的是指向同一字符串的指针！！！ 当出现动态内存分配时，要定义一个现实复制构造函数—&gt;进行深度复制(deep copy) 123456StringBad::StringBad(const StringBad &amp; st){len=st.len;str=new char[len+1];std::strcpy(str,st.str);} 4.赋值运算符，如果没有定义；赋值运算符只能由类成员函数重载的运算符之一。将已有的对象赋值给另外一个对象时（将一个对象复制给另外一个对象），使用赋值运算符。原型：class_name &amp; class_name::operator==(const class_name &amp;);接受并返回一个指向类对象的引用。 与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制 解决：提供赋值运算符（进行深度复制）定义，其实现业余复制构造函数相似，但有一些差别 123456789101112131415161718192021222324//代码1：先申请内存，再deleteCMyString&amp; CMyString::operator=(const CMyString&amp; str){if(this==str){char *temp_pData=new char[strlen(str.m_pData)+1)];delete[]m_pData;m_pData=temp_pData;strcpy(m_pData,str.m_pData);}return *this;}//代码2：调用复制构造函数CMyString&amp; CMyString::operator=(const CMyString&amp; str){if(this==str){CMyString strTemp(str);//复制构造函数创建临时对象，临时对象失效时会自动调用析构函数char* pTemp=strTemp.m_pData;//创建一个指针指向临时对象的数据成员m_pDatastrTemp.m_pData=m_pData;//交换m_pData=pTemp;//交换}return *this;} 5.地址运算符，如果没有定义； 6.移动构造函数(move construtor)，如果没有定义； 7.移动赋值运算符(move assignment operator)。 静态类成员函数 1.静态函数：静态函数与普通函数不同，它只能在声明它的文件中可以见，不能被其他文件使用。定义静态函数的好处：静态函数不会被其他文件使用。其他文件中可以定义相同名字的函数，不会发生冲突。 2.静态类成员函数:与静态成员数据一样，我们可以创建一个静态成员函数，它为类的全部服务，而不是为某一个类的具体对象服务。静态成员函数与静态成员数据一样，都是在类的内部实现，属于类定义的一部分。普通成员函数一般都隐藏了一个this指针，this指针指向类的对象本身。 3.静态成员函数由于不是与任何对象相联系，因此不具有this指针，从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数静态成员函数总结： 1.出现在类体外的函数不能指定关键字static； 2.静态成员之间可以互相访问，包括静态成员函数访问静态数据成员和访问静态成员函数； 3.非静态成员函数可以任意地访问静态成员函数和静态数据成员； 4.静态成员函数不能访问非静态成员函数和非静态数据成员 5.由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比，速度上会有少许的增长 6.调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指调用静态成员函数。 构造函数中使用new时应注意的事项 1.如果构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。 2.new和delete必须相互兼容，new对应于delete，new[]对应于delete[] 3.如果有多个构造函数，则必须以相同的方式使用new，要么中括号，要么都不带。因为只有一个析构函数，所有的构造函数都必须与它兼容。然而，可以在一个构造函数中使用new来初始化指针，而在另外一个构造函数中初始化为空（0或nullptr），这是因为delete（无论是带括号，还是不带括号）可以用于空指针。 4.应定义一个复制构造函数，通过深度复制将一个对象初始化为另外一个对象。 5.应当定义一个赋值运算符，通过深度复制将一个对象复制给另外一个对象。 有关返回对象的引用 1.首先，返回对象将调用复制构造函数（给新创建的临时对象复制（初始化）），而返回引用不会 2.其次，返回引用指向的对象因该在调用函数执行时存在。 3.返回作为参数输入的常量引用，返回类型必须为const，这样才匹配。 使用指向对象的指针Class_name* ptr = new Class_name;调用默认构造函数 定位new运算符/常规new运算符123456789101112131415161718//使用new运算符创建一个512字节的内存缓冲区char* buffer =new char[512];//地址：(void*)buffer=00320AB0//创建两个指针；JustTesting *pc1,*pc2;//给两个指针赋值pc1=new (buffer)JustTesting;//使用了new定位符，pc1指向的内存在缓冲区 地址：pc1=00320AB0pc2=new JustTesting(\"help\",20);//使用了常规new运算符，pc2指向的内存在堆中//创建两个指针；JustTesting *pc3,*pc4;//给两个指针赋值pc3=new (buffer)JustTesting(\"Bad Idea\",6);//使用了new定位符，pc3指向的内存在缓冲区 地址：pc3=00320AB0//创建时，定位new运算符使用一个新对象覆盖pc1指向的内存单元。//问题1：显然，如果类动态地为其成员分配内存，该内存还没有释放，成员就没了，这将引发问题。pc4=new JustTesting(\"help\",10);//使用了常规new运算符，pc4指向的内存在堆中//释放内存delete pc2；//free heap1delete pc4；//free heap2delete[] buffer//free buffer 解决问题1，代码如下： 12pc1=new (buffer)JustTesting;pc3=new (buffer+sizeof(JustTesting))(\"Bad Idea\",6); 问题2： 将delete用于pc2，pc4时，将自动调用为pc2和pc4指向的对象调用析构函数；问题2：然而，将的delete[]用于buffer时，不会为使用定位new运算符创建的对象调用析构函数 解决问题2：显式调用析构函数 12pc3-&gt;~JustTesting;pc1-&gt;~JustTesting; 嵌套结构和类 在类声明的结构、类或枚举被认为是被嵌套在类中，其作用域为整个类 这种声明不会创建数据对象，而是指定了可以在类中使用的类型。 1.如果声明是在类的私有部分进行的，则只能在这个类中使用被声明的类型。 2.如果声明是在公有部分进行的，则可以从类的外部通过作用域解析运算符使用被声明的类型例如，如果Node是在Queue类的公有部分声明的，则可以在外部声明Queue::Node类型的变量。 默认初始化a.内置类型的变量初始化如果定义变量时没有指定初始值，则变量被默认初始化。默认值由变量类型和定义变量的位置决定。 如果是内置类型的变量未被显示初始化，它的值由定义位置决定。定义于任何函数体外的变量被初始化为0。 12//不在块中int i;//正确，i会被值初始化为0，也称为零初始化 定义于函数体内部的内置类型变量将不被初始化（uninitialized）。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或其他形式的访问此类型将引发错误 123451 {//在一个块中2 int i;//默认初始化，不可直接使用3 int j=0;//值初始化4 j=1;//赋值5 } b.类类型的对象初始化类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数（constructor）。构造函数的任务是初始化类对象的数据成员。由编译器提供的构造函数叫（合成的默认构造函数）。合成的默认构造函数将按照如下规则初始化类的数据成员。 如果存在类内初始值（C++11新特性），用它来初始化成员。 12345678class CC{public: CC() {} ~CC() {}private: int a = 7; // 类内初始化，C++11 可用} 否则，没有初始值的成员将被默认初始化。 成员列表初始化 使用成员初始化列表的构造函数将覆盖相应的类内初始化 对于简单数据成员，使用成员初始化列表和在函数体中使用复制没什么区别 对于本身就是类对象的成员来说，使用成员初始化列表的效率更高 如果Classy是一个类，而mem1，mem2，mem3都是这个类的数据成员，则类构造函数可以使用如下的语法来初始化数据成员。 1234Classy::Classy(int n,intm):mem1(n),mem2(0),men3(n*m+2){//...} 1.这种格式只能用于构造函数 2.必须用这种格式来初始化非静态const数据成员（至少在C++之前是这样的）； 3.必须用这种格式来初始化引用数据成员 数据成员被初始化顺序与它们出现在类声明中的顺序相同，与初始化器中的排列顺序无关","link":"/2019/05/24/C++笔记6/"},{"title":"C++ 笔记9","text":"第15章 友元、异常和其他 15友元、异常和其他友元类例子：模拟电视机和遥控器的简单程序 公有继承is-a关系并不适用。遥控器可以改变电视机的状态，这表明应将Remove类作为TV类的一个友元 友元声明 friend class Remote；—&gt;友元声明可以位于公有、私有或保护部分，其所在的位置无关紧要。该声明让整个类成为友元并不需要前向（实现）声明，因为友元语句本身已经指出Remote是一个类。 友元Remove可以使用TV类的所有成员 大多类方法都被定义为内联。代码中，除构造函数外，所有Remove方法都将一个TV对象引用作为参数，这表明遥控器必须针对特定的电视机 同一个遥控器可以控制不同的电视机 12345TV S42；TV S58(TV::ON);Remote grey;grey.set_chan(S42,10);grey.set_chan(S58,28); 友元成员函数 某一个类的成员函数作为另外一个类的友元函数 例子：将TV成员中Remote方法Remote::set_chan()，成为另外一个类的成员 12345class TV{friend void Remote::set_chan(TV&amp; t,int c);...}; 问题1：在编译器在TV类声明中看到Remote的一个方法被声明为TV类的友元之前，应先看到Remote类的声明和set_chan()方法的声明。 1234//排列次序应如下：class TV;//forward declarationclass Remote{...};class TV{...}; 问题2：Remote声明包含内联代码，例如：void onoff(TV &amp; t){t.onoff();}由于这将调用TV的一个方法，所以编译器此时必须看到一个TV的类声明，解决：使Remote声明中只包含方法声明，并将实际的定义放在TV类之后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt; class B{public : B() { myValue=2; std::cout&lt;&lt;\"B init\"&lt;&lt;std::endl; } ~B() { std::cout&lt;&lt;\"B end\"&lt;&lt;std::endl; } //这样做可以 /*B operator+(const B av) { B a; a.myValue=myValue+av.myValue; return a; }*/ //也可以这么做 friend B operator+(const B b1,const B b2); //------------------------------------------------ int GetMyValue() { return myValue; } //重载&lt;&lt; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os,B);private : int myValue;};B operator+(const B b1,const B b2){ B a; a.myValue=b1.myValue+b2.myValue; return a;}std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os,B b){ return os&lt;&lt;\"重载实现：\"&lt;&lt;b.myValue&lt;&lt;std::endl;}int main(){ B b1; std::cout&lt;&lt;b1; B b2; B b3=b1+b2; std::cout&lt;&lt;b3&lt;&lt;std::endl; std::cin.get(); return 0;} 内联函数的链接性是内部的，这意味着函数定义必须在使用函数的文件中，这个例子中内联定义位于头文件中，因此在使用函数的文件中包含头文件可确保将定义放在正确的地方。这可以将定义放在实现文件中，但必须删除关键字inline这样函数的链接性将是外部的 嵌套类 在另外一个类中声明的类被称为嵌套类（nested class） 包含类的成员函数可以创建和使用被嵌套的对象。而仅当声明位于公有部分，才能在包含类外面使用嵌套类，而且必须使用作用域解析运算符 访问权限：嵌套类、结构和美剧的作用域特征（三者相同） 声明位置 包含它的类是否可以使用它 从包含它的类派生而来的类是否可以使用它 在外部是否可以使用 私有部分 是 否 否 保护部分 是 是 否 公有部分 是 是 是，可以通过类限定符来使用 * 访问控制 1.类声明的位置决定了类的作用域或可见性 2.类可见后，访问控制规则（公有，保护，私有，友元）将决定程序对嵌套类成员的访问权限。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//在下面的程序中，我们创建了一个模板类用于实现Queue容器的部分功能，并且在模板类中潜逃使用了一个Node类。// queuetp.h -- queue template with a nested class#ifndef QUEUETP_H_#define QUEUETP_H_template &lt;class Item&gt;class QueueTP{private: enum {Q_SIZE = 10}; // Node is a nested class definition class Node { public: Item item; Node * next; Node(const Item &amp; i) : item(i), next(0) {} }; Node * front; // pointer to front of Queue Node * rear; // pointer to rear of Queue int items; // current number of items in Queue const int qsize; // maximum number of items in Queue QueueTP(const QueueTP &amp; q) : qsize(0) {} QueueTP &amp; operator=(const QueueTP &amp; q) { return *this; }public: QueueTP(int qs = Q_SIZE); ~QueueTP(); bool isempty() const { return items == 0; } bool isfull() const { return items == qsize; } int queuecount() const { return items; } bool enqueue(const Item &amp;item); // add item to end bool dequeue(Item &amp;item); // remove item from front};// QueueTP methodstemplate &lt;class Item&gt;QueueTP&lt;Item&gt;::QueueTP(int qs) : qsize(qs){ front = rear = 0; items = 0;}template &lt;class Item&gt;QueueTP&lt;Item&gt;::~QueueTP(){ Node * temp; while (front != 0) // while queue is not yet empty { temp = front; front = front-&gt;next; delete temp; }}// Add item to queuetemplate &lt;class Item&gt;bool QueueTP&lt;Item&gt;::enqueue(const Item &amp; item){ if (isfull()) return false; Node * add = new Node(item); // create node // on failure, new throws std::bad_alloc exception items ++; if (front == 0) // if queue is empty front = add; // place item at front else rear-&gt;next = add; // else place at rear rear = add; return true;}// Place front item into item variable and remove from queuetemplate &lt;class Item&gt;bool QueueTP&lt;Item&gt;::dequeue(Item &amp; item){ if (front == 0) return false; item = front-&gt;item; // set item to first item in queue items --; Node * temp = front; // save location of first item front = front-&gt;next; // reset front to next item delete temp; // delete former first item if (items == 0) rear = 0; return true;}#endif // QUEUETP_H_ 异常 意外情况 1.程序可能会试图打开一个不可用的文件2.请求过多内存3.遭遇不能容忍的值 1.调用abort()–原型在cstdlib（或stdlib.h）中 其典型实现是向标准错误流（即cerr使用的错误流）发送信息abnormalprogram termination（程序异常中止），然后终止程序。它返回一个随实现而异的值，告诉操作系统，处理失败。 调用abort()将直接终止程序（调用时，不进行任何清理工作） 使用方法：1.判断触发异常的条件 2.满足条件时调用abort() 1.exit():在调用时，会做大部分清理工作，但是决不会销毁局部对象，因为没有stack unwinding。会进行的清理工作包括：销毁所有static和global对象，清空所有缓冲区，关闭所有I／O通道。终止前会调用经由atexit()登录的函数，atexit如果抛出异常，则调用terminate()。 2.abort():调用时，不进行任何清理工作。直接终止程序。 3.retrun:调用时，进行stack unwinding，调用局部对象析构函数，清理局部对象。如果在main中，则之后再交由系统调用exit()。 return返回，可析构main或函数中的局部变量，尤其要注意局部对象，如不析构可能造成内存泄露。exit返回不析构main或函数中的局部变量，但执行收工函数，故可析构全局变量（对象）。abort不析构main或函数中的局部变量，也不执行收工函数，故全局和局部对象都不析构。所以，用return更能避免内存泄露，在C++中用abort和exit都不是好习惯。 2.返回错误代码一种比异常终止更灵活的方法是，使用函数的返回值来指出问题 3.异常机制 C++异常是对程序运行过程中发生的异常情况（例如被0除）的一种响应。异常提供了将控制权从程序的一个部分传递到另外一部分的途径 异常机制由三个部分组成1.引发异常123456double hmean(double a,double b){if(a==-b)throw \"bad heam() arguments:a=-b not allowed\";//throw关键字表示引发异常（实际上是跳转）return 2.0*a*b/(a+b);} 2.使用异常处理程序（exception handler）来捕获异常3.使用try块：try块标识其中特定异常可能会被激活的代码，它后面跟一个或多个的catch块 例子：12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt; using std::cout;using std::cin;using std::cerr; int fun(int &amp; a, int &amp; b){if(b == 0){ throw \"hello there have zero sorry\\n\"; //引发异常}return a / b;} int main(){ int a; int b; while(true) { cin &gt;&gt; a; cin &gt;&gt; b; try //try里面是可能引发异常代码块 { cout &lt;&lt; \" a / b = \"&lt;&lt; fun(a,b) &lt;&lt; \"\\n\"; } catch(const char *str) 接收异常,处理异常 { cout &lt;&lt; str; cerr &lt;&lt;\"除数为0\\n\"; //cerr不会到输出缓冲中 这样在紧急情况下也可以使用 } } system(\"pause\"); return 1;} 1.try:try块标识符其中特定的异常可能被激活的代码块,他后面跟一个或者多个catch块. 2.catch:类似于函数定义,但并不是函数定义,关键字catch表明这是给一个处理程序,里面的const cahr* str会接受throw传过来错误信息. 3.throw:抛出异常信息,类似于执行返回语句,因为它将终止函数的执行,但是它不是将控制权交给调用程序,而是导致程序沿着函数调用序列后退,知道找到包含try块的函数. 注意： 1.如果程序在try块外面调用fun(),将无法处理异常。 2.throw出的异常类型可以是字符串，或其他C++类型：通常为类类型 3.执行throw语句类似于执行返回语句，因为它也将终止函数的执行。 4.执行完try中的语句后，如果没有引发任何异常，则程序跳过try块后面的catch块，直接执行后面的第一条语句。 5.如果函数引发了异常，而没有try块或没有匹配处理程序时，将会发生什么情况。在默认情况下，程序最终调用abort()函数！ 4.将对象用作异常类型 P6225.栈解开（栈解退）stack unwind C++如何处理函数调用和返回的？ 1.程序将调用函数的地址（返回地址）放入到栈中。当被调用的函数执行完毕后，程序将使用该地址来确定从哪里开始执行。 2.函数调用将函数参数放入到栈中。在栈中，这些函数参数被视为自动变量。如果被调用的函数创建的自动变量，则这些自动变量也将被添加到栈中 3.如果被调用的函数调用了另外一个函数，则后者的信息将被添加到栈中，依此类推。 假设函数出现异常（而不是返回）而终止，则程序也将释放栈中的内存，但不会释放栈中的第一个地址后停止，而是继续释放，直到找到一个位于try块中的返回地址。随后，控制权将转到块尾的异常处理程序，而不是函数调用后的第一条语句，这个过程被称为栈解退。 exception类（头文件exception.h/except.h第一了exception类）C++可以把它用作其他异常类的基类 1.stdexcept 异常类（头文件stdexcept定义了其他几个异常类。） 该文件定义了1.logic_error类 2.runtime_error类他们都是以公有的方式从exception派生而来的。 1.logic_error类错误类型（domain_error、invalid_argument、length_error、out_of_bounds）。每个类都有一个类似于logic_error的构造函数，让您能够提供一个供方法what()返回的字符串。 2.runtime_error类错误类型（range_error、overflow_error、underflow_error）。每个类都有一个类似于runtime_error的构造函数，让您能够提供一个供方法what()返回的字符串。 2.bad-alloc异常和new(头文件new) 对于使用new导致的内存分配问题，C++的最新处理方式是让new引发bad_alloc异常。头文件new包含bad_alloc类的生命，他是从exception类公有派生而来的。但在以前，当无法分配请求的内存量时，new返回一个空指针。 3.异常类和继承 1.可以像标准C++库所做的那样，从一个异常类派生出另外一个。 2.可以在类定义中嵌套异常类声明类组合异常。 3.这种嵌套声明本身可被继承，还可用作基类。 RTTI(运行阶段类型识别)(Run-Time Type Identification) 旨在为程序运行阶段确定对象的类型提供一种标准方式 RTTI的工作原理 C++有三个支持RTTI的元素 1.如果可能的话，dynamic_cast运算符将使用一个指向基类的指针来生成指向派生类的指针；否则，该运算符返回0—空指针。 2.typeid运算符返回指出对象类型的值 3.type_info结构存储了有关特定类型的信息。 1.dynamic_cast运算符是最常用的RTTI组件 他不能回答“指针指向的是哪类对象”这样的问题，但能回答“是否可以安全地将对象的地址赋给特定类型的指针”这样的问题 用法：Superb* pm = dynamic_cast&lt;Super*&gt;(pg);其中pg指向一个对象 提出这样的问题：指针pg类型是否可被安全地转换为Super* ?如果可以返回对象地址，否则返回一个空指针。 2.typeid运算符和type_info类。 typeid运算符使得能够确定两个对象是否为同类型,使用：如果pg指向的是一个Magnification对象，则下述表达式的结果为bool值true，否则为false； 12345typeid(Magnification)==typeid(*pg)type_info类的实现岁厂商而异，但包含一个name()成员，该函数返回一个随实现而异的字符串；通常（但并非一定）是类的名称。例如下面的语句想爱你是指针pg指向的对象所属的类定义的字符串：​```C++cout&lt;&lt;\"Now Processing type\"&lt;&lt;typeid(*pg).name()&lt;&lt;\".\\n\"; 类型转换运算符 4个类型转换运算符:dynamic_cast\\const_cast\\static_cast\\reinterpret_cast 1.dynamic_cast(expression) 该运算符的用途是，使得能够在类层次结构中进行向上转换（由于is-a关系，这样的类型转换是安全的），不允许其他转换。 2.const_cast(expression) 该运算符用于执行只有一种用途的类型转换，即改变之const或volatile其语法与dynamic_cast运算符相同。 3.static_cast(expression) 4.reinterpret_cast(expression) 用于天生危险的类型转换。","link":"/2019/05/24/C++笔记9/"},{"title":"ICP-Registration","text":"点云配准之迭代最近点 A.配准的意义： 两个几何数据集的刚性配准在机器人导航、曲面重建和形状匹配等许多应用中都是必不可少的。最常见的方法是使用迭代最接近点(ICP)算法及其变体来完成这项任务。这些方法在最近点计算之间交替，以建立两个数据集之间的对应关系，并求解使这些对应关系对齐的最优转换。 求解刚体旋转平移关系–配准 B.ICP及其变种 1.最开始的3D icp Besl, Paul J., and Neil D. McKay. “A method for registration of 3-D shapes.” IEEE Transactions on pattern analysis and machine intelligence 14.2 (1992): 239-256. 2.Fast icp（Soft Outlier Rejection） Rusinkiewicz, Szymon, and Marc Levoy. “Efficient variants of the ICP algorithm.” 3-D Digital Imaging and Modeling, 2001. Proceedings. Third International Conference on. IEEE, 2001. 工程：http://gfx.cs.princeton.edu/proj/trimesh2/ 该文章被引用次数极高，文章分析了影响icp的各种因素，对几种icp变体进行比较，并且提出了fast icp。能够在几十毫秒内对齐两张深度图（range images） 3.sparse icp https://github.com/opengp/sparseicp 稀疏ICP方法采用稀疏诱导准则对该问题进行求解，显著提高了配准过程对大量噪声和离群值的恢复能力，但引入了显著的性能退化。 Efficent Sparse icp：结合模拟退火搜索和Sparse ICP 4.广义ICP：Generalized-icp（GICP）https://github.com/avsegal/gicp Segal, Aleksandr, Dirk Haehnel, and Sebastian Thrun. “Generalized-ICP.” Robotics: science and systems. Vol. 2. No. 4. 2009. 5.全局优化ICP：Go-ICPYang, Jiaolong, et al. “Go-ICP: a globally optimal solution to 3D ICP point-set registration.” IEEE transactions on pattern analysis and machine intelligence 38.11 (2016): 2241-2254. C.基于CUDA加速 1.em-icp cuda_emicp_softassign 2.cudaICP**应用** ​ KinectFusion 中的 ICP 算法 GPU 代码解读 D.使用pcl来实现ICP 简单的程序：迭代猴子 E.给出其他参考： Iterative Closest Point (ICP) and other matching algorithms 后台回复“icp”自动回复论文和代码（完）","link":"/2019/05/24/ICP-Registration/"},{"title":"NDT-Registration","text":"点云配准之正态分布变换 精细配准，除了ICP，我用得比较多的就是ndt了。 ndt也可以粗配准。 ndt表现比icp要好。 A.NDT算法介绍： 详细请参考博主AdamShan的博客 https://blog.csdn.net/adamshan/article/details/79230612 B.开源项目： 自动驾驶开源项目中Autoware https://github.com/CPFL/Autoware 利用 fast_pcl package实现了对NDT优化过程的并行加速 C.PCL中的NDT: pcl中的接口在官网和其他博客有详细描述这里不再细说。 调参是主要是设置分别率和步长，分辨率越大考虑的的范围越多，当分辨率很小（对比数据）的时候，会出现内存错误。步长越大，曲面移动A(位姿变换)得越快。 12345678910111213141516171819 pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;​ Setting scale dependent NDT parameters​ ndt.setTransformationEpsilon(0.00001);​ ndt.setStepSize(5);​ ndt.setResolution(5);​ ndt.setMaximumIterations(50);//200​ ndt.setInputSource(filtered_cloud);​ ndt.setInputTarget(target_cloud);​ pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);​ ndt.align(*output_cloud); D.ndt算法和icp比较 http://ghx0x0.github.io/2014/12/30/NDT-match/ 后台回复“ndt”自动回复论文和代码(完）","link":"/2019/05/24/NDT-Registration/"},{"title":"config-PCL-qt-cuda","text":"配置PCL+QT+CUDA 回复：从源码开始编译pcl 获得文档 参考博客 1.http://pointclouds.org/documentation/tutorials/compiling_pcl_windows.php#compiling-pcl-windows 2. https://blog.csdn.net/artista/article/details/50897833 可以忽略网址 步骤 环境： Vs2013 win10 安装了pcl-all-in-one1.8**版本的预编译包（主要用到里面的编译好的第三方库，那么就不用自己来编译第三方库了）** 1． 第一步：安装cuda最新版本（v9.1） 一步一步安装就好了 2． 第二步：下载pcl-master https://github.com/PointCloudLibrary/pcl 3． 第三步：以管理员身份运行cmake（不知是否必要） 4.第四步：设置一些cmake找不到的变量 1.EIGEN_INCLUDE_DIR D:/pcl/3rdParty/Eigen/eigen3 Configure 2.Boost_INCLUDE_DIR D:/pcl/3rdParty/Boost/include/boost-1_59 CONFIGURE 5. 全部勾选上 出现错误 CMake Error at C:/ProgramFiles/CMake/share/cmake-3.11/Modules/FindBoost.cmake:2044 (message):Unable to find the requested Boost libraries. Boost version: 1.59.0 Boost include path: D:/pcl/3rdParty/Boost/include/boost-1_59 Could not find the following static Boost libraries: boost_filesystemboost_threadboost_date_timeboost_iostreamsboost_chronoboost_system Some (but not all) of the required Boost libraries were found. You mayneed to install these additional Boost libraries. Alternatively, setBOOST_LIBRARYDIR to the directory containing Boost libraries or BOOST_ROOTto the location of Boost.Call Stack (most recent call first):cmake/pcl_find_boost.cmake:41 (find_package)CMakeLists.txt:419 (include) 手动将boost库一个一个添加进去 因为预编译的第三方库没有分好类 我手动分类又添加了两个路径 CMake Error at C:/ProgramFiles/CMake/share/cmake-3.11/Modules/FindPackageHandleStandardArgs.cmake:137(message):Could NOT find Gtest (missing: GTEST_INCLUDE_DIR GTEST_SRC_DIR)Call Stack (most recent call first):C:/ProgramFiles/CMake/share/cmake-3.11/Modules/FindPackageHandleStandardArgs.cmake:378(_FPHSA_FAILURE_MESSAGE)cmake/Modules/FindGtest.cmake:35 (find_package_handle_standard_args)test/CMakeLists.txt:11 (find_package) 取消掉globaltest Cmake成功 打开vs2013工程再编译一下 Debug x64 1.All-build 重新生成 除了（example_nurbs_viewer_surface失败其他都成功了） 就不管那个了，因为主要用到gpu和cuda 2.INSTALL重新生成 —————– Releasex64 进行同样的操作 ———————————————————–**解析————————————————————** 1.Cmake**中CMAKE_INSTALL_PREFIX C:/Program Files/PCL** 放了编译出来的库（当前环境下（vs2013）可以用的东西（动态库，可执行文件，静态库）） 动态库放在了bin里面 静态库放在了lib里面 2.whereto build the binaries**：D:/pcl-master/build** 存放的是cmake出来的文件（工程文件）即：构建样例工程及源码的文件 ​ （完）","link":"/2019/05/24/config-PCL-qt-cuda/"},{"title":"about-Keypoints","text":"","link":"/2019/05/24/about-Keypoints/"},{"title":"cudanote1","text":"第三章 简介 缓冲与缓存的区别，核函数，内置参数，参数传递 作者github:littlebearsama 原文链接 (建议下载Typora来浏览markdown文件) 缓冲区(buffer)与缓存区(cache)一、缓冲缓冲区(buffer)，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区，显然缓冲区是具有一定大小的。 缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。 二、缓存 CPU的Cache，它中文名称是高速缓冲存储器，读写速度很快，几乎与CPU一样。由于CPU的运算速度太快，内存的数据存取速度无法跟上CPU的速度，所以在cpu与内存间设置了cache为cpu的数据快取区。当计算机执行程序时，数据与地址管理部件会预测可能要用到的数据和指令，并将这些数据和指令预先从内存中读出送到Cache。一旦需要时，先检查Cache，若有就从Cache中读取，若无再访问内存，现在的CPU还有一级cache，二级cache。简单来说，Cache就是用来解决CPU与内存之间速度不匹配的问题，避免内存与辅助内存频繁存取数据，这样就提高了系统的执行效率。 磁盘也有cache,硬盘的cache作用就类似于CPU的cache，它解决了总线接口的高速需求和读写硬盘的矛盾以及对某些扇区的反复读取。 三、缓存（cache）与缓冲(buffer)的主要区别Buffer的核心作用是用来缓冲，缓和冲击。比如你每秒要写100次硬盘，对系统冲击很大，浪费了大量时间在忙着处理开始写和结束写这两件事嘛。用个buffer暂存起来，变成每10秒写一次硬盘，对系统的冲击就很小，写入效率高了，日子过得爽了。极大缓和了冲击。 Cache的核心作用是加快取用的速度。比如你一个很复杂的计算做完了，下次还要用结果，就把结果放手边一个好拿的地方存着，下次不用再算了。加快了数据取用的速度。 简单来说就是buffer偏重于写，而cache偏重于读。 第三章 简介 将CPU即系统的内存称为主机（host），而将GPU及其内存称为设备（device） 123456789101112131415161718#include&lt;stdio.h&gt;__global__ void add(int a,int b,int *c){ *c = a + b;}int main(){ int c; int *dev_c; cudaMalloc((void**)&amp;dev_c,sizeof(int)); add&lt;&lt;&lt;1,1&gt;&gt;&gt;(2,7,dev_c); cudaMemcpy(&amp;c, dev_c, sizeof(int), cudaMemcpyDeviceToHost); printf(\"2 + 7 = %d\",c); cudafree（dev_c）; return 0;} 1.核函数调用 1.函数的定义带有了__global__这个标签，表示这个函数是在GPU上运行。函数add()将被交给“编译设备代码的编译器”。需要指出的是尽管是在GPU上执行，但是仍然是由CPU端发起调用的。 在每个启动线程中都被调用一遍。 2.主机代码发送给一个编译器，而将设备代码发送给另外一个编译器（CUDA编译器）,CUDA编译器运行时将负责实现从主机代码中调用设备代码。 3.核函数相对于CPU代码是异步的，也就是控制会在核函数执行完成之前就返回，这样CPU就可以不用等待核函数的完成而继续执行后面的CPU代码 4.核函数内部只能访问device内存。因为核函数是执行在设备端，所以只能访问设备端内存。所以要使用cudaMalloc在GPU的内存(全局内存)里开辟一片空间。用来存放结果dev_c。再通过*cudaMemcpy这个函数把内容从GPU**复制出来。 函数部分前缀： 限定符 在哪里被调用 在哪里被执行 __host__（默认缺省） 仅由CPU调用 由CPU执行 __gobal__ 仅由CPU调用 由GPU执行 __device__ 仅由GPU中一个线程调用的函数 由GPU执行 限制： __host__： 限定符无法一起使用 __gobal__： 限定符无法一起使用； 函数不支持递归； 函数的函数体内无法声明静态变量； 函数不得有数量可变的参数； 支持函数指针； 函数的返回类型必须为空； 函数的调用是异步的，也就是说它会在设备执行完成之前返回； 函数参数将同时通过共享存储器传递给设备，且限制为 256 字节； __device__： 函数不支持递归； 函数的函数体内无法声明静态变量； 函数不得有数量可变的参数； 函数的地址无法获取 之前说了__host__和__gobal__限定符无法和其他限定符使用，但与 __device__限定符不是 __constant__ 限定符可选择与 __device__限定符一起使用，所声明的变量具有以下特征： 1.位于固定存储器空间中；2. 与应用程序具有相同的生命周期；3.可通过网格内的所有线程访问，也可通过运行时库从主机访问。 __shared__ 限定符可选择与 __device__限定符一起使用，所声明的变量具有以下特征：1.位于线程块的共享存储器空间中；2. 与块具有相同的生命周期；3.尽可通过块内的所有线程访问。只有在_syncthreads()_的执行写入之后，才能保证共享变量对其他线程可见。除非变量被声明为瞬时变量，否则只要之前的语句完成，编译器即可随意优化共享存储器的读写操作。 2.参数传递 &lt;&lt;&lt;&gt;&gt;&gt;尖括号表示要将一些参数传递给运行时系统，这些参数并不是传递给设备代码的参数，而是告诉运行时如何启动设备代码。传递给设备代码本身的参数是放在圆括号中传递的。 尖括号作用？线程配置。 &lt;&lt;&lt;Dg, Db, Ns, S&gt;&gt;&gt; Dg 的类型为 dim3，指定网格的维度和大小，Dg.x * Dg.y 等于所启动的块数量，Dg.z =1无用，目前还不支持三维的线程格；如果指定Dg=256，那么将有256个线程块在GPU上运行。 Db 的类型为 dim3，指定各块的维度和大小，Db.x * Db.y * Db.z 等于各块的线程数量； Ns 的类型为 size_t，指定各块为此调用动态分配的共享存储器（除静态分配的存储器之外），这些动态分配的存储器可供声明为外部数组的其他任何变量使用，Ns 是一个可选参数，默认值为 0； S 的类型为 cudaStream_t，指定相关流；S 是一个可选参数，默认值为 0。 核函数内部可以调用CUDA内置变量，比如threadIdx，blockDim等。下下章将具体谈到线程索引。 参数传递和普通函数一样，通过括号内的形参传递。","link":"/2019/05/24/cudanote1/"},{"title":"about-Descriptors","text":"","link":"/2019/05/24/about-Descriptors/"},{"title":"cudanote5","text":"第八章 互操作性 OpenGL与互操作性 作者github:littlebearsama 原文链接 (建议下载Typora来浏览markdown文件) 第八章 互操作性GPU的成功要归功于它能实时计算复杂的渲染任务，同时系统的其他部分还可以执行其他工作。 互操作性概念： 通用计算：譬如前面的计算，在GPU上面进行的计算 渲染任务 互操作是指在通用计算与渲染模式之间互操作 提出问题：问1：那么能否在同一个应用程序中GPU既执行渲染计算，又执行通用计算？ 问2：如果要渲染的图像依赖于通用计算的结果，那么该如何处理？ 问3：如果想要在已经渲染的帧上执行某种图像处理或者统计，又该如何实现？ 与OpenGL的互操作性CUDA程序生成图像数据传递给OpenGL驱动程序并进行渲染 1.代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/********************************************************************* SharedBuffer.cu* interact between CUDA and OpenGL*********************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//下面两个头文件如果放反了会出错#include \"GL\\glut.h\"#include \"GL\\glext.h\"#include &lt;cuda_runtime.h&gt;//#include &lt;cutil_inline.h&gt;#include &lt;pcl\\cuda\\cutil_inline.h&gt;#include &lt;cuda.h&gt;#include &lt;cuda_gl_interop.h&gt;#define GET_PROC_ADDRESS(str) wglGetProcAddress(str)#define DIM 512PFNGLBINDBUFFERARBPROC glBindBuffer = NULL;PFNGLDELETEBUFFERSARBPROC glDeleteBuffers = NULL;PFNGLGENBUFFERSARBPROC glGenBuffers = NULL;PFNGLBUFFERDATAARBPROC glBufferData = NULL;// step one:// Step1: 申明两个全局变量，保存指向同一个缓冲区的不同句柄，指向要在OpenGL和CUDA之间共享的数据；GLuint bufferObj;cudaGraphicsResource *resource;__global__ void cudaGLKernel(uchar4 *ptr){ int x = threadIdx.x + blockIdx.x * blockDim.x; int y = threadIdx.y + blockIdx.y * blockDim.y; int offset = x + y * blockDim.x * gridDim.x; //将图像中心设为原点后的像素索引 float fx = x / (float)DIM - 0.5f; float fy = y / (float)DIM - 0.5f; unsigned char green = 128 + 127 * sin(abs(fx * 100) - abs(fy * 100)); ptr[offset].x = 0; ptr[offset].y = green; ptr[offset].z = 0; ptr[offset].w = 255;}void drawFunc(void){ glDrawPixels(DIM, DIM, GL_RGBA, GL_UNSIGNED_BYTE, 0); glutSwapBuffers();}static void keyFunc(unsigned char key, int x, int y){ switch (key){ case 27: cutilSafeCall(cudaGraphicsUnregisterResource(resource)); glBindBuffer(GL_PIXEL_UNPACK_BUFFER_ARB, 0); glDeleteBuffers(1, &amp;bufferObj); exit(0); }}int main(int argc, char* argv[]){ // step 2: // 初始化CUDA // Step2: 选择运行应用程序的CUDA设备(cudaChooseDevice),告诉cuda运行时使用哪个设备来执行CUDA和OpenGL (cudaGLSetGLDevice）； cudaDeviceProp prop; int dev; memset(&amp;prop, 0, sizeof(cudaDeviceProp)); prop.major = 1; prop.minor = 0; cutilSafeCall(cudaChooseDevice(&amp;dev, &amp;prop)); //为CUDA运行时使用openGL驱动做准备 cutilSafeCall(cudaGLSetGLDevice(dev)); //初始化OpenGL //在执行其他的GL调用之前，需要首先执行这些GLUT调用。 glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA); glutInitWindowSize(DIM, DIM); glutCreateWindow(\"CUDA interact with OpenGL\"); glBindBuffer = (PFNGLBINDBUFFERARBPROC)GET_PROC_ADDRESS(\"glBindBuffer\"); glDeleteBuffers = (PFNGLDELETEBUFFERSARBPROC)GET_PROC_ADDRESS(\"glDeleteBuffers\"); glGenBuffers = (PFNGLGENBUFFERSARBPROC)GET_PROC_ADDRESS(\"glGenBuffers\"); glBufferData = (PFNGLBUFFERDATAARBPROC)GET_PROC_ADDRESS(\"glBufferData\"); // Step3：在OpenGL中创建像素缓冲区对象； glGenBuffers(1, &amp;bufferObj); glBindBuffer(GL_PIXEL_UNPACK_BUFFER_ARB, bufferObj); glBufferData(GL_PIXEL_UNPACK_BUFFER_ARB, DIM*DIM * 4, NULL, GL_DYNAMIC_DRAW_ARB);//glBufferData()的调用需要OpenGL驱动程序分配一个足够大的缓冲区来保存DIM*DIM 个32位的值 // step 4: // Step4: 通知CUDA运行时将像素缓冲区对象bufferObj注册为图形资源，实现缓冲区共享。 cutilSafeCall(cudaGraphicsGLRegisterBuffer(&amp;resource, bufferObj, cudaGraphicsMapFlagsNone));//cudaGraphicsMapFlagsNone表示不需要为缓冲区指定特定的行为 //cudaGraphicsMapFlagsReadOnly将缓冲区指定为只读的 //通过标志cudaGraphicsMapFlagsWriteDiscard来制定缓冲区之前的内容应该抛弃，从而使缓冲区变成只写的 uchar4* devPtr; size_t size; cutilSafeCall(cudaGraphicsMapResources(1, &amp;resource, NULL)); cutilSafeCall(cudaGraphicsResourceGetMappedPointer((void**)&amp;devPtr, &amp;size, resource)); dim3 grids(DIM / 16, DIM / 16); dim3 threads(16, 16); cudaGLKernel &lt;&lt; &lt;grids, threads &gt;&gt; &gt;(devPtr); cutilSafeCall(cudaGraphicsUnmapResources(1, &amp;resource, NULL)); glutKeyboardFunc(keyFunc); glutDisplayFunc(drawFunc); glutMainLoop(); return 0;} 2.代码解析： Step1: 申明两个全局变量，保存指向同一个缓冲区的不同句柄，指向要在OpenGL和CUDA之间共享的数据； 12GLuint bufferObj;cudaGraphicsResource *resource; Step2: 选择运行应用程序的CUDA设备(cudaChooseDevice),告诉cuda运行时使用哪个设备来执行CUDA和OpenGL (cudaGLSetGLDevice）cutilSafeCall(cudaChooseDevice(&amp;dev, &amp;prop)); Step3：共享数据缓冲区是在CUDA C核函数和OpenG渲染操作之间实现互操作的关键部分。要在OpenGL和CUDA之间传递数据，我们首先要创建一个缓冲区在这两组API之间使用，在OpenGL中创建像素缓冲区对象；，并将句柄保存在全局变量GLuint bufferObj中： 123glGenBuffers(1, &amp;bufferObj);glBindBuffer(GL_PIXEL_UNPACK_BUFFER_ARB, bufferObj);glBufferData(GL_PIXEL_UNPACK_BUFFER_ARB, DIM*DIM * 4, NULL, GL_DYNAMIC_DRAW_ARB); Step4: 通知CUDA运行时将像素缓冲区对象bufferObj注册为图形资源，实现缓冲区共享。 123cutilSafeCall(cudaGraphicsGLRegisterBuffer(&amp;resource, bufferObj, cudaGraphicsMapFlagsNone)); 互操作性基本上就是调用接口，可以通过GPU Computing SDK的代码示例来学习 与DirectX的互操作性（略）","link":"/2019/05/24/cudanote5/"},{"title":"cudanote8","text":"第十一章 多GPU 零拷贝主机内存，可移动固定的内存 作者github:littlebearsama 原文链接 (建议下载Typora来浏览markdown文件) 第十一章 多GPU零拷贝主机内存 前面使用函数cudaHostAlloc()申请固定内存，并且设定参数cudaHostAllocDefault来获得默认的固定内存。 在函数cudaHostAlloc()使用其他参数值：cudaHostAllocMapped分配的主机内存也是固定的，它与通过cudaHostAllocDefault分配的固定内存有着相同的属性，特别当它不能从物理内存中交换出去或者重新定位时。 这种内存除了可以用于主机和GPU之间的内存复制外，还可以打破第三章主机内存规则之一：可以在CUDA C核函数中直接访问这种类型的主机内存。由于这种内存不需要复制到GPU，因此也称为零拷贝内存 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455float cuda_pinned_alloc_test(int size) { cudaEvent_t start, stop; float *a, *b, c, *partial_c; float *dev_a, *dev_b, *dev_partial_c; float elapsedTime; cudaEventCreate(&amp;start); cudaEventCreate(&amp;stop); // allocate the memory on the CPU cudaHostAlloc((void**)&amp;a, size * sizeof(float), cudaHostAllocWriteCombined | cudaHostAllocMapped); cudaHostAlloc((void**)&amp;b, size * sizeof(float), cudaHostAllocWriteCombined | cudaHostAllocMapped); cudaHostAlloc((void**)&amp;partial_c, blocksPerGrid * sizeof(float), cudaHostAllocMapped); // find out the GPU pointers cudaHostGetDevicePointer(&amp;dev_a, a, 0); cudaHostGetDevicePointer(&amp;dev_b, b, 0); cudaHostGetDevicePointer(&amp;dev_partial_c, partial_c, 0); // fill in the host memory with data for (int i = 0; i &lt; size; i++) { a[i] = i; b[i] = i * 2; } cudaEventRecord(start, 0); dot &lt;&lt; &lt;blocksPerGrid, threadsPerBlock &gt;&gt; &gt;(size, dev_a, dev_b, dev_partial_c); cudaThreadSynchronize(); cudaEventRecord(stop, 0); cudaEventSynchronize(stop); cudaEventElapsedTime(&amp;elapsedTime, start, stop); // finish up on the CPU side c = 0; for (int i = 0; i &lt; blocksPerGrid; i++) { c += partial_c[i]; } //无论使用什么标志都使用这个函数来释放 cudaFreeHost(a); cudaFreeHost(b); cudaFreeHost(partial_c); // free events cudaEventDestroy(start); cudaEventDestroy(stop); printf(\"计算结果: %f\\n\", c); return elapsedTime;} cudaHostAllocMapped：这个标志告诉运行时将从GPU中访问这块内存（分配零拷贝内存） cudaHostAllocWriteCombined：这个表示，运行时将内存分配为“合并式写入（Write-Combined）”内存。这个标志并不会改变应用程序的功能，但却可以显著地提升GPU读取内存时的性能。然而CPU也要读取这块内存时，“合并式写入”会显得很低效。 cudaHostGetDevicePointer：获取这块内存在GPU上的有效指针。这些指针将被传递给核函数。 cudaThreadSynchronize()：将CPU与GPU同步，在同步完成后面就可以确信核函数已经完成，并且在零拷贝内存中包含了计算好的结果。 零拷贝内存的性能 所有固定内存都存在一定的局限性，零拷贝内存同样不例外：每个固定内存都会占用系统的可用物理内存，这终将降低系统的性能。(只用在使用一次的情况的原因) 使用零拷贝内存通常会带来性能的提升，因为内存在物理上与主机是共存的。将缓冲区声明为零拷贝内存的唯一作用就是避免不必要的数据复制。 当输入内存和输出内存都只是用一次时，那么独立GPU上使用零拷贝内存将带来性能提升。如果多次读取内存，那么最终将得不偿失，还不如一开始将数据复制到GPU。 使用多个GPUNVIDIA一个显卡可能包含多个GPU。例如GeForce GTX 295、Tesla K10。虽然GeForce GTX 295物理上占用一个扩展槽，但在CUDA应用程序看来则是两个独立的GPU。 将多个GPU添加到独立的PCIE槽上，通过NVIDIA的SLI技术将他们桥接。 略。。。 可移动的固定内存—使得多个GPU共享固定内存问题： 固定内存实际上是主机内存，只是该内存页锁定在物理内存中，以防止被换出或重定位。然而这些内存页仅对于单个GPU线程（书上写的是单个CPU线程）来说是“固定的”，如果某个线程分配了固定内存，那么这些内存页只是对于分配它们的线程来说是页锁定的。如果在线程之间共享指向这块内存的指针，那么其他的线程把这块内存视为标准的、可分页的内存。 副作用：当其他线程（不是分配固定内存的线程）试图在这块内存上执行cudaMemcpy()时，将按照标准的可分页内存速率来执行复制操作。这种速率大约为最高传输速度的50%。更糟糕的时，如果线程视图将一个cudaMemcpyAsync()调用放入CUDA流的队列中，那么将失败，因为cudaMemcpyAsync()需要使用固定内存。由于这块内存对于除了分配它线程外的其他线程来说视乎是可分页的，因为这个调用会失败，甚至导致任何后续操作都无法进行。 解决： 可以将固定内存分配为可移动，这意味着可以在主机线程之间移动这块内存，并且每个线程都将其视为固定内存。 使用cudaHostAlloc()来分配内存，并在调用时使用一个新标志：cudaHostAllocPortable这个标志可以与其他标志一起使用，例如cudaHostAllocWriteCombined和cudaHostAllocMapped这意味着分配主机内存时，可以将其作为可移动，零拷贝以及合并写入等的任意组合。","link":"/2019/05/24/cudanote8/"},{"title":"cudanote6","text":"第九章 原子性 计算功能集、原子操作、计算直方图 作者github:littlebearsama 原文链接 (建议下载Typora来浏览markdown文件) 第九章 原子性1.计算功能集 不同架构的CPU有着不同的功能和指令集（例如MMX、SSE(70条指令)、SSE2(使用了144个新增指令)等） 对于支持CUDA的不同图形处理器来说同样如此。NVIDIA将GPU支持的各种功能统称为计算功能集（Compute Capability）。 基于最小功能集的编译 要支持全局内存原子操作，计算功能集的最低版本为1.1 当编译代码时，你需要告诉编译器：如果硬件支持的计算功能集版本低于1.1，那么将无法运行这个核函数。 要将这个信息告诉编译器，只需在调用NVCC时增加一个命令行选项：nvcc -arch=sm_11 当设置的计算能力比硬件本身高比如计算能力是6.1的（1080TI），设置 compute=62，sm=62 会出现错误，kernel不会被执行。 在.cu文件设置自己硬件的计算能力，如果不去设置或者去设置比较低的计算能力，比如设置compute_30,sm_30，那么自然地编译出来的程序的性能就会打折扣。 2.原子操作示例： x++；包含三步操作：a.读取x中的值；b.将步骤1中读到的值增加1；c.将递增后的结果写回到x。 现在考虑线程A和B都需要执行上面三个操作，如果线程调度方式不正确，那么最终将（可能，因为六个步骤也可能会排出正确的结果）得到错误的结果； 解决： 我们需要通过某种方式一次性执行完读取-修改-写入这三个操作，并且在执行过程中不会被其他线程所中断。我们将满足这些条件限制的操作称为原子操作。 CUDA C支持多种原子操作，当有数千个线程在内存访问上发生竞争时，这些操作能够确保在内存上实现安全的操作。 3.计算直方图概念：给定一个包含一组元素的数据集，直方图表示每个元素出现的频率。 在利用cpu实现的程序中，统计函数是： 123//统计 for (int i=0; i&lt;SIZE; i++) histo[buffer[i]]++; 在GPU计算中，计算输入数组的直方图存在一个问题，即多个线程同时对输出直方图的同一个元素进行递增。在这种情况下，我们需要通过原子的递增操作来避免上面提到的问题。 1.GPU代码：123456789101112131415161718192021222324252627//声明变量 unsigned int *dev_histo; HANDLE_ERROR( cudaMalloc( (void**)&amp;dev_histo, 256 * sizeof( int ) ) ); //代码块内的变量一定要手动初始化 HANDLE_ERROR( cudaMemset( dev_histo, 0, 256 * sizeof( int ) ) );...............__global__ void histo_kernel( unsigned char *buffer, long size, unsigned int *histo ) { int i = threadIdx.x + blockIdx.x * blockDim.x; int stride = blockDim.x * gridDim.x; while (i &lt; size) { atomicAdd( &amp;histo[buffer[i]], 1 ); i += stride; }}.............. // kernel launch - 2x the number of mps gave best timing cudaDeviceProp prop; HANDLE_ERROR( cudaGetDeviceProperties( &amp;prop, 0 ) ); int blocks = prop.multiProcessorCount; histo_kernel&lt;&lt;&lt;blocks*2,256&gt;&gt;&gt;( dev_buffer, SIZE, dev_histo ); 这里的atomicAdd就是同时只能有一个线程操作，防止了其他线程的骚操作。 引入了一个新的CUDA运行时函数，cudaMemset()函数，用于内存空间初始化。 由于直方图包含了256个元素，因此可以在每个线程块中包含256个线程 通过一些性能实验，我们发现当线程块的数量为GPU数量的2倍是，将达到最佳性能。 由于核函数中只包含非常少的计算工作，因此很可能是全局内存上的原子操作导致性能的降低，当数千个线程尝试访问少量的内存位置是，将发生大量的竞争。 2.改进版： 使用共享内存和全局内存原子操作的直方图核函数 123456789101112131415161718192021222324252627282930#define SIZE (100*1024*1024)__global__ void histo_kernel( unsigned char *buffer, long size, unsigned int *histo ) { __shared__ unsigned int temp[256];//声明一个共享缓冲区 temp[threadIdx.x] = 0; //将清除内存，每个线程写一次，由于我们在核函数设置启动线程中 //为每个block分配了256个线程，所以很容易清除累计缓冲区temp。 __syncthreads(); int i = threadIdx.x + blockIdx.x * blockDim.x; int stride = blockDim.x * gridDim.x;//因为线程数没有数据多所以要设定步长（步长为分配的线程数目） while (i &lt; size) { atomicAdd( &amp;temp[buffer[i]], 1 ); i += stride; } __syncthreads(); atomicAdd( &amp;(histo[threadIdx.x]), temp[threadIdx.x] );}············· cudaDeviceProp prop; HANDLE_ERROR( cudaGetDeviceProperties( &amp;prop, 0 ) ); int blocks = prop.multiProcessorCount; histo_kernel&lt;&lt;&lt;blocks*2,256&gt;&gt;&gt;( dev_buffer, SIZE, dev_histo ); 在共享内存中计算这些直方图，这将避免每次将写入操作从芯片发送到DRAM，现在只有256个线程在256个地址上发生竞争，这将极大地减少在全局内存中数千个线程之间发生竞争的情况。","link":"/2019/05/24/cudanote6/"},{"title":"cudanote9","text":"第十二章 后记 CUDA 工具 作者github:littlebearsama 原文链接 (建议下载Typora来浏览markdown文件) 第十二章 后记CUDA工具 CUFFT：快速傅立叶变换 CUBLAS：线性代数函数 实例程序：NVIDIA GPU Computing SDK NVIDIA性能原语（NPP）：高性能图像处理或视频应用程序 调试工具NVIDIA Parallel Nsight 其他设备信息Device: &lt;GeForce GTX 1080 Ti&gt; canMapHostMemory: Yes CUDA Capable: SM 6.1 hardware 28 Multiprocessor(s) x 128 (Cores/Multiprocessor) = 3584 (Cores)","link":"/2019/05/24/cudanote9/"},{"title":"how-to-start-PCL","text":"如何开始学习PCL点云库 写下博主学习点云的过程中的心得（后面链接提供参考资料） 建议： 首先推荐不要自己编译源码，建议安装all-in-one能够满足大部分人的需求。 其次先实现基本功能再配置QT，可能qvtk插件会有点麻烦 如有需要再安装cuda 资源： 学习资源 a.官网文档http://pointclouds.org/documentation/ b.微信公众号：点云PCL c.微信公众号：泡泡机器人SLAM，里面做slam关于点云的也是比较多的。 d.书《点云库PCL从入门到精通》 遇到问题 a.首先想着自己解决，在pcl邮件记录里面有很多别人遇到过的问题，可以先找一下有没有相似的再问别人。pcl-mailing-list：http://www.pcl-users.org/ b.加两个比较活跃的PCL点云库群： 点云库PCL旗舰群512254255、 dianyunPCL微信公众号群327490147 群里面有很多活跃的人，有问题问大神。 数据集 a.Stanford PCD Data里面有许多测试用的点云，典型的兔子bunny。 b.kitti，用于点云配准的遥感激光（车载或机载的）点云数据集。 c.室内物体rgbd数据集 d.SIXD Challenge 2017数据集 下面参考：3D-Machine-Learning e.点云深度学习数据集： ShapeNet; ShapeNetSem; ModelNet; 对应的imageNet中每一类的图像PASCAL3D+; 大型三维仿真数据集ABC dataset; 佐治亚理工大型几何模型数据集 用得最多的处理点云的必备软件（好用又开源） a.cloudcompare非常好用，可以进行点云查看，配准，剪裁，格式转换等 b.meshlab，可以对网格点云等进行处理，集成了大部分重建，分割等算法 一些知识点： 两种数据结构：kdtree和octree kdtree： octree： kdtree和octree都是两种计算机数据结构。可以简单理解为建立这些数据结构是为了方便我们进行三维空间检索。 kdtree用来组织表示k维空间中点的集合， 1.PCL中kdtree库提供了kdtree数据结构。基于FLANN（快速近邻算法）进行快速近邻查询即帮助你找到最近的几个点。有了近邻点的信息可以计算特征描述子（feature descriptor）用于描述该点的特征，建立kdtree可以简单理解为通过kdtree帮助你找到每个点的邻居，具体描述请看文档。 2.PCL中octree可以理解为：通过循环递归划分空间为八个子立方体来进行空间细分，octree的编码知道每个点云所在的octree空间，递归的次数越多就使得划分的空间越细。同样的，octree也可以像kdtree一样进行FLANN，邻域检索，邻域的特征提取，计算描述符等。另外还有一些相应的空间处理算法比如：压缩，空间变化检测。通过空间变化检测来提取两个点云的差异非常好用。 kdtree和octree具体内容会有相关的详细文档，放在百度云。 随机采样一致性算法RANSAC RANSAC是一种随机参数估计算法。RANSAC从样本中随机抽选出一个样本子集，使用最小方差估计算法对这个自己计算模型参数。 PCL中利用RANSAC实现了随机采样一致性及其范化估计算法。 用不同的估计算法和不同的几何模型结合来估算点云中隐藏的具体几何模型的系数。 实例：用平面模型对常见的室内点云进行平面分割提取，比如墙，地板，桌面等，或者用圆柱体分割出一个圆柱体的杯子。 关键点与特征描述符 在另外的文章会给出 点云精确配准 在另外的文章会给出 点云分割 点云分割是根据空间，几何和纹理等特征对点云进行划分。 点云分割可以划分为下面几种： a.基于模型分割 b.平面滤波 c.法线估计 d.区域成长法 e.欧式聚类 曲面处理与重建 pcl里面有很多曲面重建的算法，也可以通过先前提到的meshlab软件先进行可行性验证，再去编写代码。 我举一些曲面处理与曲面重建的算法出来，给大家参考一下。 使用双边滤波（Bilateral Filtering）进行上采样 使用移动最小二乘法（Moving Least Squares）进行上采样 3.使用Poisson算法进行表面重建 曲面重建还有多的其他算法，具体可以参照pcl官网的例程或者查看pcl的类定义来获取具体信息。 上述文档输入关键字“开始”获得百度云链接（完）","link":"/2019/05/24/how-to-start-PCL/"},{"title":"C++ 笔记2","text":"第5～8章 函数 函数函数—C++的编程模块（要提高编程效率，可更深入地学习STL和BOOST C++提供的功能） 1.提供函数定义 function definition 2.提供函数原型 function prototype 3.调用函数 function call 12345Void functionName(parameterlist){statement(s)teturn;} parameterlist:指定了传递给函数的参数类型和数量 void:没有返回值，对于有返回值的函数，必须有返回语句return 1.返回值类型有一定的喜爱内置：不能是数组，但可以是其他任何类型—整数，浮点数，指针，甚至可以是结构和对象。 2.函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。 为什么需要原型原型描述了函数到编译器的接口，它将1.函数返回值类型（如果有的话）以及2.参数的类型和3.数量告诉编译器。（在原型的参数列表中，可以包含变量名，也可以不包含。原型中的变量名相当于占位符，因此不必与函数中的变量名相同） 确保：编译器正确处理1，编译器检查2，3 函数参数传递和按值传递 用于接收传递值的变量被称为形参（parameter），传递给函数的值被称为实参（argument）。 值传递：调用函数时，使用的是实参的副本，而不是原来的数据。 在函数中声明的变量（局部变量（自动变量））（包括参数）是该函数私有的，函数调用时：计算机将为这些变量分配内存；函数结束时：计算机将释放这些变量使用的内存。 函数和数组123int sum_arr(int arr[],int n);//arr=arrayname.n=sizeint sum_arr(int arr[],int n);//arr=arrayname.n=size//两者是等价的 const保护数组（输入数组原数据不能改变）void show_array(const double ar[],int n);//声明形参时使用const关键字 该声明表明，指针or指向的是常量数据。这意味着不能使用or修改数据。这并不意味着原始数据必须是常量 如果该函数要修改数组的值，声明ar时不能使用const 1.对于处理数组的C++函数，必须将数组中的 1.数据类型 2.数组的起始位置 3.和数组元素中的数量提交给他 传统的C/C++方法是，将指向数组起始处的指针作为一个参数，将数组长度作为第二个参数（指针指出数组位置和数据类型） 2.第二种方法：指定元素区间（range）通过传递两个指针来完成：一个指针表示数组的开头，另外一个指针表示数组的尾部。例子：12345678910int sum_arr(const int *begun,const int *end){const int *pt;int total=0;for(pt=begin;pt!=end;pt++)total=toatl+*pt;return total;}int cookies[ArSize]= {1,2,4,8,16,32,64,128};int sum=sum_arr(cookies,cookies+ArSize); 函数与C风格字符串假设要将字符串（实际传递的是字符串第一字符的地址）作为参数传递给函数，则表示字符串的方式有三种： 1.char数组 2.用隐含阔气的字符串常量 3.被设置为字符串的地址的char指针。 函数和结构涉及函数时，结构变量的行为更接近基于基本的单值变量 1.按值传递–&gt;如果结构非常大，则复制结构将增加内存要求，且使用的是原始变量的副本 2.传递结构的地址，然后使用指针来访问结构的内容 1234567rect rplace;polar pplace;void rect_to_polar(const rect*pxy,polar*pda){...}rect_to_polar(&amp;rplace,&amp;pplace); 调用函数时，将结构的地址（&amp;pplace）而不是结构本身（pplace）传递给它；将形参声明为指向polar的指针，即polar*类型。由于函数不应该修改结构，因此使用了const修饰符，由于形参是指针不是结构，因此应使用姐姐成员运算符(-&gt;)，而不是成员运算符（.）。 3.按引传递用，传指针和传引用效率都高，一般主张是引用传递代码逻辑更加紧凑清晰。 递归—C++函数有一种有趣的特点–可以调用自己（除了main()）1.包含一个递归调用的递归 1234567void recurs(argumentlist){statement1if(test)recurs(arguments)statement2} 如果调用5次recurs就会运行5次statement1，运行1次statement2. 2.包含多个递归调用的递归 12345678void recurs(argumentlist){if(test)return;statement;recurs(argumentlist1);recurs(argumentlist2);} 3.从1加到n 12345678910class Solution{public:int Sum_Solution(int n){int ans=n;ans&amp;&amp;(ans+=Sum_Solution(n-1));return ans;}};//&amp;&amp;就是逻辑与，逻辑与有个短路特点，前面为假，后面不计算。 函数指针函数也有地址—存储其机器语言代码的内存的开始地址 获取函数的地址，只要使用函数名（后面不跟参数）即可。 例如think()是个函数 1234567891011process(think);//传递的是地址thought(think());//传递的是函数返回值//使用double pam(int);//原始函数声明double (*pf)(int);//函数指针声明pf=pam;//使用指针指向pam函数double x=pam(4);//使用函数名调用pam()double y=(*pf)(5);//使用指针调用pam()//也可以这样使用函数指针double y=pf(5); 进阶下面函数原型的特征表和返回类型相同123456789const double *f1(const double ar[],int n);const double *f2(const dopuble [],int );const double *f3(const double *,int );//声明一个指针可以指向f1，f2，f3const double * (*p1)(const double *,int );//返回类型相同，函数的特征标相同//声明并初始化const double * (*p1)(const double *,int )=f1;//也可以使用自动类型推断auto p2=f2; 使用for循环通过指针依次条用每个函数 例子：声明包含三个函数指针的数组，并初始化 const double * (*pa[3])(const double *,int)={f1,f2,f3}; 问：为什么不使用自动类型推断？auto 答：因为自动类型推断只能用于单值初始化，而不能用初始化列表。 但可以声明相同类型的数组 auto pb=pa; 使用： 123456const double *px=pa[0](av.3);//两种表示法都可以const double *py=pb[1](av.3);//创建指向整个数组的指针。由于数组名pa是指向函数指针的指针auto pc=&amp;pa;//c++11//等价于const double * (*(*pd[3]))(const double *,int)=&amp;pa;//C++98 除了auto外，其他简化声明的工具，typedef进行简化点云库里常常用到,如:typedef pcl::PointNormal PointNT 12typedef const double * (*p_fun)(const double *,int );p_fun p1=f1; 函数探幽C++11新特性 函数内联 按引用传递变量 默认参数值 函数重载（多态） 模板函数 内联函数c++内联函数–&gt;提高程序运行速度：常规函数与内联函数的区别在于,C++编译器如何将它们组合到程序中 常规函数调用过程： 执行到函数调用指令程序在函数调用后立即存储该指令地址，并将函数参数复制到堆栈中(为此保留的代码)， 跳到标记起点内存单元， 执行函数代码（也许将返回值放入寄存器中）， 然后跳回地址被保存的指令处。 来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。 情况：函数代码执行时间很短—内联调用就可以节省非内联调用的大部分时间（节省时间绝对值并不大） 代价：需要占用更多的内存：如果程序在是个不同地方调用一个内联函数，则该函数将包含该函数代码的10个副本 使用： 在函数声明前加上关键字inline； 在函数定义前加上关键字inline； 通常的做法是省略原型，将整个定义（即函数头和所有代码），放在本应提供原型的地方。 内联函数不能递归 如果函数占用多行（假设没有冗长的标识符），将其作为内联函数不太合适. 内联与宏C语言使用预处理语句#define来提供宏—内联代码的原始实现 1# define SQUARE(X) X*X 这不是通过传递参数实现的,而是通过文本替换实现的—X是”参数”的符号标记。所以宏不能按值传递 故有时候会出现错误 12c=10;d=SQUARE(C++);is replaced by d=C++*c++=11X12=122 按引用传递变量引用变量–&gt;是复合类型int &amp; rodents =rats;其中int &amp;是类型，该声明允许将rats和rodent互换—他们指向相同的值和内存单元。 必须在声明引用变量时进行初始化 引用更接近const指针(指向const数据的指针)，必须在创建时进行初始化，一旦与某个变量关联起来就一直效忠于它。12345int &amp; rodents=rats;//实际上是下述代码的伪装表示int * const pr=&amp;rats;//引用rodents扮演的角色与*pr相同。//*pr值是个地址，且该地址恒等于&amp;rat--&gt;rats的地址 引用的属性与特别之处应该尽可能使用constC++11新增了另外一种引用—右值引用。这种引用可指向右值，是使用&amp;&amp;声明的：第十八章将讨论如何使用右值引用来实现移动语义（move semantics）,以前的引用（使用&amp;声明的引用）现在称为左值引用 右值引用是对临时对象的一种引用，它是在初始化时完成的，但右值引用不代表引用临时对象后，就不能改变右值引用所引用对象的值，仍然可以初始化后改变临时对象的值 右值短暂，右值只能绑定到临时对象。所引用对象将要销毁或没有其他用户 初始化右值引用一定要用一个右值表达式绑定。 例子： 123double &amp;&amp;rref=std::sqrt(36.00);//在左值引用中不成立，即使用&amp;来实现也是不允许的double j=15.0;double&amp;&amp; jref=2.0*j+18.5;//同样使用左值引用是不能实现的。 将引用用于结构引用非常适合用于结构和类(C++用户定义类型)而不是基本的内置类型。 声明函数原型，在函数中将指向该结构的引用作为参数：void set_pc(free_throws &amp; tf);如果不希望函数修改传入的结构。可使用const；void display(free_throws &amp; tf); 返回引用：free_throws &amp;accumlate(free_throws&amp; traget,free_throws&amp; source);为何要返回引用？如果accumlate()返回一个结构，如：dup=accumlate(team,five) 而不是指向结构的引用。这将把整个结构复制到一个临时位置，再将这个拷贝复制给dup。但在返回值为引用时，直接把team复制到dup，其效率更高，复制两次和复制一次的区别。 应避免返回函数终止时，不在存在的内存单元引用。为避免这种问题，最简单的方法是，返回一个作为参数传递给函数的引用。作为参数的引用指向调用函数使用的数据，因此返回引用也将指向这些数据。 1234567free_throws&amp; accumlate(free_throws&amp; traget,free_throws&amp; source){traget.attempts+=source.attempts;traget.mode+=source.mode;set_pc(target);return target;} 另一种方法是用new来分配新的存储空间 1234567const free_throws&amp; clone(&amp;three){free_throws * pt;//创建无名的free_throws结构，并让指针pt指向该结构，因此*pt就是该结构，在不需要new分配的内存时，应使用delete来释放它们。 //auto_ptr模板以及unique_ptr可帮助程序员自动完成释放* pt=ft；return *pt;//实际上返回的是该结构的引用} 将引用用于对象和结构同理 对象继承和引用使得能够将特性从一个类传递给另外一个类的语言被称为继承 ostream–&gt;基类 ofstream–&gt;派生类 基类引用可以指向派生类对象，而无需强制类型转换 时使用引用参数使用引用参数到主要原因有两个： （1）程序员能够修改调用函数中的数据对象。 （2）通过传递引用而不是整个数据对象，可以提高程序的运行速度。 当数据对象较大时（如结构和类对象），第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于指针的代码的另一个接口。那么什么时候应该使用引用，什么时候应该使用指针呢？什么时候应该按值传递呢？下面是一些指导原则： 对于使用传递到值而不做修改到函数： （1）如果数据对象很小，如内置数据类型或小型结构，则按值传递。 （2）如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。 （3）如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需要的时间和空间。 （4）如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。 对于修改调用函数中数据的函数： （1）如果数据对象是内置数据类型，则使用指针。如果看到诸如fixit(&amp;x)这样的代码（其中x是int），则很明显，该函数将修改x。 （2）如果数据对象是数组，则只能使用指针。 （3）如果数据对象是结构，则使用引用或指针。 （4）如果数据对象是类对象，则使用引用。 当然，这只是一些指导原则，很可能有充分到理由做出其他的选择。例如，对于基本类型，cin使用引用，因此可以使用cin&gt;&gt;n，而不是cin&gt;&gt;&amp;n。 默认参数值—当函数调用中省略了实参时自动使用的一个值如何设置默认值？**必须通过函数原型 char* left(const char* str,int n=1);原型声明 定义长这样 char * left(const char* str,int n){…} 对于带参数列表的函数，必须从左向右添加默认值：下面代码错误，int j应该也设默认值 1int chico(int n,int m=6,int j);//fault 通过默认参数，可以减少要定义的析构函数，方法以及方法重载的数量 函数重载 默认参数让你能够使用不同数目的参数调用的同一个函数。 而函数多态（函数重载）让你能够使用多个同名函数。 仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应用函数重载 C++使用名称修饰（名称矫正）来跟踪每一个重载函数 未经过修饰：long MyFunction(int,float); 名称修饰（内部转换）：?MyFunctionFoo@@YAXH—&gt;将对参数数目和类型进行编码 重载与多态的区别 重载：是指允许存在多个同名方法，而这些方法的参数不同(特征标不同)。重载的实现是：编译器根据方法不同的参数表，对同名方法的名称做修饰，对于编译器而言，这些同名方法就成了不同的方法。他们的调用地址在编译器就绑定了。**重载，是在编译阶段便已确定具体的代码，对同名不同参数的方法调用（静态联编） C++中，子类中若有同名函数则隐藏父类的同名函数，即子类如果有永明函数则不能继承父类的重载。 多态：是指子类重新定义父类的虚方法（virtual,abstract）。当子类重新定义了父类的虚方法后，父类根据赋给它的不同的子类，动态调用属于子类的方法，这样的方法调用在编译期间是无法确定的。（动态联编）。对于多态，只有等到方法调用的那一刻，编译器才会确定所要调用的具体方法。 重载与覆盖的区别 重载要求函数名相同，但是参数列列表必须不不同，返回值可以相同也可以不不同。覆盖要求函数名、参数列列表、返回值必须相同。 在类中重载是同一个类中不同成员函数之间的关系在类中覆盖则是⼦子类和基类之间不同成员函数之间的关系 重载函数的调用是根据参数列表来决定调用哪一个函数 覆盖函数的调用是根据对象类型的不不同决定调用哪一个 在类中对成员函数重载是不不能够实现多态 在子类中对基类虚函数的覆盖可以实现多态 模板函数—通用的函数描述 用于函数参数个数相同的类型不同的情况，如果参数个数不同，则不能那个使用函数模板 函数模板自动完成重载函数的过程。只需要使用泛型和具体算法来定义函数，编译器将为程序使用特定的参数类型生成正确的函数定义 函数模板允许以任意类型的方式来定义函数。例如，可以这样建立一个交换模板 12345678template &lt;typename AnyType&gt;void Swap(AnyType &amp;a,AnyType &amp;a){AnyType temp;temp=a;a=b;b=temp;} 模板不会创建任何函数，而只是告诉编译器如何定义函数 C++98没有关键字typename，使用的是template&lt;class AnyType&gt;void Swap(AnyType &amp;a,AnyType &amp;a){...} 函数模板不能缩短可执行程序，最终仍将由两个独立的函数定义，就像以手工方式定义了这些函数一样。最终的代码不包含任何模板，只包含了为程序生成的实际函。使用模板的寒除湿，它使生成多个函数定义更简单，更可靠更常见的情形是将模板放在头文件中，并在需要使用模板的文件中包含头文件 重载的模板对多个不同类型使用同一种算法（和常规重载一样，被重载的模板的函数特征标必须不同）。 1234template &lt;typename T&gt;void Swap(T&amp; a,T&amp; b);template &lt;typename T&gt;void Swap(T* a,T* b,int n); 模板的局限性：编写的模板很可能无法处理某些类型 如1.T为数组时，a=b不成立；T为结构时a&gt;b不成立 解决方案： C++允许重载运算符，以便能够将其用于特定的结构或类 为特定类型提供具体化的模板定义 显式具体化（explicit specialization）提供一个具体化函数定义，其中包含所需的代码，当编译器找到与函数调用匹配的具体化定义时，将使用该定义，不再寻找模板。 该内容在代码重用中有不再重复。 重载解析(overloading resolution)—编译器选择哪个版本的函数对于函数重载，函数模板和函数模板重载，C++需要一个定义良好的策略，来决定为函数调用哪一个函数定义，尤其是有多个参数时 过程： 创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。 使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式的转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。例如，使用float参数的函数调用可以将该参数转换为double，从而与double形参匹配，而模板可以为float生成一个实例。 确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错。 最佳到最差的顺序： 完全匹配，但常规函数优先于模板 提升转换（例如，char和shorts自动转换为int ,float自动转换为double）。 标准转换（例如，int转换为char,long转换为double）。 用户定义的转换，如类声明中定义的转换。 完全匹配：完全匹配允许的无关紧要转换 从实参到形参 到实参 Type Type &amp; Type &amp; Type Type[] * Type Type(argument-list) Type( * )(argument-list) Type const Type Type volatile Type Type* const Type Type* volatile Type ***","link":"/2019/05/23/C++笔记2/"},{"title":"C++ 笔记8","text":"第14章 C++中的代码重用 14C++中的代码重用（公有继承，包含对象的类，私有继承，多重继承，类模板）包含（containment）：包含对象成员的类本身是另外一个类的对象。这种方法称为包含（containment），组合（composition），或层次化（laying） 私有继承（还是has-a关系）基类的公有成员和保护成员都将成为派生类的私有成员。和公有继承一样，基类的私有成员是会被派生类继承但是不能被派生类访问。基类方法将不会成为派生类对象公有接口的一部分，但可以在派生类中使用它们。 1.初始化基类组件 和包含不同，对于继承类的新版本的构造函数将使用成员初始化列表语法，它使用类名（std::string，std::valarry）而不是成员名来表示构造函数 1234567891011121314//Student类私有继承两个类派生而来,本来包含的时候两个基类分别是name和scoreclass Student:private std::string,private std::valarry&lt;double&gt;{public:......};//如果是包含的构造函数Student(const char *str,const double *pd,int n):name(str),score(pd,n){}//继承类的构造函数 Student(const char *str,const double *pd,int n):std::string(str),std::valarry&lt;double&gt;(pd,n){} 2.访问基类的方法 a.包含书用对象（对象名）来调用方法 b.私有继承时，将使用类名和作用域解析运算符来调用方法 1234567double Student::Average() const{if(ArrayDb::size()&gt;0）//ArrayDb typedef为std::valarry&lt;double&gt; return ArrayDb::sum()/ArrayDb::size();else return 0;} 3.访问基类对象 使用私有继承时，该string对象没有名称。那么，student类的代码如何访问内部string对象呢？ 强制类型转换! 本来子到父自动类型提升,不需要强制类型转换。父到子才需要强制类型转换。但是下面是强制类型转换，原因在第4点那里写着。 由于Student类是从string类派生而来的，因此可以通过强制类型转换，将Student对象转换为S=string对象 123456//成员方法：打印出学生的名字//因为不是包含，只能通过强制类型转换const string &amp; Student::Name()const{retrun (const string &amp;) *this;} 4.访问基类友的元函数 用类名显式地限定函数名不适合友元函数，因为友元不属于类。不能通过这种方法访问基类。 解决：通过显示地转换为基类来调用正确的函数 1234osstream &amp; operator&lt;&lt;(ostream &amp; os,const Student &amp; stu){os &lt;&lt; \"Score for \"&lt;&lt;(const String &amp;) stu &lt;&lt;\":\\n\";//显式地将stu转换为string对象引用，进而调用基类方法} 引用不会自动转换为string引用原因： a.在私有继承中，未进行显示类型转换的派生类引用或指针，无法赋值给基类的引用或指针。 b.即使这个例子使用的是公有继承，也必须使用显示类型转换。原因之一是，如果不使用类型转换，下述代码将无法与函数原型匹配从而导致递归调用，os&lt;&lt;stu c.由于这个类使用的是多重继承，编译器将无法确定应转换成哪个基类，如果两个基类都提供函数operator&lt;&lt;()。 5.使用包含还是私有继承？通常，应使用包含来建立has-a关系；如果新需要访问原有的保护成员，或重新定义虚函数，则应使用私有继承。 6.保护继承 基类的公有成员和保护成员都将成为派生类的保护成员。 共同点：和私有继承一样，基类的接口在派生类中也是可用的，但在继承和结构之外是不可用的。 区别：使用私有继承时，第三代类将不能使用基类的接口，这是因为公有方法在派生类中将变成私有方法；使用保护继承时，基类的公有方法在第二代将变成保护的，因此第三代派生类可以使用它们。 特征 公有继承 保护继承 私有继承 公有成员变成 派生类的公有成员 派生类的保护成员 派生类的私有成员 保护成员变成 派生类的保护成员 派生类的保护成员 派生类的私有成员 私有成员变成 只能通过基类接口访问 只能通过基类接口访问 只能通过基类接口访问 能否隐式向上转换 是 是（但只能在派生类中） 否 7.使用using重新定义访问权限使用派生或私有派生时，基类的公有成员将成为保护成员或私有成员，假设要让基类方法在派生类外面可用 方法1，定义一个使用该基类方法的派生类方法 1234double Student::sum() const{return std::valarray&lt;double&gt;::sum();} 方法2，将函数调用包装在另外一个函数调用中，即使用一个using声明（就像空间名称一样） 1234567class Student::private std::string,private std::valarray&lt;double&gt;{...public: using std::valarray&lt;double&gt;::min; using std::valarray&lt;double&gt;::max;} //using声明只适用于继承，而不适用于包含//using声明只使用成员名—没有圆括号，函数特征表和返回类型 多重继承必须使用关键字public来限定每一个基类，这是因为，除非特别指出，否则编译器将认为是私有派生。（class 默认访问类型是私有，strcut默认访问类型是公有） 多重继承带来的两个主要问题： 1.从两个不同的基类继承同名方法。 2.从两个或更多相关的基类那里继承同一个类的多个实例。 123class Singer:public Worker{...};class Waiter:public Worker{...};class SingerWaiter:public Singer,public Waiter{...}; Singer和Waiter都继承一个Worker组件，因此SingerWaiter将包含两份Worker的拷贝–&gt;通常可以将派生来对象的地址赋给基类指针，但是现在将出现二义性。（基类指针调用基类方法时不知道调用哪个基类方法），第二个问题：比如worker类中有一个对象成员，那么就会出现 虚基类（virtual base class） 虚基类使得从多个类（他们的基类相同）派生出的对象只继承一个基类对象。1234class Singer:virtual public Worker{...};//virtual可以和public调换位置class Waiter:public virtual Worker{...;//然后将SingingWaiter定义为class SingingWaiter：public Singer,public Waiter{...}; 现在,SingingWaiter对象只包含Worker对象的一个副本 为什么不抛弃将基类声明为虚的这种方式，使虚行为成为MI的准则呢？（为什么不讲虚行为设为默认，而要手动设置） 第一，一些情况下，可能需要基类的多个拷贝； 第二，将基类作为虚的要求程序完成额外的计算，为不需要的工具付出代价是不应当的； 第三，这样做是有缺点的，为了使虚基类能够工作，需要对C++规则进行调整，必须以不同的方式编写一些代码。另外，使用虚基类还可能需要修改已有的代码 虚基类的构造函数（需要修改） 对于非虚基类，唯一可以出现在初始化列表的构造函数是即是基类构造函数。 对于虚基类，需要对类构造函数采用一种新的方法。 基类是虚的时候,禁止信息通过中间类自动传递给基类,因此向下面构造函数将初始化成员panache和voice，但wk参数中的信息将不会传递给子对象Waiter。然而，编译器必须在构造派生对象之前构造基类对象组件；在下面情况下，编译器将使用Worker的默认构造函数（即类型为Worker的参数没有用！而且调用了Worker的默认构造函数） 1SingingWaiter(const Worker &amp;wk,int p=0;int v=Singer:other):Waiter(wk,p),Singer(wk,v){}//flawed 如果不希望默认构造函数来构造虚基类对象，则需要显式地调用所需的基类构造函数。 1SingingWaiter(const Worker &amp;wk,int p=0;int v=Singer:other):Worker(wk),Waiter(wk,p),Singer(wk,v){} 上述代码将显式地调用构造函数worker(const Worker&amp;)。请注意，这种调用是合法的，对于虚基类，必须这样做；但对于非虚基类，则是非法的。 有关MI的问题 多重继承可能导致函数调用的二义性。 假如每个祖先（Singer，waiter）都有Show()函数。那么如何调用 1.可以使用作用域解析符来澄清编程者的意图： 12SingingWaiter newhire(\"Elise Hawks\",2005,6,soprano);newhire.Singer::Show();//using Singer Version 2.然而，更好的方法是在SingingWaiter中重新定义Show(),并指出要使用哪个show。 1P559～P560 1.混合使用虚基类和非虚基类 如果基类是虚基类，派生类将包含基类的一个子对象； 如果基类不是虚基类，派生类将包含多个子对象 当虚基类和非虚基类混合是，情况将如何呢？123456//有下面情况class C:virtual public B{...};//B为虚基类class D:virtual public B{...};//B为虚基类class X: public B{...}; //B为非虚基类class Y: public B{...}; //B为非虚基类class M:public C,public D,public X,public Y{...}; 这种情况下，类M从虚派生祖先C和D那里共继承了一个B类子对象，并从每一个非虚派生祖先X和Y分别继承了一个B类子对象。因此它(M)包含三个B类子对象。 当类通过多条虚途径和非虚途径继承了某个特定的基类时，该类包含一个表示所有的虚途径的基类子对象和分别表示各条非虚途径的多个基类子对象。(本例子中是1+2=3) 2.虚基类和支配(使用虚基类将改变C++解释二义性的方式) 使用非虚基类是，规则很简单，如果类从不同的类那里继承了两个或更多的同名函数（数据或方法），则使用该成员名是，如果没有用类名进行限定，将导致二义性。 但如果使用的是虚基类，则这样做不一定会导致二义性。这种情况下，如果某个名称优先于（dominates）其他所有名称，则使用它时，即使不使用限定符，也不会导致二义性。12345678910111213141516171819202122232425262728293031class B{public:short q();...};class C:virtual public B{public:long q();int omg();...};class D:public C{...}class E:virtual public B{private:int omg();...};class F: public D,public E{...}; 1.类C中的q()定义优先于类B中的q()定义，因为类C是从类B派生而来的。因此F中的方法可以使用q()来表示C::q().（父子类之间有优先级，子类大于父类） 2.任何一个omg()定义都不优先于其他omg()定义，因为C和E都不是对方的基类。所以，在F中使用非限定的omg()将导致二义性。 3.虚二义性规则与访问规则（pravite,public,protected）无关，也就是说即使E::omg是私有的，不能在F类中直接访问，但使用omg()仍将导致二义性。 类模板类模板 类模板和模板函数都是以template开头（当然也可以使用class），后跟类型参数；类型参数不能为空，多个类型参数用逗号隔开。 1234template &lt;typename 类型参数1，typename 类型参数2，typename 类型参数3&gt;class 类名{//TODO} 类模板中定义的类型参数可以用在函数声明和函数定义中， 类模板中定义的类型参数可以用在类型类声明和类实现中， 类模板的目的同样是将数据的类型参数化。 12345678910111213141516template &lt;class Type&gt;class Stack{private: enum {MAX=10}; Type items[MAX]; int top;public: Stack(); ……}template &lt;class Type&gt;Stack&lt;Type&gt;::Stack(){ top=0;} Type:泛型标识符，这里的type被称为类型参数。这意味着它们类似于变量，但赋给它们的不是数字，而只能是类型 相比于函数模板，类模板必须显式的提供所需的类型。 模板不是函数，它们不能单独编译。模板必须与特定的模板实例化(instantiation)请求一起使用,为此，最简单的方法是将所有模板信息放在一个文件中，并在要使用这些模板的文件中包含该头文件。 123//类声明Stack&lt;int&gt;将使用int替换模板中所有的TypeStack&lt;int&gt;kernels;Stack&lt;string&gt;colonels; 深入探讨模板模板具体化（instantiation）和实例化（specialization） 模板以泛型的方式描述类，而具体化是使用具体的类型生成类声明。 类模板具体化生成类声明 类实例化生成类对象 1.隐式实例化(implicit instantiation)他们声明一个或多个对象，指出所需的类型，而编译器使用通用模板提供的处方生成具体的类定义； 12345Array&lt;int,100&gt;stuff;//隐式实例化//在编译器处理对象之间，不会生成隐式实例化，如下Array&lt;double,30&gt;*pt;//a pointer,no object needed yet//下面语句导致编译器生成类定义，并根据该定义创建一个对象昂pt=new Array&lt;double,30&gt;; 2.显式实例化(explicit instantiation) 当使用关键字template并指出所需类型来声明类时，编译器将生成类声明的实例化 1template class ArrayTP&lt;string,100&gt;; 这种情况下，虽然没有指出创建或提及类对象，编译器也将生成类声明（包含方法定义）。和隐式实例化也将根据通用模板来生成具体化。 3.显式具体化(explicit specialization)—是特定类型（用于替换模板中的泛型）的定义格式：template&lt;&gt;class Classname{…};有时候，可能需要在特殊类型实例化是，对模板进行修改，使其行为不同。在这种情况下，可以创建显式实例化。 12345//原来的类模板template &lt;typename T&gt;class sortedArray{...//details omitted}; 当具体化模板和通用模板都与实例化请求匹配时，编译器将使用具体化版本。 12345//新的表示法提供一个专供const char*类型使用的SortedArray模板template&lt;&gt;class SortedArray&lt;const char*&gt;{...//details omitted}; 4.部分具体化(partical specialization) 部分限制模板的通用性 1234//general template 一般模板 template&lt;class T1,class T2&gt;class Pair{...};//specialization with T2 set to int部分具体化 template&lt;class T1&gt;class Pair&lt;T1,int&gt;{...}; 如果有多个模板可供选择，编译器将使用具体化程度最高的模板 123Pair&lt;double,double&gt;p1;//使用了一般的Pair类模板Pair&lt;double,int&gt;p2;//使用了部分具体化Pair&lt;T1,int&gt;Pair&lt;int,int&gt;p3//使用了显式实例化Pair&lt;int,int&gt; 也可以通过为指针提供特殊版本来部分具体化现有模板： 1234template&lt;class T&gt;class Feen{...};//一般版本的类模板template&lt;class T*&gt;class Feen{...};//部分具体化 将模板用作参数template&lt;template&lt;typename T&gt;class Thing&gt;class Crab 模板类和友元 模板类声明也可以有友元。模板的友元分为3类： 非模板友元： 约束(bound)模板友元，即友元的类型取决于类被实例化时的类型； 非约束(unbund)模板友元，即友元的所有具体化都是类的每一个具体化的友元。 模板类的非模板友元函数 在模板类中奖一个常规函数声明为友元：1234567template &lt;class T&gt;class HasFriend{public:friend void counts();...}; 上述声明指定counts()函数称为模板所有实例化的友元 counts()函数不是通过对象调用（它是友元不是成员函数），也没有对象参数，那么如何访问HasFriend对象？ 1.它可以访问全局对象 2.它可以使用全局指针访问非全局对象 3.可以创建自己的对象 4.可以访问独立于对象的模板类的静态成员函数 模板类的约束模板友元 1.首先，在类定义的前面声明每个模板函数 templatevoid counts();templatevoid report(T &amp;); 2.然后，在函数中再次将模板声明为友元。这些语句根据类模板参数的类型声明 1234567template&lt;typename TT&gt;class HasFriendT{...friend coid counts&lt;TT&gt;();friend coid report&lt;&gt;(HasFriendT&lt;TT&gt; &amp;);}; 3.为友元提供模板定义 模板类的非约束模板友元函数 前一节中的约束模板友元函数在类外面声明的模板的具体化。int类具体化获得int函数具体化，依此类推。通过类内部声明模板，可以创建非约束友元函数，即每个函数具体化都是每个类具体化的友元。对于非约束友元，友元模板类型参数与模板类类型参数是不同的：123456template&lt;typename T&gt;class ManyFriend{...template&lt;typename C,typename D&gt;friend void show2(C &amp;,D &amp;);}; 模板别名(C++11) 1.如果能为类型指定别名，浙江爱你个很方便，在模板设计中尤为如此。可使用typedef为模板具体化指定别名 1234567typedef std::array&lt;double,12&gt; arrd;typedef std::array&lt;int,12&gt; arri;typedef std::array&lt;std::string,12&gt; arrst;//使用arrd gallones；arri days;arrst months; 2.C++11新增了一项功能—使用模板提供一系列别名 12template&lt;typename T&gt;using arrtype=std::array&lt;T,12&gt;;//template aliases 这将arrtype定义为一个模板别名，可以用它来指定类型 123arrtype&lt;double&gt; gallones;arrtype&lt;int&gt; days;arrtype&lt;std::string&gt; months; C++11允许将语法using=用于非模板。用于非模板是，这种语法与常规typedef等价：12typedef const char *pc1; //typedef syntax/ 常规typedef语法using pc2=const char*; //using = syntax/ using =语法 可变参数模板(variadic template)18章","link":"/2019/05/24/C++笔记8/"},{"title":"ObjectDetection and PoseEstimation","text":"物体检测与位姿估计 针对刚性物体识别与位姿估计的方法主要分为三类： 基于模板匹配 基于三维局部特征 基于学习 下面来细讲： 资料整理 0.相关 网站：Detection and 6D Pose Estimation里面收录了很多文章和方法 没趣啊知乎：meiqua知乎 石头哥的目标检测(深度学习)笔记 stone 1.基于模板匹配(template matching)基于模板匹配的6D目标位姿估计方法的研究始于20世纪90年代的单目图像。 以不同视点下目标对象的整体外观作为模型模板， A.2D基于线条特征[^3]、边缘轮廓[^4]、冲击图形和曲线[^5]进行模型与输入的匹配。 可用的开源项目： shape_based_matching edge_based_matching ShapeMatch LINE2D OpenSSE B.2.5D在增加了深度信息后，使得6D目标位姿估计对背景杂波具有更强的鲁棒性。针对机器人应用提出了快速、鲁棒的RGB-D特性， 如VFH[6]和CVFH[7]。stoisser等[8,9]提出了以图像梯度离散化方向和表面法线为特征的linemod方法。相似度得分在预先计算的响应图上快速计算出来，他们表明它比现有的方法在杂乱的背景下更健壮，也更快。 开源项目linemod(opencv和PCL中均有接口)： 6DPose PCL提供两个类LINEMOD和lineRGBD 2.基于三维局部特征(3D local features)在基于三维局部特征的方法中，六自由度位姿是根据局部特征的对应关系或Hough投票中恢复出来的。 早期提出了二维图像中提取的线条特征[^10]、边缘特征[^11]等多种局部特征。为了进行更稳健的估计，还提出了利用深度信息的局部描述符，如自旋图像[^12]和SHOT[^13]。 点对特性(PPF)[^14]是迄今为止最为成功和著名的三维局部描述符，并且已经提出了许多扩展版本。例如，选择边界或线[^15]点，计算分割点云[^16]上的PPF，改进点采样和投票[^17]。然而，与基于模板的方法相比，在6D位姿空间中进行模式搜索速度较慢。 （论文BOP: Benchmark for 6D Object Pose Estimation 中对15种方法进行了评估，得出结论是PPF表现最好，优于模板匹配方法（templates matching），基于学习（learning-based）的方法和基于3D local features的方法） 1.基于点云三维局部特征的方法3D local features一般点云物体识别的流程是： 提取关键点（keypoints）。比如iss关键点，sift关键点。它们的数据形式是三维向量XYZ+其他信息 利用关键点keypoints作为种子计算特征描述子descriptors。比如3DSC描述子，LSP描述子。它们的数据形式是多维向量比如PFH的长度是125，SI的长度是225。 匹配：实际上是通过特征描述子（descriptors）进行对应点（correspondence）估计。如SAC-IA算法。 匹配后再通过一些点云的配准（registration）方法比如迭代最近点（ICP）进行精确配准。 假设验证 使用PCL中的方法： 3D_object_recognition_(pipeline) 2.PPF vote-based pose estimation.（基于投票的位姿估计）典型方法：PPF OPENCV和PCL中均有接口 hough transform霍夫变换 hough random forests霍夫随机森林 3.基于学习(learning-based)在基于学习的方法中，出现了很多利用机器学习技术提取识别特征，训练识别前景/背景、对象类和三维对象姿态的分类器。例如，学习模板匹配[^18]或投票[^19]的权重，学习潜在类分布[^20]和学习霍夫森林进行坐标回归[^21]。近年来，CNN被引入学习三维物体姿态[^22]的流形。提出了基于卷积自动编码器[^23]和自监督增强自动编码器[^24]的流形学习方法。Kehl等人提出了类似ssd的CNN架构，用于估计对象的二维位置、类和三维位姿。利用基于CNN的检测器检测三维控制点或包围盒角的投影二维点，而不是估计三维位姿类[^25,26,27]。虽然最近的基于CNN的方法与其他两种方法相比，对背景杂波和局部遮挡的鲁棒性更高，但是它们的训练需要大量的带注释的训练样本，并且在GPU上花费更长的时间。 1.3D-Machine-Learning3D-Machine-Learning Datasets 3D Pose Estimation Courses Single Object Classification Multiple Objects Detection Scene/Object Semantic Segmentation 3D Geometry Synthesis/Reconstruction Texture/Material Analysis and Synthesis Style Learning and Transfer Scene Synthesis/Reconstruction Scene Understanding 2.A Tutorial on 3D Deep LearningA Tutorial on 3D Deep Learning 3.3D Convolutional Neural Networks — A Reading List3D Convolutional Neural Networks — A Reading List -——- [^1]: Tokhi O , Connolly C . A new integrated robot vision system from FANUC Robotics[J]. Industrial Robot: An International Journal, 2007, 34(2):103-106.[^2 ]: Consultant R B . Random bin picking: has its time finally come?[J]. Assembly Automation, 2014, 34(3):217 - 221.27] S. Lanser, O. Munkelt, and C. Zierl. Robust video-based object [^3]: S. Lanser, O. Munkelt, and C. Zierl. Robust video-based object recognition using cad models. In Intelligent AutonomousSystems IAS-4, pages 529–536, 1995[^4]: Byne J H M , Anderson J A D W . A CAD-based computer vision system ☆[J]. Image &amp; Vision Computing, 1998, 16(8):533-539.[^5]: Cyr C M , Kimia B B . A Similarity-Based Aspect-Graph Approach to 3D Object Recognition[J]. International Journal of Computer Vision, 2004, 57(1):5-22.[^6 ]: Rusu R B , Bradski G , Thibaux R , et al. Fast 3D recognition and pose using the Viewpoint Feature Histogram[C]// 2010 IEEE/RSJ International Conference on Intelligent Robots and Systems. IEEE, 2010.[^7 ]: Aldoma A , Vincze M , Blodow N , et al. CAD-model recognition and 6DOF pose estimation using 3D cues[C]// IEEE International Conference on Computer Vision Workshops. IEEE Computer Society, 2011.[^8 ]: Hinterstoisser S , Cagniart C , Ilic S , et al. Gradient Response Maps for Real-Time Detection of Textureless Objects[J]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2012, 34(5):876-888.[^9]: Al S H E . Model Based Training, Detection and Pose Estimation of Texture-Less 3D Objects in Heavily Cluttered Scenes[C]// Asian Conference on Computer Vision. Springer-Verlag, 2012.[^10 ]: David P , Dementhon D . Object recognition in high clutter images using line features[C]// Tenth IEEE International Conference on Computer Vision. IEEE Computer Society, 2005.[^11 ]: Choi C , Christensen H I . 3D textureless object detection and tracking: An edge-based approach[C]// IEEE/RSJ International Conference on Intelligent Robots &amp; Systems. IEEE, 2012.[^12 ]: Johnson A E , Hebert M . Using Spin-Images for Efficient Object Recognition in Cluttered 3-D Scenes[J]. IEEE Transactions on Pattern Analysis &amp; Machine Intelligence, 2002, 21(5):433-449.[^13 ]: Tombari F, Salti S, Stefano L D. Unique Signatures of Histograms for Local Surface Description[C]// European Conference on Computer Vision Conference on Computer Vision. 2010.[^14 ]: Drost B , Ulrich M , Navab N , et al. Model globally, match locally: Efficient and robust 3D object recognition[C]// 2010 IEEE Computer Society Conference on Computer Vision and Pattern Recognition. IEEE, 2010.[^15 ]: Choi C , Taguchi Y , Tuzel O , et al. Voting-based pose estimation for robotic assembly using a 3D sensor[C]// IEEE International Conference on Robotics &amp; Automation. IEEE, 2013.[^16 ]: Birdal T , Ilic S . [IEEE 2015 International Conference on 3D Vision (3DV) - Lyon, France (2015.10.19-2015.10.22)] 2015 International Conference on 3D Vision - Point Pair Features Based Object Detection and Pose Estimation Revisited[J]. 2015:527-535.[^17 ]: Hinterstoisser S , Lepetit V , Rajkumar N , et al. Going Further with Point Pair Features[J]. 2017.[^18 ]: Rioscabrera R , Tuytelaars T . Discriminatively Trained Templates for 3D Object Detection: A Real Time Scalable Approach[C]// IEEE International Conference on Computer Vision. IEEE Computer Society, 2013.[^19 ]: Tuzel O , Liu M Y , Taguchi Y , et al. Learning to Rank 3D Features[J]. 2014.[^20 ]: Tejani A , Tang D , Kouskouridas R , et al. Latent-class hough forests for 3D object detection and pose estimation.[J]. 2014.[^21 ]: Brachmann E , Krull A , Michel F , et al. Learning 6D Object Pose Estimation Using 3D Object Coordinates[M]// Computer Vision – ECCV 2014. Springer International Publishing, 2014.[^22 ]: Wohlhart P , Lepetit V . Learning Descriptors for Object Recognition and 3D Pose Estimation[J]. 2015.[^23 ]: Kehl W , Milletari F , Tombari F , et al. Deep Learning of Local RGB-D Patches for 3D Object Detection and 6D Pose Estimation[C]// European Conference on Computer Vision. Springer, Cham, 2016.[^24 ]: Sundermeyer M, Marton Z C, Durner M, et al. Implicit 3d orientation learning for 6d object detection from rgb images[C]//European Conference on Computer Vision. Springer, Cham, 2018: 712-729.[^25 ]: Crivellaro A , Rad M , Verdie Y , et al. A Novel Representation of Parts for Accurate 3D Object Detection and Tracking in Monocular Images[C]// IEEE International Conference on Computer Vision. IEEE, 2015.[^26 ]: Rad M , Lepetit V . BB8: A Scalable, Accurate, Robust to Partial Occlusion Method for Predicting the 3D Poses of Challenging Objects without Using Depth[C]// IEEE International Conference on Computer Vision. IEEE Computer Society, 2017. （完）","link":"/2019/05/24/ObjectDetection-and-PoseEstimation/"},{"title":"cudanote2","text":"第四章 CUDA C 并行编程、第五章线程协作 CUDA C并行编程、线程协作、GPU逻辑结构、配置线程、共享内存与同步、二维线程块实现波纹、共享内存实现点积 作者github:littlebearsama 原文链接 (建议下载Typora来浏览markdown文件) 第四章 CUDA C 并行编程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#define N 10__global__ void add( int *a, int *b, int *c ) { int tid = blockIdx.x; // this thread handles the data at its thread id if (tid &lt; N) c[tid] = a[tid] + b[tid];}int main( void ) { int a[N], b[N], c[N]; int *dev_a, *dev_b, *dev_c; // allocate the memory on the GPU cudaMalloc( (void**)&amp;dev_a, N * sizeof(int) ); cudaMalloc( (void**)&amp;dev_b, N * sizeof(int) ); cudaMalloc( (void**)&amp;dev_c, N * sizeof(int) ); // fill the arrays 'a' and 'b' on the CPU for (int i=0; i&lt;N; i++) { a[i] = -i; b[i] = i * i; } // copy the arrays 'a' and 'b' to the GPU cudaMemcpy( dev_a, a, N * sizeof(int), cudaMemcpyHostToDevice ); cudaMemcpy( dev_b, b, N * sizeof(int), cudaMemcpyHostToDevice ); add&lt;&lt;&lt;N,1&gt;&gt;&gt;( dev_a, dev_b, dev_c ); // copy the array 'c' back from the GPU to the CPU cudaMemcpy( c, dev_c, N * sizeof(int), cudaMemcpyDeviceToHost ); // display the results for (int i=0; i&lt;N; i++) { printf( \"%d + %d = %d\\n\", a[i], b[i], c[i] ); } // free the memory allocated on the GPU cudaFree( dev_a ); cudaFree( dev_b ); cudaFree( dev_c ); return 0;} 调用cudaMalloc()在设备上为三个数组分配内存。 使用完GPU后调用cudaFree()来释放他们。 通过cudaMemcpy()进行主机与设备之间复制数据。 第五章 线程协作1.GPU逻辑结构 CUDA的软件架构由网格（Grid）、线程块（Block）和线程（Thread）组成， 相当于把GPU上的计算单元分为若干（2~3）个网格， 每个网格内包含若干（65535）个线程块， 每个线程块包含若干（512）个线程， 三者的关系如下图： 2.线程索引（ID）定位作用： 线程ID用来定位线程，根据线程ID来给各个线程分配数据以及其他操作。 计算线程ID需要通过本线程的各个内建变量来计算被调用核函数所进入的线程ID. 内建变量： threadIdx(.x/.y/.z代表几维索引)：线程所在block中各个维度上的线程号 lockIdx(.x/.y/.z代表几维索引)：块所在grid中各个维度上的块号 blockDim(.x/.y/.z代表各维度上block的大小)： block的大小即block中线程的数量， blockDim.x代表块中x轴上的线程数量， blockDim.y代表块中y轴上的线程数量， blockDim.z代表块中z轴上的线程数量 gridDim(.x/.y/.z代表个维度上grid的大小)： grid的大小即grid中block的数量， gridDim.x代表grid中x轴上块的数量， gridDim.y代表grid中y轴上块的数量， gridDim.z代表grid中z轴上块的数量 定义grid、block大小：dim3 numBlock(m,n)dim3 threadPerBlock(i,j)则blockDim.x=i; blockDim.y=j; gridDim.x=m; gridDim.y=n kernel调用：kernel&lt;&lt;&lt;numBlock,threadPerBlock&gt;&gt;&gt;(a,b)这是调用kernel时的参数，尖括号&lt;&lt;&lt;&gt;&gt;&gt;中第一个参数代表启动的线程块的数量，第二个参数代表每个线程块中线程的数量. 总的线程号：设线程号为tid,以下讨论几种调用情况下的tid的值，这里只讨论一维／二维的情况 一维：１．kernel&lt;&lt;&lt;1,N&gt;&gt;&gt;()block和thread都是一维的，启动一个block，里面有N个thread，１维的。tid=threadIdx.x ２．kernel&lt;&lt;&lt;N,1&gt;&gt;&gt;()启动N个一维的block，每个block里面１个thread。tid=blockIdx.x ３．kernel&lt;&lt;&lt;M,N&gt;&gt;&gt;()启动Ｍ个一维的block，每个block里面N个一维的thread。tid=threadIdx.x+blockIdx.x * blockDim.x 一般如何配置线程？ kernel&lt;&lt;&lt;M,N&gt;&gt;&gt;() M，N为1维度 输入数据numbers，设定每个线程块有N=128或256或512个线程，一般设为128。 计算应该设置的线程块M=（numbers+N-1）/N，向上取整；线程块是数量不能超过65535，这是一种硬件限制，如果启动的线程块数量超过了这一限值，那么程序将运行失败。 二维：４．dim grid(m,n)kernel&lt;&lt;&lt;grid,1&gt;&gt;&gt;()启动一个二维的mn个block，每个block里面一个thread。*tid=blockIdx.x+blockIdx.y * gridDimx.x** ５．dim grid(m,n)kernel&lt;&lt;&lt;grid,N&gt;&gt;&gt;()启动一个二维的mn大小的block，每个block里面Ｎ个thread。*tid=** ６．dim block(m,n)kernel&lt;&lt;&lt;1,block&gt;&gt;&gt;()tid= ７．dim block(m,n)kernel&lt;&lt;&lt;N,block&gt;&gt;&gt;()tid= ８．dim grid(m,n)dim block(i,j)kernel&lt;&lt;&lt;grid,block&gt;&gt;&gt;()tid= tid&lt;N公式M=（numbers+N-1）/N保证了启动了足够多的线程,当输入数据numbers不是线程块里面线程数N的整数倍时,将启动过多线程。 为了防止启动过多线程：在核函数中，在访问输入数组和输出数组之前，必须检查线程的偏移（索引）tid是否位于0到N之间 12if(tid&lt;N) c[tid]=a[tid]+b[tid]; 因此，当索引越过数组边界时，例如当启动并行线程数量不是线程块中线程的数目N（128）就会出现这种情况，那么核函数将自动停止执行计算。更重要的是，核函数不会对越过数组边界的内存进行读取或写入。 简单来说就是启动了充足的线程，而有的线程不用工作，为了防止核函数不会出现越界读取等错误，我们使用了条件判断if（tid&lt;N）。 当数据大于运行线程时因为数据数目大于线程数目，所以正在运行的所有线程都可能会再被执行，直到所有数据处理完毕。所以while(tid&lt;N)不仅仅用于判断线程ID tid，是否执行线程。也用于循环。 添加语句tid+=blockDim.x*gridDim.x;增加的值等于每个线程块中的线程数量乘以线程网格中线程块的数量，在上面的线程分配(一维的线程格，一维的线程块)中为blockDim.x*gridDim.x 故核函数被改写为 123456__global__ void add( int *a, int *b, int *c ) { int tid = threadIdx.x+blockIdx.x*blockDim.x; // this thread handles the data at its thread id while (tid &lt; N) c[tid] = a[tid] + b[tid]; tid+=blockDim.x*gridDim.x;//新增的} 3.二维的线程格，二维的线程块（实现波纹效果） 1234567891011121314151617181920212223__global__ void kernel( unsigned char *ptr, int ticks ) { // map from threadIdx/BlockIdx to pixel position int x = threadIdx.x + blockIdx.x * blockDim.x; int y = threadIdx.y + blockIdx.y * blockDim.y; int offset = x + y * blockDim.x * gridDim.x; // now calculate the value at that position float fx = x - DIM/2; float fy = y - DIM/2; float d = sqrtf( fx * fx + fy * fy ); unsigned char grey = (unsigned char)(128.0f + 127.0f * cos(d/10.0f - ticks/7.0f) / (d/10.0f + 1.0f)); ptr[offset*4 + 0] = grey; ptr[offset*4 + 1] = grey; ptr[offset*4 + 2] = grey; ptr[offset*4 + 3] = 255;}dim3 blocks(DIM/16,DIM/16);dim3 threads(16,16);kernel&lt;&lt;&lt;blocks,threads&gt;&gt;&gt;( data.dev_bitmap, ticks ); blocks和threads是两个二维变量 由于生成的是一幅图像，因此使用二维索引，并且每个线程都有唯一的索引(x,y)，这样可以很容易与输出图像中的像素一一对应起来。就是输出图像的像素索引(x,y) offset是数据的线程索引（被称为全局偏置）,该线程对应图像像素索引(x,y)也对应数据索引offset (fx,fy)=像素点(x,y)相对于图像中心点（DIM/2，DIM/2）位置，即把图像原点移到图像中心 加入线程块是一个16X16的线程数组，图像有DIMXDIM个像素，那么就需要启动DIM/16 x DIM/16个线程块，从而使每一个像素对应一个线程。 GPU优势在于处理图像时比如1920X1080需要创建200万个线程，CPU无法完成这样的工作。 4.共享内存和同步 共享内存术语Shared Memory，是位于SM（流多处理器）中的特殊存储器。还记得SM吗，就是流多处理器，大核是也。 将关键字__share__添加到变量声明中，这将是这个变量驻留在共享内存中。 block与block的线程无法通信 共享内存缓存区驻留在物理GPU上，而不是驻留在GPU以外的系统内存中。因此，在访问共享内存时的延迟要远远低于访问普通缓存区的延迟，使得共享内存像每个线程块的高速缓存或中间结果暂存器那样高效。 想要在线程之间通信，那么还需要一种机制来实现线程之间的同步，例如，如果线程A将一个值写入到共享内存，并且我们希望线程B对这个值进行一些操作，那么只有当线程A写入操作完成后，线程B才能开始执行它的操作。如果没有同步，那么将发生竞态条件。 这里的例子是点积的例子，就是： 代码： 123456789101112131415161718192021222324__global__ void dot(float *a, float *b, float *c) { __shared__ float cache[threadsPerBlock]; int tid = threadIdx.x + blockIdx.x * blockDim.x;//全局偏移用来索引数据 int cacheIndex = threadIdx.x; //共享内存缓存中的偏移就等于线程索引 float temp = 0; while (tid &lt; N) { temp += a[tid] * b[tid]; //线程被执行的次数是未知的，数据最终被保存成temp并 tid += blockDim.x * gridDim.x; //存入到threadsPerBlock维的cache中 } cache[cacheIndex] = temp; __syncthreads(); //归约运算 int i = blockDim.x / 2;//取threadsPerBlock的一半作为i值 while (i != 0) { if (cacheIndex &lt; i) cache[cacheIndex] += cache[cacheIndex + i]; __syncthreads(); i /= 2; } //结束while()循环后，每个线程块都得到一个值。这个值位于cache[]的第一个元素中，并且就等于该线程中两两元素乘积的加和。然后，我们将这个值保存到全局内存并结束核函数。 if (cacheIndex == 0) c[blockIdx.x] = cache[0];} __shared__ float cache[threadsPerBlock];在共享内存中申请浮点数组，数组大小和线程块中线程数目相同每个线程块都拥有该共享内存的私有副本。 共享内存缓存区cache将保存该block内每个线程计算的加和值。 __syncthreads();等待线程块里面的所有线程执行完毕，简称线程同步。确保线程块中的每个线程都执行完__syncthreads();前面的语句后才会执行下一语句。 用规约运算，我们取threadsPerBlock的一半作为i值，只有索引小于这个值的线程才会执行。只有当线程索引小于i时，才可以把cache[]的两个数据项相加起来。__syncthreads()作用如下图（下图中是等待4个线程中的相加操作完成）。 ​ 假设cache[]中有8个元素，因此i的值为4。规约运算的其中一个步骤如下图所示 由于线程块之间无法通信。只能将每个线程块算出来的值存出来,存到数组c中，最后会返回block数量个c，然后由cpu执行最后的加法。 当某些线程需要执行一条指令，而其他线程不需要执行时，这种情况就称为线程发散（Thread Divergence）。在正常环境中，发散的分支只会使得某些线程处于空闲状态，而其他线程将执行分支中的代码。但是在__syncthreads()情况中，线程发散造成的结果有些糟糕。CUDA架构将确保，除非线程块中的每个线程都执行了__syncthreads()，否则没有任何线程能执行__syncthreads()之后的指令。如果__syncthreads()位于发散分支中，一些线程将永远无法执行__syncthreads()。硬件将一直保持等待。 下面代码将使处理器挂起，因为GPU在等待某个永远无法发生的事件。 1234if (cacheIndex &lt; i){ cache[cacheIndex] += cache[cacheIndex + i]; __syncthreads(); } 例子2（二维线程布置）基于共享内存的位图（略）","link":"/2019/05/24/cudanote2/"},{"title":"cudanote3","text":"第六章 常量内存与事件 光线追踪、常量内存与事件、常量内存带来的性能提升、线程束 作者github:littlebearsama 原文链接 (建议下载Typora来浏览markdown文件) 第六章 常量内存与事件0.光线追踪 常量内存用于保存在核函数执行期间不会发生变化的数据。Nvidia硬件提供了64KB的常量内存，并且对常量内存采取了不同于标准全局内存的处理方式。在某些情况中，用常量内存来替换全局内存能有效地减少内存带宽。 在光线跟踪的例子中，没有利用常量内存的代码运行时间为1.8ms，利用了常量内存的代码运行时间为0.8ms 将球面数组存入常量内存中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include \"cuda.h\"#include \"../common/book.h\"#include \"../common/image.h\"#define DIM 1024#define rnd( x ) (x * rand() / RAND_MAX)#define INF 2e10fstruct Sphere { float r,b,g; float radius; float x,y,z;//球心相对于图像中心的坐标 __device__ float hit( float ox, float oy, float *n ) { float dx = ox - x; float dy = oy - y; //计算来自于(ox,oy)处像素的光线（垂直于图像平面），计算光线是否与球面相交 //然后计算相机到光线命中球面出的距离 if (dx*dx + dy*dy &lt; radius*radius) { float dz = sqrtf( radius*radius - dx*dx - dy*dy ); *n = dz / sqrtf( radius * radius ); return dz + z; } return -INF; }};#define SPHERES 20__constant__ Sphere s[SPHERES];__global__ void kernel( unsigned char *ptr ) { // map from threadIdx/BlockIdx to pixel position int x = threadIdx.x + blockIdx.x * blockDim.x; int y = threadIdx.y + blockIdx.y * blockDim.y; int offset = x + y * blockDim.x * gridDim.x; float ox = (x - DIM/2);//(ox, oy)=(x, y)相对于图像中心点（DIM / 2，DIM / 2）位置或者说将图像移到中心 float oy = (y - DIM/2); float r=0, g=0, b=0; float maxz = -INF; for(int i=0; i&lt;SPHERES; i++) { float n; float t = s[i].hit( ox, oy, &amp;n ); if (t &gt; maxz) { float fscale = n; r = s[i].r * fscale; g = s[i].g * fscale; b = s[i].b * fscale; maxz = t; } } ptr[offset*4 + 0] = (int)(r * 255); ptr[offset*4 + 1] = (int)(g * 255); ptr[offset*4 + 2] = (int)(b * 255); ptr[offset*4 + 3] = 255;}// globals needed by the update routinestruct DataBlock { unsigned char *dev_bitmap;};int main( void ) { DataBlock data; // capture the start time cudaEvent_t start, stop; HANDLE_ERROR( cudaEventCreate( &amp;start ) ); HANDLE_ERROR( cudaEventCreate( &amp;stop ) ); HANDLE_ERROR( cudaEventRecord( start, 0 ) ); IMAGE bitmap( DIM, DIM ); unsigned char *dev_bitmap; // 在GPU上分配内存以计算输出位图 HANDLE_ERROR( cudaMalloc( (void**)&amp;dev_bitmap, bitmap.image_size() ) ); // 分配临时内存，对其初始化，并复制到GPU上的常量内存，然后释放临时内存 Sphere *temp_s = (Sphere*)malloc( sizeof(Sphere) * SPHERES ); for (int i=0; i&lt;SPHERES; i++) { temp_s[i].r = rnd( 1.0f ); temp_s[i].g = rnd( 1.0f ); temp_s[i].b = rnd( 1.0f ); temp_s[i].x = rnd( 1000.0f ) - 500; temp_s[i].y = rnd( 1000.0f ) - 500; temp_s[i].z = rnd( 1000.0f ) - 500; temp_s[i].radius = rnd( 100.0f ) + 20; } HANDLE_ERROR( cudaMemcpyToSymbol( s, temp_s, sizeof(Sphere) * SPHERES) ); free( temp_s ); // generate a bitmap from our sphere data dim3 grids(DIM/16,DIM/16); dim3 threads(16,16); kernel&lt;&lt;&lt;grids,threads&gt;&gt;&gt;( dev_bitmap ); // copy our bitmap back from the GPU for display HANDLE_ERROR( cudaMemcpy( bitmap.get_ptr(), dev_bitmap, bitmap.image_size(), cudaMemcpyDeviceToHost ) ); // get stop time, and display the timing results HANDLE_ERROR( cudaEventRecord( stop, 0 ) ); HANDLE_ERROR( cudaEventSynchronize( stop ) ); float elapsedTime; HANDLE_ERROR( cudaEventElapsedTime( &amp;elapsedTime, start, stop ) ); printf( \"Time to generate: %3.1f ms\\n\", elapsedTime ); HANDLE_ERROR( cudaEventDestroy( start ) ); HANDLE_ERROR( cudaEventDestroy( stop ) ); HANDLE_ERROR( cudaFree( dev_bitmap ) ); // display bitmap.show_image();} 变量前面加上__constant__修饰符：__constant__ Sphere s[SPHERES];常量内存为静态分配空间，所以不需要调用 cudaMalloc(), cudaFree()； 在主机端分配临时内存，对其初始化Sphere *temp_s = (Sphere*)malloc( sizeof(Sphere) * SPHERES );在把变量复制到常量内存后释放内存free( temp_s ); 使用函数cudaMemcpyToSymbol()将变量从主机内存复制到GPU上的常量内存。（cudaMencpyHostToDevice()的cudaMemcpy()之间的唯一差异在于，cudaMemcpyToSymbol()会复制到常量内存，而cudaMemcpy()会复制到全局内存） 1.常量内存带来的性能提升与从全局内存中读取数据相比，从常量内存中读取相同的数据可以节约带宽，原因有二： 对常量内存的单次读操作可以广播到其他的“邻近”线程，这将节约15次读取操作。 常量内存的数据将缓存(cache)起来，因此对相同地址的连续读操作将不会产生额外的内存通信量。 2.线程束Warp在CUDA架构中，线程束是指一个包含32个线程的集合，这个线程集合被“编织在一起”并且以“步调一致（Lockstep）”的形式执行。在程序中的每一行，线程束中的每个线程都将在不同数据上执行相同的指令。 线程束当处理常量内存是，NVIDIA硬件将把单次内存读取操作广播到每半个线程束（Half-Warp）。在半线程束中包含了16和线程。如果在半线程束中的每个线程都从常量内存的相同地址上读取数据，那么GPU只会产生一次读取请求并在随后将数据广播到每个线程。如果从常量内存中读取大量的数据，那么这种方式生产的内存流量只是全局内存的1/16（大约6%）。 常量内存与缓存但在读取常量内存是，所节约的并不只限于减少94%的带宽。由于这块内存的内容是不会发生变化的，因此硬件将主动把这个常量数据缓存在GPU上。在第一次从常量内存的某个地址上读取后，当其他半线程束请求同一地址是，那么将命中缓存(cahce)，这同样减少了额外的内存流量。在光线追踪程序中，将球面数据保存在常量内存后，硬件只需要请求这个数据一次。在缓存数据后，其他每个线程将不会产生内存流量，原因有两个：1. 线程将在半线程结束的广播中收到这个数据。 2. 从常量内存缓存中收到数据。 负面影响当使用常量内存是，也可能对性能产生负面影响。半线程束广播功能实际是把双刃剑。虽然当所有16个线程地址都读取相同地址是，这个功能可以极大地提高性能，但当所有16个线程分别读取不同地址时，它实际上会降低性能。 3.使用事件来测试性能代码： 1234567891011121314cudaEvent_t start, stop;cudaEventCreate( &amp;start );cudaEventCreate( &amp;stop );cudaEventRecord( start, 0 );// 在GPU上执行一些工作cudaEventRecord( stop, 0 );cudaEventSynchronize( stop );float elapsedTime;cudaEventElapsedTime( &amp;elapsedTime,start, stop );printf( \"Time to generate: %3.1f ms\\n\", elapsedTime );cudaEventDestroy( start );cudaEventDestroy( stop ); 运行记录事件start时，还指定了第二个参数。cudaEventRecord( start, 0 );在上面代码中为0，流(Stream)的编号。 当且仅当GPU完成了之间的工作并且记录了stop事件后，才能安全地读取stop时间值。幸运的是，还有一种方式告诉CPU在某个事件上同步，这个时间API函数就是cudaEventSynchronize();,当cudaEventSynchronize返回时，我们知道stop事件之前的所有GPU工作已经完成了，因此可以安全地读取在stop保存的时间戳。 由于CUDA事件是直接在GPU上实现的，因此它们不适用于对同时包含设备代码和主机代码的混合代码计时。也就是说，你通过CUDA事件对核函数和设备内存复制之外的代码进行计时，将得到不可靠的结果。","link":"/2019/05/24/cudanote3/"},{"title":"cudanote4","text":"第七章 纹理内存 纹理内存、纹理内存实现热传导模拟 作者github:littlebearsama 原文链接 (建议下载Typora来浏览markdown文件) 第七章 纹理内存 纹理内存(Texture Memory)和常量内存一样，纹理内存是另外一种类型的只读内存，在特定的访问模式中，纹理内存同样能够提升性能并减少内存流量。 虽然纹理内存最初是针对传统的图形处理应用程序而设计的，但在某些GPU计算应用程序中同样非常有用。 与常量内存类似的是，纹理内存同样缓存在芯片上（利用了芯片上的缓存加速）！！！，因此在某些情况中，它能够减少对内存的请求并提供更高效的内存带宽。 纹理缓存是专门为那些在内存访问模式中存在大量空间局部性（Spatial Locality）的图形应用程序而设计的。在某个计算应用程序中，这意味着一个线程读取的位置可能与邻近的线程的读取位置非常接近 上图中，从数学角度来看，图中的四个地址并非连续的，在一般的CPU缓存模式中，这些地址将不会缓存。但由于GPU纹理内存是专门为了加速这种访问模式而设计的，因此如果在这种情况中使用纹理内存而不是全局内存，那么将获得性能提升。 使用纹理内存实现热传导模拟1.算法描述： 环境是一个矩形网格，在网格中随机散布一些”热源“，热源有着不同的固定温度（该点处的温度不会变） 在随时间递进的每个步骤中，我们假设热量在某个单元机器邻接单元之间”流动“/如果某个单元的温度比邻接单元的温度更高，那么热量将从邻接单元传导到该单元。 我们对新单元中心温度的计算方法为，将单元与邻接单元的温差相加起来，加上原有温度： 常量k表示模拟过程中热量的流动速率。k值越大，表示系统会更快地达到稳定温度，而k值越小，则温度梯度将存在更长时间。 只考虑上下左右四个邻域的话讲上述式子展开有 2.实现流程： 给定一个包含初始输入温度的网格，将其中作为热源的单元温度值复制到网格的相应单元中。这将覆盖这些单元之前计算出的温度，因此也就确保了”加热单元将保持恒温“这个条件。用下面代码中的copy_const_kernel()实现； 给定一个输入网格，用上面公式计算出输出网格。用下面代码中的blend_kernel()实现； 将输入网格和输出网格交换，为下一个计算步骤做好准备。当模拟下一个时间步时，在步骤2中计算得到的输出温度网格将成为步骤1中的输入温度网格。 3.代码：（使用的是二维纹理内存）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include \"cuda.h\"#include \"../common/book.h\"#include \"../common/image.h\"#define DIM 1024#define PI 3.1415926535897932f#define MAX_TEMP 1.0f#define MIN_TEMP 0.0001f#define SPEED 0.25f// these exist on the GPU sidetexture&lt;float,2&gt; texConstSrc;texture&lt;float,2&gt; texIn;texture&lt;float,2&gt; texOut;__global__ void blend_kernel( float *dst, bool dstOut ) { // map from threadIdx/BlockIdx to pixel position //线程布置是二维线程格，二维线程块时的像素坐标索引，以及数据偏置 int x = threadIdx.x + blockIdx.x * blockDim.x; int y = threadIdx.y + blockIdx.y * blockDim.y; int offset = x + y * blockDim.x * gridDim.x; float t, l, c, r, b; //根据dstOut标志来看读取的输出部分的内存还是输出部分的内存 if (dstOut) { t = tex2D(texIn,x,y-1); l = tex2D(texIn,x-1,y); c = tex2D(texIn,x,y); r = tex2D(texIn,x+1,y); b = tex2D(texIn,x,y+1); } else { t = tex2D(texOut,x,y-1); l = tex2D(texOut,x-1,y); c = tex2D(texOut,x,y); r = tex2D(texOut,x+1,y); b = tex2D(texOut,x,y+1); } dst[offset] = c + SPEED * (t + b + r + l - 4 * c);}__global__ void copy_const_kernel( float *iptr ) { // map from threadIdx/BlockIdx to pixel position int x = threadIdx.x + blockIdx.x * blockDim.x;//将线程中的内部线程索引变量变成图像坐标 int y = threadIdx.y + blockIdx.y * blockDim.y; int offset = x + y * blockDim.x * gridDim.x;//计算偏移 float c = tex2D(texConstSrc,x,y); if (c != 0) iptr[offset] = c;//把热源温度复制到图像中(替换成原来的热源温度)}// globals needed by the update routinestruct DataBlock { unsigned char *output_bitmap; float *dev_inSrc; float *dev_outSrc; float *dev_constSrc; IMAGE *bitmap; cudaEvent_t start, stop; float totalTime; float frames;};// clean up memory allocated on the GPUvoid cleanup( DataBlock *d ) { cudaUnbindTexture( texIn ); cudaUnbindTexture( texOut ); cudaUnbindTexture( texConstSrc ); HANDLE_ERROR( cudaFree( d-&gt;dev_inSrc ) ); HANDLE_ERROR( cudaFree( d-&gt;dev_outSrc ) ); HANDLE_ERROR( cudaFree( d-&gt;dev_constSrc ) ); HANDLE_ERROR( cudaEventDestroy( d-&gt;start ) ); HANDLE_ERROR( cudaEventDestroy( d-&gt;stop ) );}int main( void ) { DataBlock data; IMAGE bitmap_image( DIM, DIM ); data.bitmap = &amp;bitmap_image; data.totalTime = 0; data.frames = 0; HANDLE_ERROR( cudaEventCreate( &amp;data.start ) ); HANDLE_ERROR( cudaEventCreate( &amp;data.stop ) ); int imageSize = bitmap_image.image_size(); HANDLE_ERROR( cudaMalloc( (void**)&amp;data.output_bitmap, imageSize ) ); // assume float == 4 chars in size (ie rgba) HANDLE_ERROR( cudaMalloc( (void**)&amp;data.dev_inSrc, imageSize ) ); HANDLE_ERROR( cudaMalloc( (void**)&amp;data.dev_outSrc, imageSize ) ); HANDLE_ERROR( cudaMalloc( (void**)&amp;data.dev_constSrc, imageSize ) ); //通道格式描述符 cudaChannelFormatDesc desc = cudaCreateChannelDesc&lt;float&gt;(); HANDLE_ERROR( cudaBindTexture2D( NULL, texConstSrc, data.dev_constSrc, desc, DIM, DIM, sizeof(float) * DIM ) ); HANDLE_ERROR( cudaBindTexture2D( NULL, texIn, data.dev_inSrc, desc, DIM, DIM, sizeof(float) * DIM ) ); HANDLE_ERROR( cudaBindTexture2D( NULL, texOut, data.dev_outSrc, desc, DIM, DIM, sizeof(float) * DIM ) ); // initialize the constant data float *temp = (float*)malloc( imageSize ); for (int i=0; i&lt;DIM*DIM; i++) { temp[i] = 0; int x = i % DIM; int y = i / DIM; if ((x&gt;300) &amp;&amp; (x&lt;600) &amp;&amp; (y&gt;310) &amp;&amp; (y&lt;601)) temp[i] = MAX_TEMP; } temp[DIM*100+100] = (MAX_TEMP + MIN_TEMP)/2; temp[DIM*700+100] = MIN_TEMP; temp[DIM*300+300] = MIN_TEMP; temp[DIM*200+700] = MIN_TEMP; for (int y=800; y&lt;900; y++) { for (int x=400; x&lt;500; x++) { temp[x+y*DIM] = MIN_TEMP; } } HANDLE_ERROR( cudaMemcpy( data.dev_constSrc, temp, imageSize, cudaMemcpyHostToDevice ) ); // initialize the input data for (int y=800; y&lt;DIM; y++) { for (int x=0; x&lt;200; x++) { temp[x+y*DIM] = MAX_TEMP; } } HANDLE_ERROR( cudaMemcpy( data.dev_inSrc, temp, imageSize, cudaMemcpyHostToDevice ) ); free( temp ); int ticks=0; bitmap_image.show_image(30); while(1) { HANDLE_ERROR( cudaEventRecord( data.start, 0 ) ); dim3 blocks(DIM/16,DIM/16); dim3 threads(16,16); IMAGE *bitmap = data.bitmap; // since tex is global and bound, we have to use a flag to // select which is in/out per iteration volatile bool dstOut = true; for (int i=0; i&lt;90; i++) { float *in, *out; if (dstOut) { in = data.dev_inSrc; out = data.dev_outSrc; } else { out = data.dev_inSrc; in = data.dev_outSrc; } copy_const_kernel&lt;&lt;&lt;blocks,threads&gt;&gt;&gt;( in ); blend_kernel&lt;&lt;&lt;blocks,threads&gt;&gt;&gt;( out, dstOut ); dstOut = !dstOut; } float_to_color&lt;&lt;&lt;blocks,threads&gt;&gt;&gt;( data.output_bitmap, data.dev_inSrc ); HANDLE_ERROR( cudaMemcpy( bitmap-&gt;get_ptr(), data.output_bitmap, bitmap-&gt;image_size(), cudaMemcpyDeviceToHost ) ); HANDLE_ERROR( cudaEventRecord( data.stop, 0 ) ); HANDLE_ERROR( cudaEventSynchronize( data.stop ) ); float elapsedTime; HANDLE_ERROR( cudaEventElapsedTime( &amp;elapsedTime, data.start, data.stop ) ); data.totalTime += elapsedTime; ++data.frames; printf( \"Average Time per frame: %3.1f ms\\n\", data.totalTime/data.frames ); ticks++; char key = bitmap_image.show_image(30); if(key==27) { break; } } cleanup(&amp;data); return 0;} 4.代码解析（下面是使用一维纹理内存的解析） 1.申请纹理内存：使用了浮点类型纹理内存的引用；纹理内存必须声明为文件作用域内的全局变量！ 1234//这些变量位于GPU上texture&lt;float&gt; texConstSrc;texture&lt;float&gt; texIn;texture&lt;float&gt; texOut; 2.申请GPU全局内存：下面代码为这三个缓存区分配了GPU内存（全局内存）,data.dev_inSrc等三个指针已经在结构对象data中声明了。 123456HANDLE_ERROR( cudaMalloc( (void**)&amp;data.dev_inSrc, imageSize ) );HANDLE_ERROR( cudaMalloc( (void**)&amp;data.dev_outSrc, imageSize ) );HANDLE_ERROR( cudaMalloc( (void**)&amp;data.dev_constSrc, imageSize ) ); 3.纹理内存与GPU全局内存绑定：需要通过cudaBindTexture()将这些变量（上面的纹理内存引用）绑定到内存缓冲区。相当于告诉CUDA运行时两件事情： a. 指定的缓冲区作为纹理来使用 b.纹理引用作为纹理的”名字” 123456789HANDLE_ERROR( cudaBindTexture( NULL, texConstSrc, data.dev_constSrc, imageSize ) );HANDLE_ERROR( cudaBindTexture( NULL, texIn, data.dev_inSrc, imageSize ) );HANDLE_ERROR( cudaBindTexture( NULL, texOut, data.dev_outSrc, imageSize ) ); 4.使用内置函数tex1Dfetch()：当读取核函数中的纹理时，需要通过特殊的函数来告诉GPU将读取请求转发到纹理内存而不是标准的全局内存。tex1Dfetch()它是一个编译器内置函数（Instrinsic）。 5.使用二维纹理内存：性能与一维的基本相同，但代码更简单。在使用内置函数tex2Dfetch()，读取缓存区中的数据时，不用计算缓存区中的线性偏置，而是可以直接用计算的像素索引x，y，这样使得代码更为简洁，并且能自动处理边界问题。 6.通道格式描述符：在绑定二维纹理内存时，CUDA运行时要求提供一个cudaChanelFormatDesc()。在二维纹理内存的代码包含了一个对通道格式描述符的声明(Channel Format Descriptor)。在这里可以使用默认的参数，并且只要指定需要的是一个浮点描述符。然后我们通过1.cudaBindTexture2D(),2.纹理内存的位数（DIMXDIM）以及3.通道格式描述（desc）将这三个输入缓冲区绑定为二维纹理，main()函数其他部分保持不变。 纹理采样器（Texture Sampler），找不到该部分的内容？如果使用了纹理采样器自动执行某种转换，那么纹理内存还能带来额外的加速。","link":"/2019/05/24/cudanote4/"},{"title":"cudanote7","text":"第十章 流 页锁定主机内存、CUDA流、GPU工作调度机制 作者github:littlebearsama 原文链接 (建议下载Typora来浏览markdown文件) 第十章 流通过CUDA流在GPU上用任务并行 页锁定主机内存两个主机内存分配函数： 标准C库函数malloc()在主机上分配内存 CUDA运行时提供自己独有的机制来分配主机内存：cudaHostAlloc()。 两个函数分配的内存之间的差异： malloc()将分配标准的，可分页的（Pagable）主机内存， cudaHostAlloc()将分配页锁定的主机内存（固定内存） 页锁定主机内存页锁定主机内存也称为固定内存（Pinned Memory）或者不可分内存。 对于固定内存，操作系统将不会对这块内存分页交换到磁盘上，从而确保了该内存始终驻留在物理内存中。因此，操作系统能够安全地使用某个程序访问该内存的物理地址，因为这块内存将不会被破坏或者重新定位。—&gt;物理地址固定不变。 由于知道内存的物理地址，因此可以通过“直接内存访问(Direct Memory Access,DMA)”技术来在GPU和主机之间复制数据。DMA操作在可分页内存中可能会延迟—&gt;DMA复制过程中使用固定内存非常重要，页锁定主机内存（固定内存）的性能比标准可分页的性能要高大约2倍。 实际上并不是说使用固定内存就好 固定内存是一把双刃剑。但是用固定内存时，你将失去虚拟内存的所有功能。应用程序中使用每个固定内存时都需要分配物理内存，因为这些内存不能交换到磁盘上。—&gt;意味着系统更快地耗尽内存。 使用情况：仅对cudaMemcpy()调用中的源内存或者目标内存，才使用也锁存内存，并且不再需要他们时立即释放，而不是等到程序关闭才释放。 页锁定内存的作用不仅限于性能的提升，后面章节会看到，在一些特殊情况中也需要使用页锁定内存。 调用： 12345678#define SIZE (64*1024*1024)int *a；int size = SIZE;//CUDA运行时申请固定内存 HANDLE_ERROR( cudaHostAlloc( (void**)&amp;a, size * sizeof( *a ), cudaHostAllocDefault ) ); 计算带宽123float MB = (float)100*SIZE*sizeof(int)/1024/1024;//SIZE=(64*1024*1024)printf( \"\\tMB/s during copy up: %3.1f\\n\", MB/(elapsedTime/1000) );//elapsedTime=用时 CUDA流 CUDA流表示一个操作GPU队列 该队列的操作将以指定的顺序执行。我们可以在流中添加一些操作，例如启动核函数，内存复制，以及事件的启动和结束等。 可以将流视为GPU上的一个任务，并且这些任务可以并行执行。 设备重叠功能的GPU支持设别重叠功能的GPU能在执行一个CUDA C核函数的同时，还能在设备与主机之间执行复制操作。可以使用多个流来实现这种计算与数据传输的重叠。 使用流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include \"../common/book.h\"#define N (1024*1024)#define FULL_DATA_SIZE (N*20)//核函数N个线程，每次处理N个数__global__ void kernel( int *a, int *b, int *c ) { int idx = threadIdx.x + blockIdx.x * blockDim.x; if (idx &lt; N) { int idx1 = (idx + 1) % 256; int idx2 = (idx + 2) % 256; float as = (a[idx] + a[idx1] + a[idx2]) / 3.0f; float bs = (b[idx] + b[idx1] + b[idx2]) / 3.0f; c[idx] = (as + bs) / 2; }} int main( void ) { cudaDeviceProp prop; int whichDevice; HANDLE_ERROR( cudaGetDevice( &amp;whichDevice ) ); HANDLE_ERROR( cudaGetDeviceProperties( &amp;prop, whichDevice ) ); //判断：支持设别重叠功能 if (!prop.deviceOverlap) { printf( \"Device will not handle overlaps, so no speed up from streams\\n\" ); return 0; } //创建事件和流 cudaEvent_t start, stop; float elapsedTime; cudaStream_t stream; int *host_a, *host_b, *host_c; int *dev_a, *dev_b, *dev_c; // start the timers HANDLE_ERROR( cudaEventCreate( &amp;start ) ); HANDLE_ERROR( cudaEventCreate( &amp;stop ) ); // initialize the stream HANDLE_ERROR( cudaStreamCreate( &amp;stream ) ); // 分配设备内存，只申请了20分之一的数据量大小的内存 HANDLE_ERROR( cudaMalloc( (void**)&amp;dev_a, N * sizeof(int) ) ); HANDLE_ERROR( cudaMalloc( (void**)&amp;dev_b, N * sizeof(int) ) ); HANDLE_ERROR( cudaMalloc( (void**)&amp;dev_c, N * sizeof(int) ) ); // 在这里申请固定内存不仅仅是为了让复制操作执行得更快 // 要以异步的方式在主机和设备之间复制数据必须是固定内存 // 申请内存大小为数据大小 HANDLE_ERROR( cudaHostAlloc( (void**)&amp;host_a, FULL_DATA_SIZE * sizeof(int), cudaHostAllocDefault ) ); HANDLE_ERROR( cudaHostAlloc( (void**)&amp;host_b, FULL_DATA_SIZE * sizeof(int), cudaHostAllocDefault ) ); HANDLE_ERROR( cudaHostAlloc( (void**)&amp;host_c, FULL_DATA_SIZE * sizeof(int), cudaHostAllocDefault ) ); // 填充申请的缓冲区host_a，host_b for (int i=0; i&lt;FULL_DATA_SIZE; i++) { host_a[i] = rand(); host_b[i] = rand(); } HANDLE_ERROR( cudaEventRecord( start, 0 ) ); // now loop over full data, in bite-sized chunks //我们不将输入缓冲区整体复制到GPU，而是将输入缓冲区划分成更小的块（分成20块），并在每个块上执行一个包含三个步骤的过程： //1.将一部分输入缓冲区复制到GPU ；2.在这部分缓冲区上运行核函数；3.然后将一部分输入缓冲区复制到GPU for (int i=0; i&lt;FULL_DATA_SIZE; i+= N) { // copy the locked memory to the device, async // 将固定内存以异步的方式复制到设备上 HANDLE_ERROR( cudaMemcpyAsync( dev_a, host_a+i, N * sizeof(int), cudaMemcpyHostToDevice, stream ) ); HANDLE_ERROR( cudaMemcpyAsync( dev_b, host_b+i, N * sizeof(int), cudaMemcpyHostToDevice, stream ) ); // 核函数带有流参数 // 刚好N个线程N个数据，线程不需要多次工作 kernel&lt;&lt;&lt;N/256,256,0,stream&gt;&gt;&gt;( dev_a, dev_b, dev_c ); // 将数据从设备复制到锁定内存 HANDLE_ERROR( cudaMemcpyAsync( host_c+i, dev_c, N * sizeof(int), cudaMemcpyDeviceToHost, stream ) ); } // copy result chunk from locked to full buffer HANDLE_ERROR( cudaStreamSynchronize( stream ) ); HANDLE_ERROR( cudaEventRecord( stop, 0 ) ); HANDLE_ERROR( cudaEventSynchronize( stop ) ); HANDLE_ERROR( cudaEventElapsedTime( &amp;elapsedTime, start, stop ) ); printf( \"Time taken: %3.1f ms\\n\", elapsedTime ); // cleanup the streams and memory HANDLE_ERROR( cudaFreeHost( host_a ) ); HANDLE_ERROR( cudaFreeHost( host_b ) ); HANDLE_ERROR( cudaFreeHost( host_c ) ); HANDLE_ERROR( cudaFree( dev_a ) ); HANDLE_ERROR( cudaFree( dev_b ) ); HANDLE_ERROR( cudaFree( dev_c ) ); HANDLE_ERROR( cudaStreamDestroy( stream ) ); getchar(); return 0;}//Time taken: 25.4 ms 创建流和事件 分配好设备内存和主机内存 分块执行三个步骤 当for循环结束时，队列中应该包含了很多等待GPU执行的工作。如果想要确保GPU只能执行完了计算和内存复制等操作。那么就需要将GPU与主机同步。也就是说主机在继续执行之前要先等待GPU完成。调用cudaStreamSynchronize()并指定想要等待的流 主机与设备之间复制数据 cudaMemcpy()同步方式执行：意味着，当函数返回时，复制操作已经完成，并且在输出缓冲区包含了复制进去的内容。 新函数cudaMemcpyAsync()异步方式执行：与同步方式相反，在调用该函数时，只是放置一个请求，表示在流中执行一次内存复制操作，这个流是通过函数stream来指定的。当函数返回时，我们无法确保复制操作是否已经启动，更无法保证它是否已经结束。我们能够保证的是，复制操作肯定会当下一个被放入流中的操作之前执行。 任何一个传递给cudaMemcpyAsync()的主机内存指针都必须已经通过cudaHostAlloc()分配好内存。你只能已异步方式对固定内存进行复制操作。 带有流参数的核函数此时核函数的调用是异步的。 使用多个流 改进思想： 分块计算 内存复制和核函数执行的重叠 上图中，第0个流执行：核函数时，在第1个流中执行：输入缓冲区复制到GPU…… 在任何支持内存复制和核函数的执行相互重叠的设备上，当使用多个流是，应用程序的整体性能都会提升。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include \"../common/book.h\"#define N (1024*1024)#define FULL_DATA_SIZE (N*20)__global__ void kernel( int *a, int *b, int *c ) { int idx = threadIdx.x + blockIdx.x * blockDim.x; if (idx &lt; N) { int idx1 = (idx + 1) % 256; int idx2 = (idx + 2) % 256; float as = (a[idx] + a[idx1] + a[idx2]) / 3.0f; float bs = (b[idx] + b[idx1] + b[idx2]) / 3.0f; c[idx] = (as + bs) / 2; }}int main( void ) { cudaDeviceProp prop; int whichDevice; HANDLE_ERROR( cudaGetDevice( &amp;whichDevice ) ); HANDLE_ERROR( cudaGetDeviceProperties( &amp;prop, whichDevice ) ); if (!prop.deviceOverlap) { printf( \"Device will not handle overlaps, so no speed up from streams\\n\" ); return 0; } //事件 cudaEvent_t start, stop; float elapsedTime; //流 cudaStream_t stream0, stream1; int *host_a, *host_b, *host_c; int *dev_a0, *dev_b0, *dev_c0; int *dev_a1, *dev_b1, *dev_c1; HANDLE_ERROR( cudaEventCreate( &amp;start ) ); HANDLE_ERROR( cudaEventCreate( &amp;stop ) ); HANDLE_ERROR( cudaStreamCreate( &amp;stream0 ) ); HANDLE_ERROR( cudaStreamCreate( &amp;stream1 ) ); // 申请内存 HANDLE_ERROR( cudaMalloc( (void**)&amp;dev_a0, N * sizeof(int) ) ); HANDLE_ERROR( cudaMalloc( (void**)&amp;dev_b0, N * sizeof(int) ) ); HANDLE_ERROR( cudaMalloc( (void**)&amp;dev_c0, N * sizeof(int) ) ); HANDLE_ERROR( cudaMalloc( (void**)&amp;dev_a1, N * sizeof(int) ) ); HANDLE_ERROR( cudaMalloc( (void**)&amp;dev_b1, N * sizeof(int) ) ); HANDLE_ERROR( cudaMalloc( (void**)&amp;dev_c1, N * sizeof(int) ) ); //申请页锁定内存 HANDLE_ERROR( cudaHostAlloc( (void**)&amp;host_a, FULL_DATA_SIZE * sizeof(int), cudaHostAllocDefault ) ); HANDLE_ERROR( cudaHostAlloc( (void**)&amp;host_b, FULL_DATA_SIZE * sizeof(int), cudaHostAllocDefault ) ); HANDLE_ERROR( cudaHostAlloc( (void**)&amp;host_c, FULL_DATA_SIZE * sizeof(int), cudaHostAllocDefault ) ); //初始化页锁定内存 for (int i=0; i&lt;FULL_DATA_SIZE; i++) { host_a[i] = rand(); host_b[i] = rand(); } HANDLE_ERROR( cudaEventRecord( start, 0 ) ); // now loop over full data, in bite-sized chunks for (int i=0; i&lt;FULL_DATA_SIZE; i+= N*2) { // stream0 HANDLE_ERROR( cudaMemcpyAsync( dev_a0, host_a+i, N * sizeof(int), cudaMemcpyHostToDevice, stream0 ) ); HANDLE_ERROR( cudaMemcpyAsync( dev_b0, host_b+i, N * sizeof(int), cudaMemcpyHostToDevice, stream0 ) ); kernel&lt;&lt;&lt;N/256,256,0,stream0&gt;&gt;&gt;( dev_a0, dev_b0, dev_c0 ); HANDLE_ERROR( cudaMemcpyAsync( host_c+i, dev_c0, N * sizeof(int), cudaMemcpyDeviceToHost, stream0 ) ); // stream1 HANDLE_ERROR( cudaMemcpyAsync( dev_a1, host_a+i+N, N * sizeof(int), cudaMemcpyHostToDevice, stream1 ) ); HANDLE_ERROR( cudaMemcpyAsync( dev_b1, host_b+i+N, N * sizeof(int), cudaMemcpyHostToDevice, stream1 ) ); kernel&lt;&lt;&lt;N/256,256,0,stream1&gt;&gt;&gt;( dev_a1, dev_b1, dev_c1 ); HANDLE_ERROR( cudaMemcpyAsync( host_c+i+N, dev_c1, N * sizeof(int), cudaMemcpyDeviceToHost, stream1 ) ); } //两个流都要将CPU与GPI同步。 HANDLE_ERROR( cudaStreamSynchronize( stream0 ) ); HANDLE_ERROR( cudaStreamSynchronize( stream1 ) ); // HANDLE_ERROR( cudaEventRecord( stop, 0 ) ); HANDLE_ERROR( cudaEventSynchronize( stop ) ); HANDLE_ERROR( cudaEventElapsedTime( &amp;elapsedTime, start, stop ) ); printf( \"Time taken: %3.1f ms\\n\", elapsedTime ); // cleanup the streams and memory HANDLE_ERROR( cudaFreeHost( host_a ) ); HANDLE_ERROR( cudaFreeHost( host_b ) ); HANDLE_ERROR( cudaFreeHost( host_c ) ); HANDLE_ERROR( cudaFree( dev_a0 ) ); HANDLE_ERROR( cudaFree( dev_b0 ) ); HANDLE_ERROR( cudaFree( dev_c0 ) ); HANDLE_ERROR( cudaFree( dev_a1 ) ); HANDLE_ERROR( cudaFree( dev_b1 ) ); HANDLE_ERROR( cudaFree( dev_c1 ) ); HANDLE_ERROR( cudaStreamDestroy( stream0 ) ); HANDLE_ERROR( cudaStreamDestroy( stream1 ) ); getchar(); return 0;} 因为使用了两个流，for循环中处理的数据量为原来的两倍，步长为原来的两倍，程序处理的总数据量不变。 处理数据量是相同的，结果是一个流与两个流使用的时间差不多。 一个流使用的时间是24.1ms～25.2ms， 两个流使用的时间是：23.1～23.9ms， 修改后代码使用时间为23.9ms～24.9ms 使用了流的确改善了执行时间，但是在一个流和多个流之间并没有明显的性能提高。 GPU工作调度机制 程序员可以将流视为有序的操作序列，其中既包含内存复制操作，又包含核函数调用。 然而，硬件中并没有流的概念，而是包含一个或多个引擎来执行内存复制操作，以及一个引擎来执行核函数。这些引擎彼此独立地对操作进行排队。 应用程序首先将第0个流的所有操作放入队列，然后是第一个流的所有操作。CUDA驱动程序负责按照这些操作的顺序把他们调度到硬件上执行，这就维持了流内部的依赖性。图10.3说明了这些依赖性，箭头表示复制操作要等核函数执行完成之后才能开始。 于是得到这些操作在硬件上执行的时间线： 图中显示，第0个流复制C阻塞了第1个流复制A,第一个流复制B，导致第0个流执行完核函数还要等待内存复制引擎完成流0复制C，流1复制A，流1复制B的三个操作才能执行流1核函数 由于第0个流中将c复制回主机的操作要等待核函数执行完成，因此第1个流中将a和b复制到GPU的操作虽然是完全独立的，但却被阻塞了，这是因为GPU引擎是按照指定的顺序来执行工作。记住，硬件在处理内存复制和核函数执行时分别采用了不同的引擎，因此我们需要知道，将操作放入流队列中的顺序将影响着CUDA驱动程序调度这些操作以及执行的方式。 高效使用多个流如果同时调度某个流的所有操作，那么很容易在无意中阻塞另一个流的复制操作或者核函数执行。要解决这个问题，在将操作放入流的队列时应采用宽度优先方式，而非深度优先方式。如下代码所示： 12345678910111213141516171819202122232425262728293031323334for (int i=0; i&lt;FULL_DATA_SIZE; i+= N*2) { // enqueue copies of a in stream0 and stream1 HANDLE_ERROR( cudaMemcpyAsync( dev_a0, host_a+i, N * sizeof(int), cudaMemcpyHostToDevice, stream0 ) ); HANDLE_ERROR( cudaMemcpyAsync( dev_a1, host_a+i+N, N * sizeof(int), cudaMemcpyHostToDevice, stream1 ) ); // enqueue copies of b in stream0 and stream1 HANDLE_ERROR( cudaMemcpyAsync( dev_b0, host_b+i, N * sizeof(int), cudaMemcpyHostToDevice, stream0 ) ); HANDLE_ERROR( cudaMemcpyAsync( dev_b1, host_b+i+N, N * sizeof(int), cudaMemcpyHostToDevice, stream1 ) ); // enqueue kernels in stream0 and stream1 kernel&lt;&lt;&lt;N/256,256,0,stream0&gt;&gt;&gt;( dev_a0, dev_b0, dev_c0 ); kernel&lt;&lt;&lt;N/256,256,0,stream1&gt;&gt;&gt;( dev_a1, dev_b1, dev_c1 ); // enqueue copies of c from device to locked memory HANDLE_ERROR( cudaMemcpyAsync( host_c+i, dev_c0, N * sizeof(int), cudaMemcpyDeviceToHost, stream0 ) ); HANDLE_ERROR( cudaMemcpyAsync( host_c+i+N, dev_c1, N * sizeof(int), cudaMemcpyDeviceToHost, stream1 ) ); } 如果内存复制操作的时间与核函数执行的时间大致相当，那么新的执行时间线将如图10.5所示，在新的调度顺序中，依赖性仍然能得到满足： 由于采用了宽度优先方式将操作放入各个流的队列中，因此第0个流对c的复制操作将不会阻塞第1个流对a和b的内存复制操作。这使得GPU能够并行的执行复制操作和核函数，从而使应用程序的运行速度显著加快。 实验结果表明，并没有改进性能，可能是高版本的CUDA运行时已经对流和复制引擎等进行了优化（个人猜想）","link":"/2019/05/24/cudanote7/"},{"title":"C++ 笔记3","text":"第9章 内存模型和名称空间 9内存模型和名称空间（4）原来的程序分为三个部分 头文件：包含结构声明和使用这些结构的函数的原型//结构声明与函数原型 源代码文件：包含与结构有关的函数代码 //函数 源代码文件：包含调用与结构相关的函数的代码 //调用函数 这种组织方式也与oop方式一致。 一个文件（头文件）包含用户定义类型的定义； 另外一个文件包含操纵用户定义类型的函数代码； 这两个文件组成了一个软件包，可用于各种程序中。 请不要将函数定义或变量声明放在头文件中，如果其他文件都包含这个头文件，那么同一个函数就会有多次定义，变量也同理，会出错。 头文件中常包含的内容： 函数原型。 使用#define或const定义的符号常量（头文件中不可以创建变量） 结构声明=&gt;因为它们不创建变量 模板声明=&gt;模板声明不是将被编译的代码，他们指示编译器如何生成源代码中的函数调用相匹配的函数定义。 内联函数–&gt;只有它可以在头文件定义函数。 被声明为const的数据和内联函数有特殊的链接属性 注意：在IDE中 不要将头文件加入到项目列表中 也不要在源代码文件中使用#include来包含其他源代码文件 在同一文件中只能将同一个头文件包含一次。–&gt;使用预编译指令 1234#ifndef COORDIN_H_...#endif 但是这种方法并不能防止编译器将头文件包含两次，而只是让它忽略第一次包含之外的所有内容。大多数标注C和C++头文件都是用各种防护(guarding)方案。否则，可能在一个文件中定义同一个结构两次，这将导致编译错误。 编译在UNIX系统中编译由多个文件组成的C++程序 编译两个源代码文件的UNIX命令： CC file1.cpp file2.cpp 预处理将包含的文件与源代码文件合并： 临时文件： temp1.cpp temp2.cpp 编译器创建每个源代码文件的目标代码文件：file1.o file2.o 链接程序将目标代码文件(file1.o file2.o)、库代码(Library code)和启动代码(startup code)合并，生成可执行文件：a.out 多个库的链接 由不同编译器创建的二进制模块（对象代码文件）很可能无法正确地链接。 原因：两个编译器为同一个函数生成不同的名称修饰 名称的不同将使链接器无法将一个编译器生成的函数调用与另外一个编译器生成的函数定义匹配。在链接编译模块时，请确保所有对象文件或库都是由同一编译器生成的。 链接错误解决的方法：如果有源代码，通常可以用自己的编译器重新编译来消除错误。 存储持续性，作用域与和链接性C++中的四种存储方案 自动存储持续性 :在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。 静态存储持续性 :在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态。（请注意）它们在整个运行过程中都存在。 线程存储持续性(C++11) :当前，多核处理器很常见，这些CPU可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_local声明的，则其生命周期与所属的线程一样长。 动态存储持续性 :用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储(free store)或堆(heap)。 作用域和链接性 作用域(scope) 描述了名称在文件的多大范围内可见。例如，函数中定义的变量可在该函数中使用，但不能在其他函数中使用；而在文件中的函数定义之前定义的变量则可在所有函数中使用。 作用域：局部与全局–&gt;(代码块/文件) 作用域为局部的变量只在定义它的代码块中可用。（代码块：由花括号括起的一系列语句，比如：函数体） 做英语为全局（也叫文件作用域）的变量在定义位置到文件结尾都可以用。 链接性(linkage) 描述了名称如何在不同单元间共享。链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享，自动变量的名称没有链接性，因为它们不能共享。 C++内存空间分布1.命令行参数和环境变量 shell在执行程序的时候调用exec函数将命令行参数传递给要执行的程序。 使程序了解进程环境，在执行时分配空间。 2.bss段（Block Start by Symbol） 存放未初始化的全局变量或者静态变量。 3.data段 存放具有明确初始值的全局变量或者静态变量。 存在于程序镜像文件中，由 exec 函数从程序镜像文件中读入内存。 4.text段 CPU执行的机器指令。 堆栈简要概述栈：系统自动开辟空间，自动分配自动回收，在作用域运行完成后（函数返回时）就会被回收。 堆：由程序员自己申请空间，释放空间，不释放会出现内存泄漏。 栈 1.栈是连续的向下扩展的数据结构，总共只有1M或者2M的空间。空间不足就会异常提示栈溢出。 2.存储自动变量, 函数调用者信息, 包括函数参数(可变参数列表的压栈方向是从右向左), 函数内局部变量, 函数返回值, 函数调用时的返回地址。 堆 1.堆是不连续的向上扩展的数据结构，大小受限于计算机系统虚拟内存的大小。 2.操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。 对于大多数系统，会在这块内存空间中的首地址处（一般为一个字节的大小）记录本次分配的大小，这样，代码中的 delete语句才能正确的释放本内存空间。 由于找到的堆结点的空间大小可能大于申请的大小，系统会自动的将多余的那部分（即内存碎片）重新放入空闲链表中。这就涉及到申请效率的问题。 引入名称空间之前下面列出5种变量存储方式（引用名称空间之前） 存储描述 持续性 作用域 链接性 如何声明 自动 自动 代码块 无 在代码块中 寄存器 自动 代码块 无 在代码块中，使用关键字register 静态,无链接性 静态 代码块 无 在代码块中，使用关键字static 静态,外部链接性 静态 文件 外部 不在任何函数内 静态,内部链接性 静态 文件 内部 不在任何函数内，使用关键字static 自动存储持续性 在默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性（自动变量不能共享）。 自动变量的初始化：可以使用任何声明时其值已知的表达式来初始化自动变量int x=5;int y=2*x; 自动变量和栈：自动变量的数目随函数的开始和结束而增减，因此程序必须在运行是对自动变量进行管理。常用方法是流出一段内存，并将其视为栈。程序使用两个指针来跟踪栈，一个指向栈底，栈的开始位置。另外一个指针指向栈顶，下一个可用内存单元。栈是LIFO（后进先出）的，即最后加入到栈中的变量首先被弹出。 寄存器变量–&gt;旨在提高访问变量的速度 关键字register最初由C语言引入的，它建议编译器使用CPU寄存器来存储自动变量 1register int count_fast;//request for a register variable 鉴于关键字register只能用于原来就是自动的变量，使用它的唯一原因是，指出程序员想使用一个自动变量，这个变量名可能与外部变量相同 静态持续变量 C++也为静态存储持续性提供了三种链接性 1.外部链接性（可在其他文件中访问） 2.内部链接性（只能在当前文件中访问） 3.无链接性（只能在当前函数或代码块中访问） 这三种链接性都在整个程序执行期间一直存在，与自动变量相比，他们的寿命更长。由于静态变量的数目在程序运行期间是不变的，因此程序不需要使用特殊的装置（如栈）来管理它们，编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。另外，如果没有显示地初始化静态变量，编译器将把它设置为0。在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0。被称为0初始化 例子： 123456789101112int NUM_ZDS_GLOBAL = 80; //#1static int NUM_ZDS_ONEFILE = 50; //#2int main(){…}void fun1(int n){static int nCount = 0; //#3int nNum = 0; //#4}void fun2(int q){ …} #1、#2、#3在整个程序运行期间都存在。在fun1中声明的#3的作用域为局部，没有链接性，这意味着只能在fun1函数中使用它，就像自动变量#4一样。但是，与#4不同的是，即使在fun1没有被执行的时候，#3也保留在内存中。 静态变量初始化 123456#include&lt;cmath&gt;int x; //零初始化 int y=5; //常量表达式初始化long z=13*13; //常量表达式初始化const double pi=4.0*atan(1.0);//动态初始化，要初始化pi，必须调用函数atan()，这需要等到函数被链接上且程序执行时。（这也是常量表达式初始化）//C++新增关键字constexpr，这增加了创建常量表达是的方式 1.静态持续性，外部链接性==&gt;普通全局变量链接性为外部的变量通常称为外部变量，它们的存储持续性为静态，作用域为整个文件。 外部变量是函数外部定义的，因此对所有函数而言都是外部的。 例如，可以在main()前面或头文件中定义他们。可以在文件中位于外部定义后面的任何函数中使用它。 因此外部变量也称为全局变量。 全局变量是在所有函数体的外部定义的，程序的所在部分（甚至其它文件中的代码）都可以使用。全局变量不受作用域的影响（也就是说，全局变量的生命期一直到程序的结束）。如果在一个文件中使用extern关键字来声明另一个文件中存在的全局变量，那么这个文件可以使用这个数据。 单定义规则一方面，在每个使用外部变量的文件中，都必须声明它；另外一方面，C++有“单定义规则”，该规则指出，变量只有一次定义。 为满足这种需求，C++提供了两种变量声明。 一种是定义声明（defining declaration）或简称为定义（definition），它给变量分配存储空间。 一种是引用声明（referencing declaration）或简称为声明（declaration），它不给内存变量分配存储空间。 引用声明使用关键字extern，且不进行初始化；否则，声明未定义，导致分配内存空间：例 123double up;//definition,up is 0 定义extern int bllem;//blem defined elsewhere 声明，blem变量在某处定义了extern char gr = 'z';//definition because initialized 定义 注意： 单定义规则并非意味着不能有多个变量名称相同 如果函数中声明了一个与外部变量同名的变量，结果将如何呢？ 12345678910111213141516//external1.cpp 文件1double warning=0.3;//warning defined 定义//support.cpp 文件2extern double warning;//use warning from another file 使用外部定义的变量warning......void update(double dt){extern double warning;//optional redeclaration......}void local(){//定义域全局变量名相同的局部变量都，局部变量将隐藏全局变量double warning=0.8;//new variable hides external one......} 通常情况下，应使用局部变量，然而全局变量也有它们的用处。例如，可以让多个函数可以使用同一个数据块（如月份，名数组或原子量数组）。外部存储尤其适用于表示常量数据，因为这样可以使用关键字const来防止数据修改。 2.静态持续性，内部链接性==&gt;Static全局变量 全局变量（外部变量）的说明之前再冠以static就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。 由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。 static全局变量与普通的全局变量的区别是static全局变量只初始化一次，防止在其他文件单元被引用。 3.静态持续性，无链接性==&gt;静态局部变量这种变量是这样创建的，将static限定符用于代码块中定义的变量。 在两次函数调用之间，静态局部变量的值将保持不变，它同时拥有静态变量和局部变量的特性，即： 编译时自动初始化 会被放到静态内存的静态区 只能在局部被访问 作用：有时候我们需要在两次调用之间对变量进行保存，通常的想法是定义一个全局变量来实现。但这样一来变量就不属于函数本身了，而受全局变量的控制。静态局部变量正好可以解决这个问题，静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下一次赋新值 说明符和限定符存储说明符(storage class specifier) auto(在C++11中不再是说明符)：在C++11之前，可以在声明中使用关键字auto来指出变量为自动变量；但在C++11中，auto用于自动类型推断。 register：用于在声明中指示寄存器存储，在C++11中，它只是显式地指出变量是自动的。 static:关键字static被用在作用域为整个文件的声明中时，表示内部链接性；被用于局部声明中，表示局部变量的存储持续性为静态的。 thread_local(C++11新增)：可以用static或extern结合使用，关键字thread_local指出变量持续性与其所属的持续性相同。thread_local变量之于线程，由于常规静态变量至于整个程序。 mutable：关键字mutable的含义根据const来解释 mutable:可以用来指出，即使结构（或类）变量为const，其某个成员也可以被修改。 12345678910struct data{char name[30];mutable int accesses;...}const data veep={\"claybourne clodde\",0,...};strcpy(veep.name,\"ytttt\"); //not allowedveep.accessses++; //allowed CV限定符（cv-qualifier） const:它表明，内存被初始化后，程序便不能再对他进行修改。 volatile: volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问 再谈const const限定对默认存储类型稍有影响。在默认情况下，全局变量的链接性为外部的，但const全局变量的链接性为内部的 1234const int fingers = 10;//same as static const init fingers=10;int main(){...} 原因：C++这样子修改了常量类型的规则，让程序员更轻松 假如，假设将一组常量放在头文件中，并在同一程序的多个文件中使用该头文件。那么预处理器将头文件中的内容包含到每个源文件后，所有的源文件都将包含类似下面的定义： 12const int fingers=10;const char* warning =\"wak!\"; 如果全局const声明的链接性像常规变量那样是外部的，则根据单定义规则，这将出错（二义性）。也就是说只能有一个文件可以包含前面的声明，而其他文件必须使用extern关键字来提供引用声明。另外只有未使用extern关键字的生命才能进行初始化。 然而，由于外部定义的const数据的链接性为内部的，因此可以在所有文件中使用相同的声明。 内部链接性意味着每个文件都有自己一组常量，而不是所有文件共享一组常量。每个定义都是其所属文件所私有的，这就是能够将常量定义放在头文件中的原因。 函数和链接性 和C语言一样，C++不允许在一个函数中定义另外一个函数=&gt;因此所有函数的存储持续性都自动为静态的，即整个程序执行期间都一直存在。 在默认情况喜爱，函数的链接性为外部的，即可以在文件间共享。 实际上可以使用extern关键字来指出函数是在另外一个文件中定义的，不过这是可选的。 使用关键字static将函数链接性改为内部链接性，使其只能在本文件中使用，必须在原型和函数定义中同时使用该关键字。 单定义规则也适用于非内联函数，因此对于每个非内联函数，程序只能包含一个定义。对于链接性味外部的函数来说，这意味着在多文件程序中，只能有一个文件包含该函数的定义，但使用该函数的每个文件都应包含其函数原型。 内联函数不受这种规则的约束，这允许程序员能够将内联函数的定义放在头文件中，这样包含了头文件的每个文件都有内联函数的定义。然而，C++要求同一个函数的所有内联定义都必须相同。 C++在哪里寻找函数？假设在程序的某个文件中调用一个函数，C++将到哪里寻找函数定义？ 如果该文件中的函数原型指出该函数是静态的，则编译器将只在该文件中查找函数定义； 否则，编译器（包括链接程序）将在所有文件中查找。 如果在程序文件中找不到，编译器将在库中搜索。这意味着，如果定义了一个与库函数同名的函数，编译器将使用程序员定义的版本，而不是库函数。 语言链接性链接程序要求每个不同的函数都有不同的符号名。在C语言中，一个名词只对应一个函数，因此这很容易实现。为满足内部需要，C语言编译器可能将spiff这样的函数名翻译为_spiff。这种方法称为C语言链接性（C language linkage）。但在C++中，同一个名称可能对应多个函数，必须将这些函数翻译为不同的符号名称。因此，C++编译器执行名称纠正或名称修饰，为重载函数生成不同的符号名称。例如，spiff（int）转换为—_spiff_i，而将spiff(double, double)转换为_spiff_d_d。这种方法称为C++语言的链接性（C++ language linkage）。 如果要在C++程序中使用C语言预编译的函数，将出现什么情况呢？例如，假设有如下代码：spiff(22);它在C库文件中的符号名称为_spiff,但对于我们的C++链接程序来说，C++查询约定是查找符号民称_spiff_i。为解决这样的问题，可以用函数原型来指出要使用何种约定： 123extern “C” void spiff(int);//使用C语言链接性extern void spoff(int);//使用C++语言的链接性(通过默认方式指出)extern “C++” void spaff(int);//使用C++语言的链接性（通过显式指出） C和C++链接性是C++标准制定的说明符，但实现可以提供其他语言链接性说明符。 存储方案和动态分配使用C++运算符new（或C函数malloc()）分配的内存，这种内存被称为动态内存，动态内存由运算符new和delete控制，而不是由作用域和链接性规则控制。因此，可以在一个函数中分配动态内存，而在另外一个函数中将其释放。其分配方式要取决于new和delete在何时以何种方式被使用。通常编译器使用三块独立的内存： 一块用于静态变量（可能再细分） 一块用于自动变量 另外一块用于动态存储 虽然存储方案概念不是用于动态内存，但适用于用来跟踪动态内存的自动和静态指针变量（自动指针变量，静态指针变量），指针变量还是有作用域和链接性的 new运算符如果要为内置的标量类型（int、double）分配存储空间并初始化，可在类型名后面加上初始值，并将其用括号括起。 1int *pi = new int(6); 要初始化常规结构或数组，需要使用大括号的列表初始化，这要求编译器支持C++11。 123struct where{double x, double y, double z};where *one = new where{2.5, 5.3, 7.2};int *ar = new int[4] {2, 4, 7, 6}; 在C++11中，还可将初始化列表用于单值变量： 1int *pin = new int {6}; new失败时 在最初的10年中，C++让new失败时返回空指针，但现在将引发std::bad_alloc异常。 new：运算符、函数和替换函数运算符与函数： 1234567891011//分配函数（allcation function）；void *operator new(std::size_t);//函数void *operator new[](std::size_t);//函数//释放函数（deallocation function）；void *operator delete(void *);//函数void *operator delete[](void *);//函数int *pi=new int;//运算符int *pi=new(sizeof(int));//函数int *pi=new int[40];//运算符int *pi=new(40*sizeof(int));//函数 替换函数： 有趣的是，C++将这些函数（分配函数，释放函数）称为可替换的（replaceable）。这意味着如果您有足够的知识和意愿，可为new和delete提供替换函数，并根据需要对其进行定制。例如，可定义作用域为类的替换函数，并对其进行定制，以满足该类的内存分配需求。在代码中，仍将使用new运算符，但它将调用您定义的new()函数。 定位new运算符通常，new负责在堆（heap）中找到一个足以能够满足要求的内存块。new运算符还有另一种变体，被称为定位（placement）new运算符，它让您能够指定要使用的位置。程序员可能使用这种特性来设置其内存管理规程、处理需要通过特定地址进行访问的硬件或在特定位置创建对象。 要使用定位new特性，首先需要包含头文件new，它提供了这种版本的new运算符的原型；然后将new运算符用于提供了所需地址的参数。除需要指定参数外，句法与常规new运算符相同。具体地说，使用定位new运算符时，变量后面可以有方括号，也可以没有。下面的代码段演示了new运算符的4种用法： 1234567891011121314#include &lt;new&gt;char buffer1[50];//静态数组char buffer2[500];struct chaff{char dross[20];int slag;};chaff *p1, *p2;int *p3, *p4;p1=new chaff; //place structure in heapp3=new int[20]; //place int array in heapp2=new (buffer1) chaff; //place structure in buffer1p4=new (buffer2) int[20]; //place int array in buffer2 上述代码从buffer1中分配空间给结构chaff，从buffer2中分配空间给一个包含20个元素的int数组。 定位new运算符的其他形式就像常规new调用一个接受一个参数的new函数一样，标准定位new调用一个接收两个参数的new函数。 123int * p1=new int;//调用 new(sizeof(int))int * p2=new(buffer) int;//调用 new(sizeof(int),buffer)int * p3=new(buffer) int[40];//调用new(40*sizeof(int),buffer) 定位new运算符不可替换，但可重载。至少需要接收两个参数，其中第一个总是std::size_t，指定了请求的字节数。这样的重载函数都被定义为new。 名称空间在C++中，名称可以是变量，函数，结构，枚举，类以及类的结构成员 两个概念：声明区域、潜在作用域声明区域(declaration region) 可以在其中进行声明的区域 在函数外面声明全局变量=&gt;对这种变量，其声明区域为其声明所在的文件。对于在函数声明的变量=&gt;其声明区域为其声明所在的代码块。 潜在作用域（potential scope） 变量潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域比声明区域小，这是由于变量必须定义后才能使用。 变量并非在其潜在作用域的任何位置都是可见的。 例如，它可能被另外一个嵌套声明区域中声明的同名变量隐藏 例如，在函数声明的局部变量（对于这种变量，声明区域为整个函数）将隐藏在同一文件中声明的全局变量（对于这种变量，声明区域为整个文件）。 变量对程序而言可见的范围被称为作用域（scope）。 新的名称空间(命名的名称空间)即通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会和另一个名称空间中的名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。 关键字namespace 名称空间可以是全局的，也可以位于另一个名称空间中，但是不能位于代码块中。因此在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。 除用户定义的名称空间，还存在另外一个名称空间全局名称空间(global namespace)。它对应文件级声明区域，因此前面所说的全局变量现在被描述为位于全局名称空间中 using 声明和using编译指令 using声明使特定的标识符可用: 1 using std::cout;//将cout添加到它所属的声明区域中，即使得cout能够在main函数中直接使用 using编译指令使整个名称空间可用： 1 using namespace std;//使得std空间中所有的名称都可以直接使用 using编译指令和using声明之比较 使用using声明时，就好像声明了相应的名称一样，如果某个名称已经在函数中声明了，则不能用using声明导入相同的名称。 然而，使用using编译指令时，将进行名称解析，就像在包含using声明和名称空间本身的最小声明区域中声明了名称一样。如果使用using编译指令倒入一个已经在函数中声明的名称，则局部名称将隐藏名称空间名，就像隐藏同名的全局变量一样。 一般来说，使用using声明要比使用using编译指令更加安全，这是由于它只能导入指定的名称，如果该名称与局部名称发生冲突，编译器将发出指示。 using编译指令导入所有的名称，包括可能并不需要的名称，如果与局部名称发生冲突，则局部名称将覆盖名称空间版本而编译器不发出警告！ 另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。所以我们平时自己写程序时先怼一个using namespace std;上去可能并不是一个很好的决定。","link":"/2019/05/23/Cppnote3/"},{"title":"C++ 笔记(总)","text":"C++ Primer Plus(第六版)笔记 1～4基础 浮点运算的速度通常比整型运算慢， 对于标量运算float和double都不了没有明显差别 对于矢量运算double比float慢得多 运算符重载（operator overloading）：使用相同符号进行多种操作 1.C++内置重载 9/5 int ； 9L/5L long ； 9.0/5.0 double ； 9.0f/5.0f float 2.C++扩展运算符重载 int guess(3.9832);结果：guess=3; 将浮点float转换为整型int时，采用截取（丢弃小数部分），而不是四舍五入 将一个值赋值给取值范围更大的类型通常不会导致什么问题，只是占用的字节更多而已。 列表初始化(使用大括号初始化)不允许窄缩（float--&gt;int）。 (long)thorn; long(thron);强制类型转换不会改变thorn变量本身，而是创建一个新的，指定类型的值。 auto让编译器能够根据初始值的类型推断变量的类型。 C++的基本类型 整数值(内存量及有无符号)： bool,char,signed char,unsigned char,short,unsigned short,int,unsigned int,long,unsigned long,(新)long long,unsigned long 浮点格式的值：float(32位),double(64位),long double（94～128位） 复合类型：数组；字符串：1.字符数组char array 2.string类；结构：struct；共同体：union；枚举：enum；指针：int* ,long*数组（array）123456short months[12];int yamcosts[3]={20,30.5};double earning[4]{1.2e4,1.6e4,1.4e4,1.7e4};float balances[100]{};//初始化全部元素值为0//字符串char boss[8]=\"Bozo\"//后面四个元素为\"\\0\"空字符 using using namespace XXX;这是指示 引入名称空间内所有的名称：将XXX名称空间，所有成员变成可见，作用域和using声明一致；例：using namespace std; using XXX;这是声明 引入名称空间或基类作用域内已经被声明的名称：一次只引入一个命名空间成员;using std::cout; 类之于对象，类型之于变量对象和变量都是用来描述一段内存的。 变量更强调的是变量名这个符号的含义，更强调名字与内存的联系，而不必关注这段内存是什么类型，有多少字节长度，只关注这个变量名a对应着某段内存。 而对象的描述更强调的是内存的类型而不在乎名字，也就是说,从对象的角度看内存，就需要清除这段内存的字节长度等信息，而不是关注这个对象在代码中是否有一个变量名来引用这段内存。struct结构 struct和class的区别 struct能包含成员函数吗？ 能！ struct能继承吗？ 能！！ struct能实现多态吗？ 能！！！ 既然这些它都能实现，那它和class还能有什么区别？最本质的一个区别就是默认的访问控制，体现在两个方面：默认继承访问权限和默认成员访问权限 1）默认的继承访问权限。struct是public的，class是private的。 2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。 做个总结，从上面的区别，我们可以看出，struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。 共用体union 它能够存储不同的数据类型，但只能同时存储其中的一种类型。 这种特性使得当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。 使用场合：1.对内存的使用苛刻，如嵌入式系统编程 2.操作系统数据结构或硬件数据结构 枚举 enum 提供了一种创建符号常量的方式，这种方式可以替代const。 它还允许定义新的类型，但必须按严格的限制进行。123456789101112enum spectrum{red,orange,yellow,green,blue,violet,indigo,wltraciolet};//对应整数值0～7（声明定义）//在不进行强制类型转换的情况下，只能将定义使用的枚举量赋给这种枚举的变量。spectrum band；//声明定义band = blue;//初始化（赋值）//枚举量是整型，可悲提升为int型int color = blue;//设置枚举量的值；enum bits{one=1,two=2,four=4,eight=8};enum bigstep{first,second=100,third};//first=0,third=101//枚举的取值范围bits myflag;myflag=bits(6);//强制类型转换（整数值），保证bits()输入的参数小茹bits的上限，上限=(2^n-1)&gt;max,max在bits中等于8 指针和自由存储空间1.使用常规变量时，值是指定的量，而地址为派生量。指针与C++基本原理1.编译阶段：编译器将程序组合起来 2.运行阶段：程序正在运行时–》oop强调的是在运行阶段进行决策 考虑为数组分配内存的情况，C++采用的方法是：使用关键字new请求正确数量的内存以及使用指针来跟踪新分配内存的位置2.处理存储数据的新策略刚好相反，将地址视为指定的量，将之视为派生量*运算符被称为间接值运算符或叫解除引用运算符（对指针解除引用意味着获得指针指向的值）。 &amp;地址运算符 注意：int * p1,p2;p1是指针，p2是int变量；对于每个指针变量名，都需要一个* 定义与初始化12345int h = 5;int *pt =&amp; h;//或int *pt;pt = &amp;h; 应用*之前，一定要将指针初始化为一个确定的，适当的地址。就是说一定要初始化，否则*pt 将值会赋给一个未知内存。否者都还没引用，又怎么接触引用呢？ 要将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型。1pt=(int *)0×B8000000; 使用new来分配内存变量：在编译时分配的有名称的内存。 指针的真正的用武之地在于，在运行阶段分配未命名的内存以及存储值，（C++中使用new运算符来实现）在这种情况下，只能通过指针来访问内存—&gt;所以new的出现都会有指针。 12typeName * pointer_name=new typeName;//使用new分配未命名的内存* pointer_name=1000;//对该未去命名的内存赋值 new从被称为堆（heap）或自由存储区(free store)的内存区域分配内存。delete pointer_name;//释放指针pointer_name指向的内存。释放pointer_name指向的内存，但不会删除pointer_name指针本身。例如，可以将pointer_name重新指向另外一个新分配的内存块。不要创建两个指向同一内存块的指针 对于大型数据对象来说，使用new，如数组、字符串、结构。 1.静态联编（static binding） 如果通过声明来创建数组，则程序被编译时将为它分配内存空间，不管程序最终是否使用数组，数组都在那里。它占用了内存，所以必须指定数组长度。 2.动态联编（dynamic binding） 意味着数组是在程序运行时创建的，这种数组叫作的哦你太数组。 使用new创建动态数组–&gt;Vector模板类是替代品 1234//创建int * psome =new int[10];//释放delete[] psome;//方括号告诉程序，应释放整个数组。 指针和数组等价的原因在于指针算术 将整数变量加1后，其值将增加1， 将指针变量加1后，增加的量等于它指向类型的字节数。 指针与数组之间的转换 数组：arrayname[i]等价于*(arrayname+i) 指针：pointername[i]等价于*(pointername+i) 因此，很多情况下，可以使用相同的方式使用数组名和指针名 const char *bird ='&quot;wren&quot;bird的值可以修改，但*bird值不可以修改。其实应该说是不能使用bird指针来修改！！！ 常量指针：const修饰的是“char * bird”，里面的值是不可以改变的。可以使用指针bird访问字符串“wren”但不能修改字符串。 char * const p =&quot;wren&quot;; 指针常量：const修饰的是指针“p”，指针的值是不能改变的。使用new来创建动态结构运行时创建数组（结构）由于编译时创建数组（结构） 创建一个未命名的inflatable类型，并将其地址赋给一个指针。 1inflatable *ps=new inflatble C++有三种管理数据内存的方式（不是说物理结构） 自动存储 静态存储 动态存储–&gt;有时也叫自由存储空间或堆 线程存储（C++11新增–&gt;第9章） 自动存储：自动变量（函数内部定义的常规变量）通常存储在栈中 —&gt;随函数被调用生产，随该函数结束而消亡 —&gt;自动变量是个局部变量，作用域为包含的代码块（{…}） 静态存储：使变量称为静态 1.在函数外面定义它 2.在声明变量是使用static关键字 static double free = 5650; 动态存储：使用new和delete（可能导致占用的自由存储去不连续）对数据的生命周期不完全受程序或函数的生存周期不完全受程序或函数的生存时间控制。 如果使用new运算符在自由存储（或堆）上创建变量后，没有调用delete。则即使包含指针的内存由于副作用或规则和对象生命周期的原因而被释放（将会无法访问自由存储空间中的结构，因为指向这些内存的指针无效。这将导致内存泄漏），在自由存储空间上动态内存分配的变量或结构也将继续存在。 类型组合数组名是一个指针 要用指向成员运算符123a_y_e trio[3];trio[0].year=2003;(trio+1)-&gt;year=2004; 1234567//创建指针数组const a_y_e *arp[3]={&amp;s01,&amp;s02,&amp;s03};std::cout&lt;&lt;arp[1]-&gt;year&lt;&lt;std::endl;//可创建指向上述收集自的指针：const a_y_e **ppa =arp;//麻烦//可以auto，让编译器自动推断auto ppa=arps; 数组的替代品 1.模板类vector–&gt;是一种动态数组–&gt;可以在运行时设置长度–&gt;它是使用new创建动态数组的替代品。 vector类自动通过new和delete来管理内存。vector&lt;typeName&gt; vt(n_elm); typeName:类型,vt:对象名,n_elm:个数：整型常量/变量 2.模板类array（C++11）–&gt;与数组一样，array对象长度也是固定的，也使用栈（静态内存分配），而不是自由存储去，因此其效率与数组相同，更方便，更安全。 12array&lt;int,5&gt;ai;array&lt;double,4&gt;ad={1.2,2.1,3.4,4.3};//列表初始化 C++的vector、array和数组的比较（都使用连续内存,而list内存空间是不连续的）在C++11中，STL中提拱了一个新的容器std::array，该容器在某些程度上替代了之前版本的std::vector的使用，更可以替代之前的自建数组的使用。那针对这三种不同的使用方式，先简单的做个比较： 相同点： 三者均可以使用下标运算符对元素进行操作，即vector和array都针对下标运算符[]进行了重载 三者在内存的方面都使用连续内存，即在vector和array的底层存储结构均使用数组 不同点： vector属于变长容器，即可以根据数据的插入删除重新构建容器容量；但array和数组属于定长容量。 vector和array提供了更好的数据访问机制，即可以使用front和back以及at访问方式，使得访问更加安全。而数组只能通过下标访问，在程序的设计过程中，更容易引发访问 错误。 vector和array提供了更好的遍历机制，即有正向迭代器和反向迭代器两种 vector和array提供了size和判空的获取机制，而数组只能通过遍历或者通过额外的变量记录数组的size vector和array提供了两个容器对象的内容交换，即swap的机制，而数组对于交换只能通过遍历的方式，逐个元素交换的方式使用 array提供了初始化所有成员的方法fill vector提供了可以动态插入和删除元素的机制，而array和数组则无法做到，或者说array和数组需要完成该功能则需要自己实现完成。**但是vector的插入删除效率不高（从中间插入和删除会造成内存块的拷贝），但能进行高效的随机存储，list能高效地进行插入和删除，但随机存取非常没有效率遍历成本高。 由于vector的动态内存变化的机制，在插入和删除时，需要考虑迭代的是否失效的问题。 基于上面的比较，在使用的过程中，可以将那些vector或者map当成数组使用的方式解放出来，可以直接使用array；也可以将普通使用数组但对自己使用的过程中的安全存在质疑的代码用array解放出来。 函数函数—C++的编程模块（要提高编程效率，可更深入地学习STL和BOOST C++提供的功能） 1.提供函数定义 function definition 2.提供函数原型 function prototype 3.调用函数 function call 12345Void functionName(parameterlist){statement(s)teturn;} parameterlist:指定了传递给函数的参数类型和数量 void:没有返回值，对于有返回值的函数，必须有返回语句return 1.返回值类型有一定的喜爱内置：不能是数组，但可以是其他任何类型—整数，浮点数，指针，甚至可以是结构和对象。 2.函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。 为什么需要原型原型描述了函数到编译器的接口，它将1.函数返回值类型（如果有的话）以及2.参数的类型和3.数量告诉编译器。（在原型的参数列表中，可以包含变量名，也可以不包含。原型中的变量名相当于占位符，因此不必与函数中的变量名相同） 确保：编译器正确处理1，编译器检查2，3 函数参数传递和按值传递 用于接收传递值的变量被称为形参（parameter），传递给函数的值被称为实参（argument）。 值传递：调用函数时，使用的是实参的副本，而不是原来的数据。 在函数中声明的变量（局部变量（自动变量））（包括参数）是该函数私有的，函数调用时：计算机将为这些变量分配内存；函数结束时：计算机将释放这些变量使用的内存。 函数和数组123int sum_arr(int arr[],int n);//arr=arrayname.n=sizeint sum_arr(int arr[],int n);//arr=arrayname.n=size//两者是等价的 const保护数组（输入数组原数据不能改变）void show_array(const double ar[],int n);//声明形参时使用const关键字 该声明表明，指针or指向的是常量数据。这意味着不能使用or修改数据。这并不意味着原始数据必须是常量 如果该函数要修改数组的值，声明ar时不能使用const 1.对于处理数组的C++函数，必须将数组中的 1.数据类型 2.数组的起始位置 3.和数组元素中的数量提交给他 传统的C/C++方法是，将指向数组起始处的指针作为一个参数，将数组长度作为第二个参数（指针指出数组位置和数据类型） 2.第二种方法：指定元素区间（range）通过传递两个指针来完成：一个指针表示数组的开头，另外一个指针表示数组的尾部。例子：12345678910int sum_arr(const int *begun,const int *end){const int *pt;int total=0;for(pt=begin;pt!=end;pt++)total=toatl+*pt;return total;}int cookies[ArSize]= {1,2,4,8,16,32,64,128};int sum=sum_arr(cookies,cookies+ArSize); 函数与C风格字符串假设要将字符串（实际传递的是字符串第一字符的地址）作为参数传递给函数，则表示字符串的方式有三种： 1.char数组 2.用隐含阔气的字符串常量 3.被设置为字符串的地址的char指针。 函数和结构涉及函数时，结构变量的行为更接近基于基本的单值变量 1.按值传递–&gt;如果结构非常大，则复制结构将增加内存要求，且使用的是原始变量的副本 2.传递结构的地址，然后使用指针来访问结构的内容 1234567rect rplace;polar pplace;void rect_to_polar(const rect*pxy,polar*pda){...}rect_to_polar(&amp;rplace,&amp;pplace); 调用函数时，将结构的地址（&amp;pplace）而不是结构本身（pplace）传递给它；将形参声明为指向polar的指针，即polar*类型。由于函数不应该修改结构，因此使用了const修饰符，由于形参是指针不是结构，因此应使用姐姐成员运算符(-&gt;)，而不是成员运算符（.）。 3.按引传递用，传指针和传引用效率都高，一般主张是引用传递代码逻辑更加紧凑清晰。 递归—C++函数有一种有趣的特点–可以调用自己（除了main()）1.包含一个递归调用的递归 1234567void recurs(argumentlist){statement1if(test)recurs(arguments)statement2} 如果调用5次recurs就会运行5次statement1，运行1次statement2. 2.包含多个递归调用的递归 12345678void recurs(argumentlist){if(test)return;statement;recurs(argumentlist1);recurs(argumentlist2);} 3.从1加到n 12345678910class Solution{public:int Sum_Solution(int n){int ans=n;ans&amp;&amp;(ans+=Sum_Solution(n-1));return ans;}};//&amp;&amp;就是逻辑与，逻辑与有个短路特点，前面为假，后面不计算。 函数指针函数也有地址—存储其机器语言代码的内存的开始地址 获取函数的地址，只要使用函数名（后面不跟参数）即可。 例如think()是个函数 1234567891011process(think);//传递的是地址thought(think());//传递的是函数返回值//使用double pam(int);//原始函数声明double (*pf)(int);//函数指针声明pf=pam;//使用指针指向pam函数double x=pam(4);//使用函数名调用pam()double y=(*pf)(5);//使用指针调用pam()//也可以这样使用函数指针double y=pf(5); 进阶下面函数原型的特征表和返回类型相同123456789const double *f1(const double ar[],int n);const double *f2(const dopuble [],int );const double *f3(const double *,int );//声明一个指针可以指向f1，f2，f3const double * (*p1)(const double *,int );//返回类型相同，函数的特征标相同//声明并初始化const double * (*p1)(const double *,int )=f1;//也可以使用自动类型推断auto p2=f2; 使用for循环通过指针依次条用每个函数 例子：声明包含三个函数指针的数组，并初始化 const double * (*pa[3])(const double *,int)={f1,f2,f3}; 问：为什么不使用自动类型推断？auto 答：因为自动类型推断只能用于单值初始化，而不能用初始化列表。 但可以声明相同类型的数组 auto pb=pa; 使用： 123456const double *px=pa[0](av.3);//两种表示法都可以const double *py=pb[1](av.3);//创建指向整个数组的指针。由于数组名pa是指向函数指针的指针auto pc=&amp;pa;//c++11//等价于const double * (*(*pd[3]))(const double *,int)=&amp;pa;//C++98 除了auto外，其他简化声明的工具，typedef进行简化点云库里常常用到,如:typedef pcl::PointNormal PointNT 12typedef const double * (*p_fun)(const double *,int );p_fun p1=f1; 函数探幽C++11新特性 函数内联 按引用传递变量 默认参数值 函数重载（多态） 模板函数 内联函数c++内联函数–&gt;提高程序运行速度：常规函数与内联函数的区别在于,C++编译器如何将它们组合到程序中 常规函数调用过程： 执行到函数调用指令程序在函数调用后立即存储该指令地址，并将函数参数复制到堆栈中(为此保留的代码)， 跳到标记起点内存单元， 执行函数代码（也许将返回值放入寄存器中）， 然后跳回地址被保存的指令处。 来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。 情况：函数代码执行时间很短—内联调用就可以节省非内联调用的大部分时间（节省时间绝对值并不大） 代价：需要占用更多的内存：如果程序在是个不同地方调用一个内联函数，则该函数将包含该函数代码的10个副本 使用： 在函数声明前加上关键字inline； 在函数定义前加上关键字inline； 通常的做法是省略原型，将整个定义（即函数头和所有代码），放在本应提供原型的地方。 内联函数不能递归 如果函数占用多行（假设没有冗长的标识符），将其作为内联函数不太合适. 内联与宏C语言使用预处理语句#define来提供宏—内联代码的原始实现 1# define SQUARE(X) X*X 这不是通过传递参数实现的,而是通过文本替换实现的—X是”参数”的符号标记。所以宏不能按值传递 故有时候会出现错误 12c=10;d=SQUARE(C++);is replaced by d=C++*c++=11X12=122 按引用传递变量引用变量–&gt;是复合类型int &amp; rodents =rats;其中int &amp;是类型，该声明允许将rats和rodent互换—他们指向相同的值和内存单元。 必须在声明引用变量时进行初始化 引用更接近const指针(指向const数据的指针)，必须在创建时进行初始化，一旦与某个变量关联起来就一直效忠于它。12345int &amp; rodents=rats;//实际上是下述代码的伪装表示int * const pr=&amp;rats;//引用rodents扮演的角色与*pr相同。//*pr值是个地址，且该地址恒等于&amp;rat--&gt;rats的地址 引用的属性与特别之处应该尽可能使用constC++11新增了另外一种引用—右值引用。这种引用可指向右值，是使用&amp;&amp;声明的：第十八章将讨论如何使用右值引用来实现移动语义（move semantics）,以前的引用（使用&amp;声明的引用）现在称为左值引用 右值引用是对临时对象的一种引用，它是在初始化时完成的，但右值引用不代表引用临时对象后，就不能改变右值引用所引用对象的值，仍然可以初始化后改变临时对象的值 右值短暂，右值只能绑定到临时对象。所引用对象将要销毁或没有其他用户 初始化右值引用一定要用一个右值表达式绑定。 例子： 123double &amp;&amp;rref=std::sqrt(36.00);//在左值引用中不成立，即使用&amp;来实现也是不允许的double j=15.0;double&amp;&amp; jref=2.0*j+18.5;//同样使用左值引用是不能实现的。 将引用用于结构引用非常适合用于结构和类(C++用户定义类型)而不是基本的内置类型。 声明函数原型，在函数中将指向该结构的引用作为参数：void set_pc(free_throws &amp; tf);如果不希望函数修改传入的结构。可使用const；void display(free_throws &amp; tf); 返回引用：free_throws &amp;accumlate(free_throws&amp; traget,free_throws&amp; source);为何要返回引用？如果accumlate()返回一个结构，如：dup=accumlate(team,five) 而不是指向结构的引用。这将把整个结构复制到一个临时位置，再将这个拷贝复制给dup。但在返回值为引用时，直接把team复制到dup，其效率更高，复制两次和复制一次的区别。 应避免返回函数终止时，不在存在的内存单元引用。为避免这种问题，最简单的方法是，返回一个作为参数传递给函数的引用。作为参数的引用指向调用函数使用的数据，因此返回引用也将指向这些数据。 1234567free_throws&amp; accumlate(free_throws&amp; traget,free_throws&amp; source){traget.attempts+=source.attempts;traget.mode+=source.mode;set_pc(target);return target;} 另一种方法是用new来分配新的存储空间 1234567const free_throws&amp; clone(&amp;three){free_throws * pt;//创建无名的free_throws结构，并让指针pt指向该结构，因此*pt就是该结构，在不需要new分配的内存时，应使用delete来释放它们。 //auto_ptr模板以及unique_ptr可帮助程序员自动完成释放* pt=ft；return *pt;//实际上返回的是该结构的引用} 将引用用于对象和结构同理 对象继承和引用使得能够将特性从一个类传递给另外一个类的语言被称为继承 ostream–&gt;基类 ofstream–&gt;派生类 基类引用可以指向派生类对象，而无需强制类型转换 时使用引用参数使用引用参数到主要原因有两个： （1）程序员能够修改调用函数中的数据对象。 （2）通过传递引用而不是整个数据对象，可以提高程序的运行速度。 当数据对象较大时（如结构和类对象），第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于指针的代码的另一个接口。那么什么时候应该使用引用，什么时候应该使用指针呢？什么时候应该按值传递呢？下面是一些指导原则： 对于使用传递到值而不做修改到函数： （1）如果数据对象很小，如内置数据类型或小型结构，则按值传递。 （2）如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。 （3）如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需要的时间和空间。 （4）如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。 对于修改调用函数中数据的函数： （1）如果数据对象是内置数据类型，则使用指针。如果看到诸如fixit(&amp;x)这样的代码（其中x是int），则很明显，该函数将修改x。 （2）如果数据对象是数组，则只能使用指针。 （3）如果数据对象是结构，则使用引用或指针。 （4）如果数据对象是类对象，则使用引用。 当然，这只是一些指导原则，很可能有充分到理由做出其他的选择。例如，对于基本类型，cin使用引用，因此可以使用cin&gt;&gt;n，而不是cin&gt;&gt;&amp;n。 默认参数值—当函数调用中省略了实参时自动使用的一个值如何设置默认值？**必须通过函数原型 char* left(const char* str,int n=1);原型声明 定义长这样 char * left(const char* str,int n){…} 对于带参数列表的函数，必须从左向右添加默认值：下面代码错误，int j应该也设默认值 1int chico(int n,int m=6,int j);//fault 通过默认参数，可以减少要定义的析构函数，方法以及方法重载的数量 函数重载 默认参数让你能够使用不同数目的参数调用的同一个函数。 而函数多态（函数重载）让你能够使用多个同名函数。 仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应用函数重载 C++使用名称修饰（名称矫正）来跟踪每一个重载函数 未经过修饰：long MyFunction(int,float); 名称修饰（内部转换）：?MyFunctionFoo@@YAXH—&gt;将对参数数目和类型进行编码 重载与多态的区别 重载：是指允许存在多个同名方法，而这些方法的参数不同(特征标不同)。重载的实现是：编译器根据方法不同的参数表，对同名方法的名称做修饰，对于编译器而言，这些同名方法就成了不同的方法。他们的调用地址在编译器就绑定了。**重载，是在编译阶段便已确定具体的代码，对同名不同参数的方法调用（静态联编） C++中，子类中若有同名函数则隐藏父类的同名函数，即子类如果有永明函数则不能继承父类的重载。 多态：是指子类重新定义父类的虚方法（virtual,abstract）。当子类重新定义了父类的虚方法后，父类根据赋给它的不同的子类，动态调用属于子类的方法，这样的方法调用在编译期间是无法确定的。（动态联编）。对于多态，只有等到方法调用的那一刻，编译器才会确定所要调用的具体方法。 重载与覆盖的区别 重载要求函数名相同，但是参数列列表必须不不同，返回值可以相同也可以不不同。覆盖要求函数名、参数列列表、返回值必须相同。 在类中重载是同一个类中不同成员函数之间的关系在类中覆盖则是⼦子类和基类之间不同成员函数之间的关系 重载函数的调用是根据参数列表来决定调用哪一个函数 覆盖函数的调用是根据对象类型的不不同决定调用哪一个 在类中对成员函数重载是不不能够实现多态 在子类中对基类虚函数的覆盖可以实现多态 模板函数—通用的函数描述 用于函数参数个数相同的类型不同的情况，如果参数个数不同，则不能那个使用函数模板 函数模板自动完成重载函数的过程。只需要使用泛型和具体算法来定义函数，编译器将为程序使用特定的参数类型生成正确的函数定义 函数模板允许以任意类型的方式来定义函数。例如，可以这样建立一个交换模板 12345678template &lt;typename AnyType&gt;void Swap(AnyType &amp;a,AnyType &amp;a){AnyType temp;temp=a;a=b;b=temp;} 模板不会创建任何函数，而只是告诉编译器如何定义函数 C++98没有关键字typename，使用的是template&lt;class AnyType&gt;void Swap(AnyType &amp;a,AnyType &amp;a){...} 函数模板不能缩短可执行程序，最终仍将由两个独立的函数定义，就像以手工方式定义了这些函数一样。最终的代码不包含任何模板，只包含了为程序生成的实际函。使用模板的寒除湿，它使生成多个函数定义更简单，更可靠更常见的情形是将模板放在头文件中，并在需要使用模板的文件中包含头文件 重载的模板对多个不同类型使用同一种算法（和常规重载一样，被重载的模板的函数特征标必须不同）。 1234template &lt;typename T&gt;void Swap(T&amp; a,T&amp; b);template &lt;typename T&gt;void Swap(T* a,T* b,int n); 模板的局限性：编写的模板很可能无法处理某些类型 如1.T为数组时，a=b不成立；T为结构时a&gt;b不成立 解决方案： C++允许重载运算符，以便能够将其用于特定的结构或类 为特定类型提供具体化的模板定义 显式具体化（explicit specialization）提供一个具体化函数定义，其中包含所需的代码，当编译器找到与函数调用匹配的具体化定义时，将使用该定义，不再寻找模板。 该内容在代码重用中有不再重复。 重载解析(overloading resolution)—编译器选择哪个版本的函数对于函数重载，函数模板和函数模板重载，C++需要一个定义良好的策略，来决定为函数调用哪一个函数定义，尤其是有多个参数时 过程： 创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。 使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式的转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。例如，使用float参数的函数调用可以将该参数转换为double，从而与double形参匹配，而模板可以为float生成一个实例。 确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错。 最佳到最差的顺序： 完全匹配，但常规函数优先于模板 提升转换（例如，char和shorts自动转换为int ,float自动转换为double）。 标准转换（例如，int转换为char,long转换为double）。 用户定义的转换，如类声明中定义的转换。 完全匹配：完全匹配允许的无关紧要转换 从实参到形参 到实参 Type Type &amp; Type &amp; Type Type[] * Type Type(argument-list) Type( * )(argument-list) Type const Type Type volatile Type Type* const Type Type* volatile Type *** # 9内存模型和名称空间（4） 原来的程序分为三个部分 1. 头文件：包含结构声明和使用这些结构的函数的原型//结构声明与函数原型 2. 源代码文件：包含与结构有关的函数代码 //函数 3. 源代码文件：包含调用与结构相关的函数的代码 //调用函数 这种组织方式也与oop方式一致。 一个文件（头文件）包含用户定义类型的定义； 另外一个文件包含操纵用户定义类型的函数代码； 这两个文件组成了一个软件包，可用于各种程序中。 请不要将函数定义或变量声明放在头文件中，如果其他文件都包含这个头文件，那么同一个函数就会有多次定义，变量也同理，会出错。 头文件中常包含的内容： 函数原型。 使用#define或const定义的符号常量（头文件中不可以创建变量） 结构声明=&gt;因为它们不创建变量 模板声明=&gt;模板声明不是将被编译的代码，他们指示编译器如何生成源代码中的函数调用相匹配的函数定义。 内联函数–&gt;只有它可以在头文件定义函数。 被声明为const的数据和内联函数有特殊的链接属性 注意：在IDE中 不要将头文件加入到项目列表中 也不要在源代码文件中使用#include来包含其他源代码文件 在同一文件中只能将同一个头文件包含一次。–&gt;使用预编译指令 1234#ifndef COORDIN_H_...#endif 但是这种方法并不能防止编译器将头文件包含两次，而只是让它忽略第一次包含之外的所有内容。大多数标注C和C++头文件都是用各种防护(guarding)方案。否则，可能在一个文件中定义同一个结构两次，这将导致编译错误。 编译在UNIX系统中编译由多个文件组成的C++程序 编译两个源代码文件的UNIX命令： CC file1.cpp file2.cpp 预处理将包含的文件与源代码文件合并： 临时文件： temp1.cpp temp2.cpp 编译器创建每个源代码文件的目标代码文件：file1.o file2.o 链接程序将目标代码文件(file1.o file2.o)、库代码(Library code)和启动代码(startup code)合并，生成可执行文件：a.out多个库的链接 由不同编译器创建的二进制模块（对象代码文件）很可能无法正确地链接。 原因：两个编译器为同一个函数生成不同的名称修饰 名称的不同将使链接器无法将一个编译器生成的函数调用与另外一个编译器生成的函数定义匹配。在链接编译模块时，请确保所有对象文件或库都是由同一编译器生成的。 链接错误解决的方法：如果有源代码，通常可以用自己的编译器重新编译来消除错误。存储持续性，作用域与和链接性C++中的四种存储方案 自动存储持续性 :在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。 静态存储持续性 :在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态。（请注意）它们在整个运行过程中都存在。 线程存储持续性(C++11) :当前，多核处理器很常见，这些CPU可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_local声明的，则其生命周期与所属的线程一样长。 动态存储持续性 :用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储(free store)或堆(heap)。 作用域和链接性 作用域(scope) 描述了名称在文件的多大范围内可见。例如，函数中定义的变量可在该函数中使用，但不能在其他函数中使用；而在文件中的函数定义之前定义的变量则可在所有函数中使用。 作用域：局部与全局–&gt;(代码块/文件) 作用域为局部的变量只在定义它的代码块中可用。（代码块：由花括号括起的一系列语句，比如：函数体） 做英语为全局（也叫文件作用域）的变量在定义位置到文件结尾都可以用。 链接性(linkage) 描述了名称如何在不同单元间共享。链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享，自动变量的名称没有链接性，因为它们不能共享。 C++内存空间分布1.命令行参数和环境变量 shell在执行程序的时候调用exec函数将命令行参数传递给要执行的程序。 使程序了解进程环境，在执行时分配空间。 2.bss段（Block Start by Symbol） 存放未初始化的全局变量或者静态变量。 3.data段 存放具有明确初始值的全局变量或者静态变量。 存在于程序镜像文件中，由 exec 函数从程序镜像文件中读入内存。 4.text段 CPU执行的机器指令。 堆栈简要概述栈：系统自动开辟空间，自动分配自动回收，在作用域运行完成后（函数返回时）就会被回收。 堆：由程序员自己申请空间，释放空间，不释放会出现内存泄漏。 栈 1.栈是连续的向下扩展的数据结构，总共只有1M或者2M的空间。空间不足就会异常提示栈溢出。 2.存储自动变量, 函数调用者信息, 包括函数参数(可变参数列表的压栈方向是从右向左), 函数内局部变量, 函数返回值, 函数调用时的返回地址。 堆 1.堆是不连续的向上扩展的数据结构，大小受限于计算机系统虚拟内存的大小。 2.操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。 对于大多数系统，会在这块内存空间中的首地址处（一般为一个字节的大小）记录本次分配的大小，这样，代码中的 delete语句才能正确的释放本内存空间。 由于找到的堆结点的空间大小可能大于申请的大小，系统会自动的将多余的那部分（即内存碎片）重新放入空闲链表中。这就涉及到申请效率的问题。 引入名称空间之前下面列出5种变量存储方式（引用名称空间之前） 存储描述 持续性 作用域 链接性 如何声明 自动 自动 代码块 无 在代码块中 寄存器 自动 代码块 无 在代码块中，使用关键字register 静态,无链接性 静态 代码块 无 在代码块中，使用关键字static 静态,外部链接性 静态 文件 外部 不在任何函数内 静态,内部链接性 静态 文件 内部 不在任何函数内，使用关键字static 自动存储持续性 在默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性（自动变量不能共享）。 自动变量的初始化：可以使用任何声明时其值已知的表达式来初始化自动变量int x=5;int y=2*x; 自动变量和栈：自动变量的数目随函数的开始和结束而增减，因此程序必须在运行是对自动变量进行管理。常用方法是流出一段内存，并将其视为栈。程序使用两个指针来跟踪栈，一个指向栈底，栈的开始位置。另外一个指针指向栈顶，下一个可用内存单元。栈是LIFO（后进先出）的，即最后加入到栈中的变量首先被弹出。 寄存器变量–&gt;旨在提高访问变量的速度 关键字register最初由C语言引入的，它建议编译器使用CPU寄存器来存储自动变量 1register int count_fast;//request for a register variable 鉴于关键字register只能用于原来就是自动的变量，使用它的唯一原因是，指出程序员想使用一个自动变量，这个变量名可能与外部变量相同 静态持续变量 C++也为静态存储持续性提供了三种链接性 1.外部链接性（可在其他文件中访问） 2.内部链接性（只能在当前文件中访问） 3.无链接性（只能在当前函数或代码块中访问） 这三种链接性都在整个程序执行期间一直存在，与自动变量相比，他们的寿命更长。由于静态变量的数目在程序运行期间是不变的，因此程序不需要使用特殊的装置（如栈）来管理它们，编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。另外，如果没有显示地初始化静态变量，编译器将把它设置为0。在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0。被称为0初始化 例子：123456789101112int NUM_ZDS_GLOBAL = 80; //#1static int NUM_ZDS_ONEFILE = 50; //#2int main(){…}void fun1(int n){static int nCount = 0; //#3int nNum = 0; //#4}void fun2(int q){ …} #1、#2、#3在整个程序运行期间都存在。在fun1中声明的#3的作用域为局部，没有链接性，这意味着只能在fun1函数中使用它，就像自动变量#4一样。但是，与#4不同的是，即使在fun1没有被执行的时候，#3也保留在内存中。 静态变量初始化 123456#include&lt;cmath&gt;int x; //零初始化 int y=5; //常量表达式初始化long z=13*13; //常量表达式初始化const double pi=4.0*atan(1.0);//动态初始化，要初始化pi，必须调用函数atan()，这需要等到函数被链接上且程序执行时。（这也是常量表达式初始化）//C++新增关键字constexpr，这增加了创建常量表达是的方式 1.静态持续性，外部链接性==&gt;普通全局变量链接性为外部的变量通常称为外部变量，它们的存储持续性为静态，作用域为整个文件。 外部变量是函数外部定义的，因此对所有函数而言都是外部的。 例如，可以在main()前面或头文件中定义他们。可以在文件中位于外部定义后面的任何函数中使用它。 因此外部变量也称为全局变量。 全局变量是在所有函数体的外部定义的，程序的所在部分（甚至其它文件中的代码）都可以使用。全局变量不受作用域的影响（也就是说，全局变量的生命期一直到程序的结束）。如果在一个文件中使用extern关键字来声明另一个文件中存在的全局变量，那么这个文件可以使用这个数据。 单定义规则一方面，在每个使用外部变量的文件中，都必须声明它；另外一方面，C++有“单定义规则”，该规则指出，变量只有一次定义。 为满足这种需求，C++提供了两种变量声明。 一种是定义声明（defining declaration）或简称为定义（definition），它给变量分配存储空间。 一种是引用声明（referencing declaration）或简称为声明（declaration），它不给内存变量分配存储空间。 引用声明使用关键字extern，且不进行初始化；否则，声明未定义，导致分配内存空间：例 123double up;//definition,up is 0 定义extern int bllem;//blem defined elsewhere 声明，blem变量在某处定义了extern char gr = 'z';//definition because initialized 定义 注意： 单定义规则并非意味着不能有多个变量名称相同 如果函数中声明了一个与外部变量同名的变量，结果将如何呢？12345678910111213141516//external1.cpp 文件1double warning=0.3;//warning defined 定义//support.cpp 文件2extern double warning;//use warning from another file 使用外部定义的变量warning......void update(double dt){extern double warning;//optional redeclaration......}void local(){//定义域全局变量名相同的局部变量都，局部变量将隐藏全局变量double warning=0.8;//new variable hides external one......} 通常情况下，应使用局部变量，然而全局变量也有它们的用处。例如，可以让多个函数可以使用同一个数据块（如月份，名数组或原子量数组）。外部存储尤其适用于表示常量数据，因为这样可以使用关键字const来防止数据修改。 2.静态持续性，内部链接性==&gt;Static全局变量 全局变量（外部变量）的说明之前再冠以static就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。 由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。 static全局变量与普通的全局变量的区别是static全局变量只初始化一次，防止在其他文件单元被引用。 3.静态持续性，无链接性==&gt;静态局部变量这种变量是这样创建的，将static限定符用于代码块中定义的变量。 在两次函数调用之间，静态局部变量的值将保持不变，它同时拥有静态变量和局部变量的特性，即： 编译时自动初始化 会被放到静态内存的静态区 只能在局部被访问作用：有时候我们需要在两次调用之间对变量进行保存，通常的想法是定义一个全局变量来实现。但这样一来变量就不属于函数本身了，而受全局变量的控制。静态局部变量正好可以解决这个问题，静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下一次赋新值 说明符和限定符存储说明符(storage class specifier) auto(在C++11中不再是说明符)：在C++11之前，可以在声明中使用关键字auto来指出变量为自动变量；但在C++11中，auto用于自动类型推断。 register：用于在声明中指示寄存器存储，在C++11中，它只是显式地指出变量是自动的。 static:关键字static被用在作用域为整个文件的声明中时，表示内部链接性；被用于局部声明中，表示局部变量的存储持续性为静态的。 thread_local(C++11新增)：可以用static或extern结合使用，关键字thread_local指出变量持续性与其所属的持续性相同。thread_local变量之于线程，由于常规静态变量至于整个程序。 mutable：关键字mutable的含义根据const来解释 mutable:可以用来指出，即使结构（或类）变量为const，其某个成员也可以被修改。 12345678910struct data{char name[30];mutable int accesses;...}const data veep={\"claybourne clodde\",0,...};strcpy(veep.name,\"ytttt\"); //not allowedveep.accessses++; //allowed CV限定符（cv-qualifier） const:它表明，内存被初始化后，程序便不能再对他进行修改。 volatile: volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问 再谈const const限定对默认存储类型稍有影响。在默认情况下，全局变量的链接性为外部的，但const全局变量的链接性为内部的 1234const int fingers = 10;//same as static const init fingers=10;int main(){...} 原因：C++这样子修改了常量类型的规则，让程序员更轻松 假如，假设将一组常量放在头文件中，并在同一程序的多个文件中使用该头文件。那么预处理器将头文件中的内容包含到每个源文件后，所有的源文件都将包含类似下面的定义： 12const int fingers=10;const char* warning =\"wak!\"; 如果全局const声明的链接性像常规变量那样是外部的，则根据单定义规则，这将出错（二义性）。也就是说只能有一个文件可以包含前面的声明，而其他文件必须使用extern关键字来提供引用声明。另外只有未使用extern关键字的生命才能进行初始化。 然而，由于外部定义的const数据的链接性为内部的，因此可以在所有文件中使用相同的声明。 内部链接性意味着每个文件都有自己一组常量，而不是所有文件共享一组常量。每个定义都是其所属文件所私有的，这就是能够将常量定义放在头文件中的原因。 函数和链接性 和C语言一样，C++不允许在一个函数中定义另外一个函数=&gt;因此所有函数的存储持续性都自动为静态的，即整个程序执行期间都一直存在。 在默认情况喜爱，函数的链接性为外部的，即可以在文件间共享。 实际上可以使用extern关键字来指出函数是在另外一个文件中定义的，不过这是可选的。 使用关键字static将函数链接性改为内部链接性，使其只能在本文件中使用，必须在原型和函数定义中同时使用该关键字。 单定义规则也适用于非内联函数，因此对于每个非内联函数，程序只能包含一个定义。对于链接性味外部的函数来说，这意味着在多文件程序中，只能有一个文件包含该函数的定义，但使用该函数的每个文件都应包含其函数原型。 内联函数不受这种规则的约束，这允许程序员能够将内联函数的定义放在头文件中，这样包含了头文件的每个文件都有内联函数的定义。然而，C++要求同一个函数的所有内联定义都必须相同。 C++在哪里寻找函数？假设在程序的某个文件中调用一个函数，C++将到哪里寻找函数定义？ 如果该文件中的函数原型指出该函数是静态的，则编译器将只在该文件中查找函数定义； 否则，编译器（包括链接程序）将在所有文件中查找。 如果在程序文件中找不到，编译器将在库中搜索。这意味着，如果定义了一个与库函数同名的函数，编译器将使用程序员定义的版本，而不是库函数。 语言链接性链接程序要求每个不同的函数都有不同的符号名。在C语言中，一个名词只对应一个函数，因此这很容易实现。为满足内部需要，C语言编译器可能将spiff这样的函数名翻译为_spiff。这种方法称为C语言链接性（C language linkage）。但在C++中，同一个名称可能对应多个函数，必须将这些函数翻译为不同的符号名称。因此，C++编译器执行名称纠正或名称修饰，为重载函数生成不同的符号名称。例如，spiff（int）转换为—_spiff_i，而将spiff(double, double)转换为_spiff_d_d。这种方法称为C++语言的链接性（C++ language linkage）。 如果要在C++程序中使用C语言预编译的函数，将出现什么情况呢？例如，假设有如下代码：spiff(22);它在C库文件中的符号名称为_spiff,但对于我们的C++链接程序来说，C++查询约定是查找符号民称_spiff_i。为解决这样的问题，可以用函数原型来指出要使用何种约定： 123extern “C” void spiff(int);//使用C语言链接性extern void spoff(int);//使用C++语言的链接性(通过默认方式指出)extern “C++” void spaff(int);//使用C++语言的链接性（通过显式指出） C和C++链接性是C++标准制定的说明符，但实现可以提供其他语言链接性说明符。 存储方案和动态分配使用C++运算符new（或C函数malloc()）分配的内存，这种内存被称为动态内存，动态内存由运算符new和delete控制，而不是由作用域和链接性规则控制。因此，可以在一个函数中分配动态内存，而在另外一个函数中将其释放。其分配方式要取决于new和delete在何时以何种方式被使用。通常编译器使用三块独立的内存： 一块用于静态变量（可能再细分） 一块用于自动变量 另外一块用于动态存储 虽然存储方案概念不是用于动态内存，但适用于用来跟踪动态内存的自动和静态指针变量（自动指针变量，静态指针变量），指针变量还是有作用域和链接性的 new运算符如果要为内置的标量类型（int、double）分配存储空间并初始化，可在类型名后面加上初始值，并将其用括号括起。 1int *pi = new int(6); 要初始化常规结构或数组，需要使用大括号的列表初始化，这要求编译器支持C++11。 123struct where{double x, double y, double z};where *one = new where{2.5, 5.3, 7.2};int *ar = new int[4] {2, 4, 7, 6}; 在C++11中，还可将初始化列表用于单值变量： 1int *pin = new int {6}; new失败时 在最初的10年中，C++让new失败时返回空指针，但现在将引发std::bad_alloc异常。new：运算符、函数和替换函数运算符与函数：1234567891011//分配函数（allcation function）；void *operator new(std::size_t);//函数void *operator new[](std::size_t);//函数//释放函数（deallocation function）；void *operator delete(void *);//函数void *operator delete[](void *);//函数int *pi=new int;//运算符int *pi=new(sizeof(int));//函数int *pi=new int[40];//运算符int *pi=new(40*sizeof(int));//函数 替换函数： 有趣的是，C++将这些函数（分配函数，释放函数）称为可替换的（replaceable）。这意味着如果您有足够的知识和意愿，可为new和delete提供替换函数，并根据需要对其进行定制。例如，可定义作用域为类的替换函数，并对其进行定制，以满足该类的内存分配需求。在代码中，仍将使用new运算符，但它将调用您定义的new()函数。 定位new运算符通常，new负责在堆（heap）中找到一个足以能够满足要求的内存块。new运算符还有另一种变体，被称为定位（placement）new运算符，它让您能够指定要使用的位置。程序员可能使用这种特性来设置其内存管理规程、处理需要通过特定地址进行访问的硬件或在特定位置创建对象。 要使用定位new特性，首先需要包含头文件new，它提供了这种版本的new运算符的原型；然后将new运算符用于提供了所需地址的参数。除需要指定参数外，句法与常规new运算符相同。具体地说，使用定位new运算符时，变量后面可以有方括号，也可以没有。下面的代码段演示了new运算符的4种用法： 1234567891011121314#include &lt;new&gt;char buffer1[50];//静态数组char buffer2[500];struct chaff{char dross[20];int slag;};chaff *p1, *p2;int *p3, *p4;p1=new chaff; //place structure in heapp3=new int[20]; //place int array in heapp2=new (buffer1) chaff; //place structure in buffer1p4=new (buffer2) int[20]; //place int array in buffer2 上述代码从buffer1中分配空间给结构chaff，从buffer2中分配空间给一个包含20个元素的int数组。 定位new运算符的其他形式就像常规new调用一个接受一个参数的new函数一样，标准定位new调用一个接收两个参数的new函数。 123int * p1=new int;//调用 new(sizeof(int))int * p2=new(buffer) int;//调用 new(sizeof(int),buffer)int * p3=new(buffer) int[40];//调用new(40*sizeof(int),buffer) 定位new运算符不可替换，但可重载。至少需要接收两个参数，其中第一个总是std::size_t，指定了请求的字节数。这样的重载函数都被定义为new。 名称空间在C++中，名称可以是变量，函数，结构，枚举，类以及类的结构成员 两个概念：声明区域、潜在作用域声明区域(declaration region) 可以在其中进行声明的区域 在函数外面声明全局变量=&gt;对这种变量，其声明区域为其声明所在的文件。对于在函数声明的变量=&gt;其声明区域为其声明所在的代码块。 潜在作用域（potential scope） 变量潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域比声明区域小，这是由于变量必须定义后才能使用。 变量并非在其潜在作用域的任何位置都是可见的。 例如，它可能被另外一个嵌套声明区域中声明的同名变量隐藏 例如，在函数声明的局部变量（对于这种变量，声明区域为整个函数）将隐藏在同一文件中声明的全局变量（对于这种变量，声明区域为整个文件）。 变量对程序而言可见的范围被称为作用域（scope）。新的名称空间(命名的名称空间)即通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会和另一个名称空间中的名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。 关键字namespace 名称空间可以是全局的，也可以位于另一个名称空间中，但是不能位于代码块中。因此在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。 除用户定义的名称空间，还存在另外一个名称空间全局名称空间(global namespace)。它对应文件级声明区域，因此前面所说的全局变量现在被描述为位于全局名称空间中 using 声明和using编译指令 using声明使特定的标识符可用: 1 using std::cout;//将cout添加到它所属的声明区域中，即使得cout能够在main函数中直接使用 using编译指令使整个名称空间可用： 1 using namespace std;//使得std空间中所有的名称都可以直接使用 using编译指令和using声明之比较 使用using声明时，就好像声明了相应的名称一样，如果某个名称已经在函数中声明了，则不能用using声明导入相同的名称。 然而，使用using编译指令时，将进行名称解析，就像在包含using声明和名称空间本身的最小声明区域中声明了名称一样。如果使用using编译指令倒入一个已经在函数中声明的名称，则局部名称将隐藏名称空间名，就像隐藏同名的全局变量一样。 一般来说，使用using声明要比使用using编译指令更加安全，这是由于它只能导入指定的名称，如果该名称与局部名称发生冲突，编译器将发出指示。 using编译指令导入所有的名称，包括可能并不需要的名称，如果与局部名称发生冲突，则局部名称将覆盖名称空间版本而编译器不发出警告！ 另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。所以我们平时自己写程序时先怼一个using namespace std;上去可能并不是一个很好的决定。 10对象和类 类声明：以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述公有接口–&gt;C++程序员将接口（类定义）放在头文件中 类方法定义：描述如何实现成员函数–&gt;并将实现（类方法代码）放在源代码文件中 细节： 使用#ifndef等来访问多次包含同一个文件 将类的首字母大写 控制访问关键字：private public protected C++对结构进行了扩展，使之具有与类相同的特性。他们之间唯一的区别是：结构的默认访问类型是public，类为private 通常，数据成员被放在私有部分中=&gt;数据隐藏；成员函数被放在公有部分中=&gt;公有接口实现类成员方法成员函数两个特殊的特征： 定义类成员函数时。使用作用域解析符（::）来标识函数所属的类； 类方法可以访问类的private组件。 123456789101112131415161718class Stock{ private: char company[30]; int shares; double share_val; double total_val; void set_tot(){total_val = shares * share_val;} public: Stock(); Stock(const char * co , int n = 0 , double pr = 0.0); ~Stock(){} void buy(int num , double price); void sell(int num , double price); void update(double price); void show() const; const Stock &amp; topval(const Stock &amp; s) const;}; set_tot()只是实现代码的一种方式，而不是公有接口的组成部分，因此这个类将其声明为私有成员函数（即编写这个类的人可以使用它，但编写带来来使用这个类的人不能使用）。 内联方法， 其定义位于类声明中的函数都将自动成为内联函数。因此Stock::set_tot()是一个内联函数。 在类声明之外定义内联函数 1234567891011class Stock{private:...void set_tot();public:...};inline void Stock::set_tot(){total_val = shares * share_val;} 内联函数有特殊规则，要求每个使用它们的文件都对其进行定义。确保内联定义对多个文件程序中的所有文件都可用的最简便方法是：将内联定义放在头文件中 如何将类方法应用于对象？（对象，数据和成员函数）所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员。但同一个类的所有对象共享一组类方法，即每种方法只有一个副本。 要使用类，要创建类对象，可以声明类变量，也可以使用new为类对象分配存储空间。 实现了一个使用stock00接口和实现文件的程序后，将其与stock00.cpp一起编译，并确保stock00.h位于当前文件夹中 类成员函数(方法)可通过类对象来调用。为此，需要使用成员运算符句点。 类的构造函数和析构函数构造函数原因：数据部分的访问状态是私有的，这意味着程序不能直接访问数据成员（私有部分数据）。程序只能通过成员函数来访问数据成员，因此需要设计合适的成员函数才能将对象初始化。—类构造函数 声明和定义构造函数12//construtor prototype with some default argumentStock(const string &amp;co,long n=0,double pr=0.0);//原型 原型声明位于类声明的公有部分。 构造函数可能的一种定义 1234567891011121314Stock::Stock(const string &amp;co,long n,double pr){company = co;if(n&gt;0){std::cerr&lt;&lt;\"Number of shares can't be negative;\" &lt;&lt; company &lt;&lt;\" shares set to 0.\\n\"; shares = 0;}elseshares=n;share_val=pr;set_tot();} 注意“参数名co，n，pr不能与类成员相同.构造函数的参数表示不是类成员，而是赋给类成员的值。 区分参数名和类成员：一种常见的做法是在数据成员名中使用m_前缀 string m_company;;另外一种常见的做法是，在成员名中使用后缀_ string company_;使用构造函数 显式调用 1Stock food = Stock1(\"World cabbage\",250,1.25); 隐式调用 123Stock garment(\"Furry Mason\",50,2.5);//等价于Stock garment= Stock(\"Furry Mason\",50,2.5); 每次创建类对象（甚至使用new动态分配内存）时，C++都是用类结构函数。 1Stock *pstock= new Stock(\"Electroshock Games\",18,19.0);//对象没有名称，但可以使用指针来管理对象 默认构造函数未提供显示初始值是，用来创建对象的构造函数。例: 1Stock fluffy_the_cat;//use the default constructor 当且今当没有定义任何构造函数时，编译器才会提供默认构造函数。 为类定义了构造函数后，程序员就必须为它提供默认构造函数 如果提供了非默认构造函数（如Stock(const string &amp;co,long n,double pr);），但没有提供构造函数，下面声明将出错（禁止创建未初始化对象）1Stock stock1; 如何定义默认构造函数：方法1：给已有构造函数函数的所有参数提供默认值 1Stock(const string &amp;co=\"Error\",int n=0,double pr=0.0); 方法2：通过函数重载来定义另外一个构造函数—一个没有参数的构造函数 1Stock(); 为Stock类提供一个默认构造函数： 12345678//隐式初始化所有对象，提供初始值Stock::Stock(){company = \"no name\";shares = 0;share_val = 0.0;total_val = 0.0;} 使用默认构造函数： 123Stock first;//隐式地调用默认的构造函数Stock first = Stock();//显式地Stock * prelief=new Stock;//隐式地 然而不要被废默认构造函数的隐式形式所误导： 123Stock first(\"Concrete Conglomerate\");//调用构造函数Stcok second(); //声明一个函数Stock third； //调用默认构造函数 析构函数 对象过期是，程序将自动调用该特殊的成员函数。析构函数完成清理工作 如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。 什么时候调用析构函数？这由编译器决定，不应在代码中显示地调用析构函数 如果创建的是静态存储类对象，其析构函数将在程序结束时自动被调用。2 .如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时（该对象是在其中定义的）自动被调用。 如果对象是通过new创建的，则它将驻留在栈内存或自由存储区中，当使用delete来释放内存时，其析构函数将自动被调用。程序可以创建临时变量对象来完成特定操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数。 总的来说：类对象过期时（需要被销毁时），析构函数将自动被调用。因此必须有一个析构函数。如果程序员没有提供析构函数，编译器将隐式地声明一个默认构造函数。 C++列表初始化只要提供与某个构造函数的参数列表匹配的内容，并用大括号将它们括起。 123Stock hot_tip = {\"Derivatives Plus Plus\",100 ,45.0};//构造函数Stock jock {\"Sport Age Storage,Inc\"};//构造函数Stock temp{};//默认构造函数 前两个声明中，用大括号括起的列表与下面的构造函数匹配： 1Stock(const string &amp;co,long n=0,double pr=0.0);//原型 因此，用该构造函数来创建这两个对象。创建对象jock时，第二和第三个参数将默认值为0和0.0。第三个声明与默认构造函数匹配，因此将使用该构造函数创建对象temp。 const成员函数1void Stock::show() const;//promises not to change invoking object 以这种方式声明和定义的类成员函数被称为const成员函数。就像应景可能将const引用和指针作函数参数一样，只要类方法不修改调用对象，就应该将其声明为const this指针有的方法可能涉及两个对象，在这种情况下需要使用C++的this指针（比如运算符重载） 提出问题：如何实现：定义一个成员函数，查看两个Stocl对象，并返回股价高的那个对象的引用。 最直接的方法是，返回一个引用，该引用指向股价总值较高的对象，因此，用于比较的方法原型如下：1const Stock &amp; topval(const Stock &amp; s) const;//该函数隐式地访问一个对象，并返回其中一个对象 第一个const：由于返回函数返回两个const对象之一的引用，因此返回类型也应为const引用 第二个const：表明该函数不会修改被显式访问的对象 第三个const：表明该函数不会修改被隐式访问的对象 调用： 1top = stock1.topval(stock2);//隐式访问stock1，显式访问stock2 this 指针用来指向调用成员函数的对象（this被作为隐藏参数传递给方法）。 每个成员函数（包括构造函数和析构函数）都有一个this指针。this指针指向调用对象 如果方法需要引用整个调用对象，可一个使用表达式*this。 实现： 1234567const Stock &amp; topval(const Stock &amp; s) const{if(s.total_val&gt;total_val)return s;elsereturn *this;} 创建对象数组123456Stock stocks[4]={ Stock(\"NanoSmart\",12,20.0), Stock(\"Boffo Objects\",200,2.0), Stock(\"Monolothic Obelisks\",130,3.25), Stock(\"Fleep Enterprises\",60,6.5)}; 类作用域回顾： 全局（文件）作用域，局部（代码块）作用域 可以在全局变量所属的任何地方使用它，而局部变量只能在其所属的代码块中使用。函数名称的作用域也可以是全局的，但不能是局部的。 类作用域 在类中定义的名称（如类数据成员和类成员函数名）的作用域为整个类。 类作用域意味着不能从外部直接访问类成员，公有函数也是如此。也就是说，要用调用公有成员函数，必须通过对象。 使用类成员名时，必须根据上下文使用，直接成员运算符（.），间接成员运算符（-&gt;）或者作用域解析符（::） 作用域为类的常量下面是错误代码 123456class Bakery{private:const int Months=12;//错误代码double cots[Months];} 这是行不通的，因为声明类只是描述了对象的形式，并没有创建对象。因此在创建对象之前，并没有用于存储值的空间。 解决： 方法一：使用枚举123456class Bakery{private:enum{Months=12};double costs[Months];} 这种方式声明枚举并不会创建类数据成员。也就是说，所有对象都不包含枚举。另外，Months只是一个符号名称，在作用域为整个类的代码中遇到他时，编译器将用12来替换它。 方法二：使用关键字static123456class Bakery{private:static const int Months=12；double costs[Months];} 这将创建一个名为Months的常量，该常量与其他静态变量存储在一起，而不是存储在对象中。因此，只有一个Months常量，被所有Bakery对象共享。 作用域内枚举（C++11）传统的枚举存在一些问题，其中之一是两个枚举定义的枚举量可能发生冲突。 12enum egg{Small，Medium,Large，XLarge};enum t_shirt{Small,Medium,Large,Xlarge}; 这将无法通过编译因为egg Small和t_shirt Small位于相同的作用域内，他们将发生冲突。 新枚举12enum class egg{Small，Medium,Large，XLarge};enum class t_shirt{Small,Medium,Large,Xlarge}; 作用域为类后，不同枚举定义的枚举量就不会发生冲突了。 class也可以用关键字struct来代替 使用： 12egg choice = egg::Large;t_shirt Floyd=t_shirt::Large; 注意：作用域内枚举不能隐式地转换为整型，下面代码错误 1int ring = Floyd;//错误 但是必要时可以进行显式转换 1int Floyd = int(t_shirt::Small); 抽象数据类型ADT(Abstract Data Type) 以抽象的方式描述数据类型，而没有引入语言和细节 11使用类运算符重载 运算符重载或函数多态—定义多个名称相同但特征标（参数列表）不同的函数 运算符重载—允许赋予运算符多种含义 运算符函数：operator op(argument-list)示例： 1234567891011//有类方法：Time Sum(const Time &amp;t)const;//定义：Time Time::Sum(const Time &amp; t)const{Time sum;sum.minutes = minutes + t.minutes;sum.hours = hours + t.hours + sum.minutes/60;sum.minutes%=60;retrun sum;} 返回值是函数创建一个新的Time对象（sum），但由于sum对象是局部变量，在函数结束时将被删除，因此引用指向一个不存在的对象，返回类型Time意味着程序将在删除sum之前构造他的拷贝，调用函数将得到该拷贝 运算符重载，只需把上述函数名修改即可Sum()的名称改为operator+()1234567//调用：total=coding.Sum(fixing);//运算符重载后调用1. total=coding.operator+(fixing);2. total=coding+fixing;//t1,t2,t3,t4都是Time对象t4=t1+t2+t3; 重载限制下面是可重载的运算符列表： 运算符 分别 双目算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于) 逻辑运算符 ||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，&amp;(取地址) 自增自减运算符 ++(自增)，–(自减) 位运算符 | (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移) 赋值运算符 =, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，-&gt;(成员访问)，,(逗号)，[](下标) 下面是不可重载的运算符列表： .：成员访问运算符 .*, -&gt;*：成员指针访问运算符 ::：域运算符 sizeof：长度运算符 ?:：条件运算符 重载的运算符(有些例外情况)不必是成员函数,但必须至少有一个操作数是用户定义的类型.这防止用户标准类型重载运算符 使用运算符时不能违反运算符原来的语句法则,例如,不恩那个将秋末运算符(%)重载成一个操作数。 不能创建新的运算符 不能重载下面的运算符 sizeof：sizeof运算符 .：成员运算符 ::：作用域解析运算符 ？:：条件运算符 typeid：一个RTTI运算符 const_cast：强制类型转换运算符 dynamic_cast：强制类型转换运算符 static_cast：强制类型转换运算符 reinterpret_cast：强制类型转换运算符 下面运算符只能通过成员运算符函数进行重载 =：赋值运算符 ()：函数调用运算符 []：下标运算符 -&gt;：通过指针访问类成员的运算符 友元函数C++控制类对象私有部分的访问。通常，公有方法提供唯一的访问途径。 C++提供了另外一种形式的访问权限：友元 友元函数 友元类（15章） 友元成员函数（15章） 友元函数：通过让函数成为类的友元，可以赋予该函数与类成员函数相同的访问权限。 问：为何需要友元？为类重载二元运算符是（带两个参数的运算符）常常需要友元函数。将Time对象乘以实数就属于这种情况之前我们有运算符重载： A = B * 2.75;//Time operator*(double n)const; 如果要实现 A=2.75 * B;//不对应成员函数 cannot correspond to a member function 因为2.75不是TIme类型的对象。左侧炒作书应是调用对象 解决： 告知每个人（包括程序员自己），只能按 B * 2.75这种格式编写。 非成员函数（非成员函数来重载运算符），非成员函数不是由对象调用的，它所使用的所有值（包括对象）都是显式参数。 有函数原型： 1Time operator * (double m,const Time &amp;t); 使用： 1A=2.75 * B;或 A=operator *(2.75,B); 问题：非成员函数不能访问类的私有数据，至少常规非成员函数不能访问 解决：友元函数（非成员函数，但其访问权限与成员函数相同。）创建友元函数 将其原型放在类声明中，并在原型声明前加上关键字friend* 声明：friend Time operator * (double m,const Time &amp; t);。该原型声明意味着下面两点： 虽然，operator* ()函数是在类中声明的，但它不是成员函数，因此不能使用成员运算符来调用； 虽然，operator* ()函数不是成员函数，但它与成员函数的访问权限相同。 定义：不要使用Time::限定符，不要再定义中使用关键字friend 12345678Time operator*(double m,const Time &amp; t){Time result;long totalminutes=t.hours*mult*60+t.minutes*mult;resut.hours = totalminutes/60;result.minutes=totalminutes%60;return result;} 注：不必是友元函数（不访问数据成员也能完成功能) 1234Time operator * (double m,const Time &amp; t){return t*m;//调用了Time operator*(double n)const} 重载&lt;&lt;运算符常用友元：重载座左移运算符 第一种重载版本 使用一个Time成员函数重载&lt;&lt; 1trip&lt;&lt;cout;//（trip是Time对象）这样会让人困惑 通过使用友元函数，可以像下面这样重载运算符： 1234void operator&lt;&lt;(ostream &amp; os,const Time&amp; t){os&lt;&lt;t.hours&lt;&lt;\"hours\"&lt;&lt;t.minutes&lt;&lt;\"minute\";} 该函数成为Time类的一个友元函数（operator&lt;&lt;()直接访问Time对象的私有成员），但不是ostream类的友元（从始至终都将ostream对象作为一个整体来使用）第二种重载版本按照上面的定义，下面语句会出错：1cout&lt;&lt;\"Trip Time:\"&lt;&lt;trip&lt;&lt;\"(Tuesday)\\n\"//不能这么做 应该修改友元函数返回ostream对象的引用即可： 12345ostream&amp; operator&lt;&lt;(ostream &amp; os,const Time&amp; t){os&lt;&lt;t.hours&lt;&lt;\"hours\"&lt;&lt;t.minutes&lt;&lt;\"minute\";return os;} 按照上面的定义，下面可以正常运行： 1cout&lt;&lt;\"Trip Time:\"&lt;&lt;trip&lt;&lt;\"(Tuesday)\\n\"//正常运行 类继承属性让ostream引用能指向ostream对象和ofstream对象12345#include&lt;fstream&gt;ofstram fout;fout.open(\"Savetime.txt\");Time trip(12,40);fout&lt;&lt;trip;//等价于operator&lt;&lt;(fout,trip); 类的自动类型转换和强制转换有构造函数Stonewt(double lbs);可以编写下列代码： 12stonewt mycat;//创建一个对象mycat=19.6；//使用了Stonewt(double lbs)构造函数创意了一个临时对象 上面使用了一个Stonewt(double lbs)构造函数创建了一个临时对象，然后将该对象内容复制到了mycat中，这一过程（19.6利用构造函数变成类对象）需要隐式转换，因为是自动进行的，而不需要显式强制转换。 —&gt;只接受一个参数类型的构造函数定义了从参数类型到类类型的转换 注意：只有接受一个参数的构造函数才能作为转换函数，然而，如果第二个参数提供默认值，它便可用于转换int 1Stonewt(int stn,double lbs=0); explicit这种自动特性并非总是合乎需要的，因为会导致意外的类型转换。 新增关键字explicit，用于关闭这种自动特性，也就是说，可以这样声明构造函数：1234567explicit Stonewt(double lbs);//关闭了上面的隐式转换，但允许显式转换，即显式强制类型转换Stonewt mycat;mycat =19.6;//错误代码mycat = Stonewt(19.6);//这里是调用构造函数mycat =(Stonewt)19.6;//这里是前置类型转换 总结 当构造函数只接受一个参数是，可以使用下面的格式来初始化类对象。1Stonewt incognito=2.75; 这等价于前面介绍过的另外两种格式：(这两种格式可用于接收多个参数的构造函数)Stonewt incognito(2.75);Stonewt incognito = Stonewt(2.75); 下面函数中，Stonewt和Stonewt&amp;形参都与Stonewt实参匹配 12345678void display(const Stonewt &amp; st,int n){for(int=0;i&lt;n;i++){cout&lt;&lt;\"WOW!\";st&gt;show_stn();}} 语句display(422,2);中 编译器先查找自动类型转换中42转Stone的构造函数Stonewt(int) 不存在Stonewt(int)的话，Stonewt(double)构造函数满足这种要求因为，编译器将int转换为double 类的转换函数 构造函数只用于某种类型到类类型的转换，要进行相反的转换，必须用到特殊的C++运算符—转换函数 转换函数必定是类方法 用户定义的强制类型转换，可以向使用强制类型转换那样使用它们。 123Stonewt wolf(285,7);double host = double(wolfe);//格式1double thinker=(double)wolfe;//格式2 也可以让编译器来决定如何做： 12Stonewt wolf(20,3);double star =wells;//隐式转换 创建转换函数opeator typeName(); 转换函数必定是类方法 转换函数不能指定返回类型 转换函数不能有参数 例如：转换函数为double类型的原型如下 1operator double();//不要返回类型也不要参数 如何定义 头文件中声明： 12operator int() const;operator double() const; cpp文件中定义： 123456789Stonewt::opeator int() const{return int (pounds+0.5);//四舍五入}Stonewt::opeator double() const{return pounds;//四舍五入} 二义性C++中，int和double值都可以被赋值给long变量，下面语句被编译器认为有二义性而拒绝了。 1234long gone = poppins;//注：poppins是Stonewt对象//但是还是可以进行强制类型转换long gone = (double)poppins;long gone =int (poppins); 避免隐式转换 方法1：C++98中，关键字explicit不能用于转换函数，但C++11消除了这种限制。因此，在C++11中，可将转换运算符声明为显示的：1234567class Stonewr{...//conversion functionsexplicit operator int() const;explicit operator double() const;}; 有了这些声明后，需要前置转换时，将调用这些运算符。 方法2：用一个功能相同的非转换函数替换转换函数即可，但仅在被显式调用时，该函数才会执行。也就是说，可以将：1Stonewt::operator int(){return int(pounds+0.5);} 替换为 1int Stonewt stone_to_int(){return int(pounds+0.5);} 这样下面语句为非法的： 1int plb=popins; 需要转换时只能调用stone_to_int()： 1int plb =poppins.stone_to_int(); 12类和动态内存分配 动态内存和类 –&gt;让程序运行时决定内存分配，而不是在编译时决定。 —-&gt;使用new和delete运算符来动态控制内存 ——&gt;在类中使用这些运算符将导致许多新的编程问题。这种情况下，析构函数将是必不可少的，而不再是可有可无的。 ——–&gt;有时候还必须重载赋值运算符。 C++为类自动提供了下面这些成员函数 1.默认构造函数，如果没有定义构造函数；记得自己定义了构造函数时，编译器不会再提供默认构造函数，记得自己再定义一个默认构造函数。带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值。 2.默认析构函数，如果没有定义；用于销毁对象 3.复制（拷贝）构造函数，如果没有定义；用于将一个对象赋值到新创建的对象中（将一个对象初始化为另外一个对象）。用于初始化的过程中，而不是常规的赋值过程。 每当程序生成对象副本时（函数按值传递对象，函数返回对象时），编译器都将使用复制构造函数 编译器生成临时对象是，也将使用复制构造函数默认的复制构造函数的功能---&gt;逐个复制非静态成员（成员复制也叫浅复制,给两个对象的成员划上等号），复制的是成员的值；如果成员本身就是类对象，则将使用这个类的复制构造函数复制成员对象,静态成员变量不受影响，因为它们属于整个类，而不是各个对象 浅复制面对指针时会出现错误，在复制构造函数中浅复制的等价于sailor.len=sport.len;sailor.str=sport.str;前一个语句正确，后一个语句错误，因为成员char* str是指针，得到的是指向同一字符串的指针！！！ 当出现动态内存分配时，要定义一个现实复制构造函数—&gt;进行深度复制(deep copy) 123456StringBad::StringBad(const StringBad &amp; st){len=st.len;str=new char[len+1];std::strcpy(str,st.str);} 4.赋值运算符，如果没有定义；赋值运算符只能由类成员函数重载的运算符之一。将已有的对象赋值给另外一个对象时（将一个对象复制给另外一个对象），使用赋值运算符。原型：class_name &amp; class_name::operator==(const class_name &amp;);接受并返回一个指向类对象的引用。 与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制 解决：提供赋值运算符（进行深度复制）定义，其实现业余复制构造函数相似，但有一些差别 123456789101112131415161718192021222324//代码1：先申请内存，再deleteCMyString&amp; CMyString::operator=(const CMyString&amp; str){if(this==str){char *temp_pData=new char[strlen(str.m_pData)+1)];delete[]m_pData;m_pData=temp_pData;strcpy(m_pData,str.m_pData);}return *this;}//代码2：调用复制构造函数CMyString&amp; CMyString::operator=(const CMyString&amp; str){if(this==str){CMyString strTemp(str);//复制构造函数创建临时对象，临时对象失效时会自动调用析构函数char* pTemp=strTemp.m_pData;//创建一个指针指向临时对象的数据成员m_pDatastrTemp.m_pData=m_pData;//交换m_pData=pTemp;//交换}return *this;} 5.地址运算符，如果没有定义； 6.移动构造函数(move construtor)，如果没有定义； 7.移动赋值运算符(move assignment operator)。 静态类成员函数 1.静态函数：静态函数与普通函数不同，它只能在声明它的文件中可以见，不能被其他文件使用。定义静态函数的好处：静态函数不会被其他文件使用。其他文件中可以定义相同名字的函数，不会发生冲突。 2.静态类成员函数:与静态成员数据一样，我们可以创建一个静态成员函数，它为类的全部服务，而不是为某一个类的具体对象服务。静态成员函数与静态成员数据一样，都是在类的内部实现，属于类定义的一部分。普通成员函数一般都隐藏了一个this指针，this指针指向类的对象本身。 3.静态成员函数由于不是与任何对象相联系，因此不具有this指针，从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数静态成员函数总结： 1.出现在类体外的函数不能指定关键字static； 2.静态成员之间可以互相访问，包括静态成员函数访问静态数据成员和访问静态成员函数； 3.非静态成员函数可以任意地访问静态成员函数和静态数据成员； 4.静态成员函数不能访问非静态成员函数和非静态数据成员 5.由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比，速度上会有少许的增长 6.调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指调用静态成员函数。 构造函数中使用new时应注意的事项 1.如果构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。 2.new和delete必须相互兼容，new对应于delete，new[]对应于delete[] 3.如果有多个构造函数，则必须以相同的方式使用new，要么中括号，要么都不带。因为只有一个析构函数，所有的构造函数都必须与它兼容。然而，可以在一个构造函数中使用new来初始化指针，而在另外一个构造函数中初始化为空（0或nullptr），这是因为delete（无论是带括号，还是不带括号）可以用于空指针。 4.应定义一个复制构造函数，通过深度复制将一个对象初始化为另外一个对象。 5.应当定义一个赋值运算符，通过深度复制将一个对象复制给另外一个对象。 有关返回对象的引用 1.首先，返回对象将调用复制构造函数（给新创建的临时对象复制（初始化）），而返回引用不会 2.其次，返回引用指向的对象因该在调用函数执行时存在。 3.返回作为参数输入的常量引用，返回类型必须为const，这样才匹配。 使用指向对象的指针Class_name* ptr = new Class_name;调用默认构造函数 定位new运算符/常规new运算符123456789101112131415161718//使用new运算符创建一个512字节的内存缓冲区char* buffer =new char[512];//地址：(void*)buffer=00320AB0//创建两个指针；JustTesting *pc1,*pc2;//给两个指针赋值pc1=new (buffer)JustTesting;//使用了new定位符，pc1指向的内存在缓冲区 地址：pc1=00320AB0pc2=new JustTesting(\"help\",20);//使用了常规new运算符，pc2指向的内存在堆中//创建两个指针；JustTesting *pc3,*pc4;//给两个指针赋值pc3=new (buffer)JustTesting(\"Bad Idea\",6);//使用了new定位符，pc3指向的内存在缓冲区 地址：pc3=00320AB0//创建时，定位new运算符使用一个新对象覆盖pc1指向的内存单元。//问题1：显然，如果类动态地为其成员分配内存，该内存还没有释放，成员就没了，这将引发问题。pc4=new JustTesting(\"help\",10);//使用了常规new运算符，pc4指向的内存在堆中//释放内存delete pc2；//free heap1delete pc4；//free heap2delete[] buffer//free buffer 解决问题1，代码如下： 12pc1=new (buffer)JustTesting;pc3=new (buffer+sizeof(JustTesting))(\"Bad Idea\",6); 问题2： 将delete用于pc2，pc4时，将自动调用为pc2和pc4指向的对象调用析构函数；问题2：然而，将的delete[]用于buffer时，不会为使用定位new运算符创建的对象调用析构函数 解决问题2：显式调用析构函数 12pc3-&gt;~JustTesting;pc1-&gt;~JustTesting; 嵌套结构和类 在类声明的结构、类或枚举被认为是被嵌套在类中，其作用域为整个类 这种声明不会创建数据对象，而是指定了可以在类中使用的类型。 1.如果声明是在类的私有部分进行的，则只能在这个类中使用被声明的类型。 2.如果声明是在公有部分进行的，则可以从类的外部通过作用域解析运算符使用被声明的类型例如，如果Node是在Queue类的公有部分声明的，则可以在外部声明Queue::Node类型的变量。 默认初始化a.内置类型的变量初始化如果定义变量时没有指定初始值，则变量被默认初始化。默认值由变量类型和定义变量的位置决定。 如果是内置类型的变量未被显示初始化，它的值由定义位置决定。定义于任何函数体外的变量被初始化为0。 12//不在块中int i;//正确，i会被值初始化为0，也称为零初始化 定义于函数体内部的内置类型变量将不被初始化（uninitialized）。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或其他形式的访问此类型将引发错误 123451 {//在一个块中2 int i;//默认初始化，不可直接使用3 int j=0;//值初始化4 j=1;//赋值5 } b.类类型的对象初始化类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数（constructor）。构造函数的任务是初始化类对象的数据成员。由编译器提供的构造函数叫（合成的默认构造函数）。合成的默认构造函数将按照如下规则初始化类的数据成员。 如果存在类内初始值（C++11新特性），用它来初始化成员。 12345678class CC{public: CC() {} ~CC() {}private: int a = 7; // 类内初始化，C++11 可用} 否则，没有初始值的成员将被默认初始化。 成员列表初始化 使用成员初始化列表的构造函数将覆盖相应的类内初始化 对于简单数据成员，使用成员初始化列表和在函数体中使用复制没什么区别 对于本身就是类对象的成员来说，使用成员初始化列表的效率更高 如果Classy是一个类，而mem1，mem2，mem3都是这个类的数据成员，则类构造函数可以使用如下的语法来初始化数据成员。 1234Classy::Classy(int n,intm):mem1(n),mem2(0),men3(n*m+2){//...} 1.这种格式只能用于构造函数 2.必须用这种格式来初始化非静态const数据成员（至少在C++之前是这样的）； 3.必须用这种格式来初始化引用数据成员 数据成员被初始化顺序与它们出现在类声明中的顺序相同，与初始化器中的排列顺序无关 13类继承基类和派生类的特殊关系 1.派生类对象可以使用非私有的基类方法 2.基类指针（引用）可以在不进行显示转换的情况下指向（引用）派生类对象（反过来不行）；基类指针或引用只能用来调用基类方法，不能用来调用派生类方法。 3.不可以将基类对象和地址赋给派生类对象引用和指针。 派生类构造函数要点1.首先创建基类对象；2.派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数。3.派生类构造函数应初始化新增的数据成员。注意：可以通过初始化列表语法知名指明要使用的基类构造函数，否则使用默认的基类构造函数。派生类对象过期时，程序将首先调用派生类的析构函数，然后在调用基类的析构函数。 1234RetedPlayer::RetedPlayer(unsigned int r,const string &amp; fn,const string &amp;ln, bool ht)//:TableTennisPlayer()等价于调用默认构造函数{rating = r;} 虚方法 经常在基类中将派生类会重新定义的方法声明为虚方法。方法在基类中被声明为虚的后。它在派生类中将自动生成虚方法。然而，在派生类中使用关键字virtual来指出哪些函数是虚函数也不失为一个好方法。 如果要在派生类中重新定义基类的方法，通常将基类方法声明为虚。这样，程序根据对象类型而不是引用或指针类型来选择方法版本，为基类声明一个虚的析构函数也是一种惯例，为了确保释放派生类对象时，按正确的顺序调用析构函数。 虚函数的作用：基类指针（引用）指向（引用）派生类对象，会发生自动向上类型转换，即派生类升级为父类，虽然子类转换成了它的父类型，但却可正确调用属于子类而不属于父类的成员函数。这是虚函数的功劳。 派生类方法可以调用公有的基类方法在派生类方法中，标准技术是使用作用域解析运算符来调用基类方法，如果没有使用作用域解析符，有可能创建一个不会终止的递归函数。如果派生类没有重新定义基类方法，那么代码不必对该方法是用作用域解析符（即该方法只有在基类中有）。 静态联编和动态联编函数名联编（binding）：将代码中的函数调用解释为执行特定的代码块。 在C语言中，这非常简单，因为每个函数名都对应一个不同的函数。 在C++中，由于函数重载的缘故，这个任务更繁杂，编译器必须查看函数参数以及函数名才能确定使用哪个函数。 静态联编(static binding) 在编译过程中进行联编，又称为早期联编 动态联编(dynamic binding) 编译器在程序运行时确定将要调用的函数，又称为晚期联编什么时候使用静态联编，什么时候使用动态联编？ 编译器对虚方法使用静态联编，因为方法是非虚的，可以根据指针类型关联到方法。 编译器对虚方法使用动态联编，因为方法是虚的，程序运行时才知道指针指向的对象类型，才来选择方法。（引用同理）效率：为使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针和指向引用对象的对象类型，这增加了额外的处理开销 例如，如果类不会用作基类，则不需要动态联编。 同样，如果派生类不重新定义基类的任何方法，也不需要动态联编。 通常，编译器处理函数的方法是：给每个对象添加一个隐藏成员–指向函数地址数组的指针(vptr) 使用虚函数时，在内存和执行速度上有一定的成本，包括：a.每个对象为存储地址的空间；b.对于每个类，比那一期都将创建一个虚函数地址表（数组）vtbl；c.对于每个函数调用，都需要执行一项额外的操作，到表中查找地址。虽然非虚函数的效率比虚函数稍高，但不具有动态联编的功能 总结： 在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类（包括从派生类派生出来的类）中是虚的。 如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不是用为引用或者指针类型定义的方法。这个成为动态联编或者晚期联编。这种行为非常重要。因为这样基类指针或引用可以指向派生类对象。 如果定义的类将被用作基类，则应该将那些在派生类中重新定义的类方法生命为虚的。 虚函数细节 1.构造函数不能是虚函数，派生类不能继承基类的构造函数，将类构造函数声明为虚没什么意义。 2.析构函数应当是虚函数，除非类不用作基类。 1.当子类指针指向子类是，析构函数会先调用子类析构再调用父类析构，释放所有内存。2.当父类指针指向子类时，只会调用父类析构函数，子类析构函数不会被调用，会造成内存泄漏。（基类析构函数声明为虚，可以使得父类指针能够调用子类虚的析构函数）所以我们需要虚析构函数，将父类的析构函数定位为虚，那么父类指针会先调用子类的析构函数，再调用父类析构，使得内存得到释放。 3.友元不能是虚函数，因为友元不是类成员，只有类成员才是虚函数。 4.如果派生类没有重新定义函数。将使用该函数的基类版本。 5.重新定义将隐藏方法不会生成函数的两个重载版本，而是隐藏基类版本。如果派生类位于派生链中，则使用最新的虚函数版本，例外的情况是基类版本是隐藏的。总之，重新定义基本的方法并不是重载。如果重新定义派生类中的函数，将不只是使用相同的函数参数列表覆盖其基类声明，无论参数列表是否相同，该操作将隐藏所有的同名方法。 两条经验规则 1.如果重新定义继承的方法，应确保与原来的原型完全相同，但是如果返回类型是积累的引用或指针，则可以修改为指向派生类的引用或指针（只适用于返回值而不适用于参数），这种例外是新出现的。这种特性被称为返回类型协变（convariance of return type），因此返回类型是随类类型变化的。 123456789101112//基类class Dwelling{public:virtual Dwelling &amp; build(int n);}//派生类class Hovel:public Dwelling{public:virtual Hovel &amp; build(int n);} 2.如果基类声明被重载了，则应该在派生类中重新定义所有基类版本。 123456789101112131415161718//基类class Dwelling{public://三个重载版本的showperksvirtual void showperks（int a）const；virtual void showperks（double a）const；virtual void showperks（ ）const；}//派生类class Hovel:public Dwelling{public://三个重新定义的的showperksvirtual void showperks（int a）const；virtual void showperks（double a）const；virtual void showperks（ ）const；} 如果只重新定义一个版本，则另外两个版本将被隐藏，派生类对象将无法使用它们，注意，如果不需要修改，则新定义可知调用基类版本： 1234void Hovel::showperk()const{Dwelling::showperks();} 访问控制：protected 1.关键字protected与private相似，在类外，只能用公有类成员来访问protected部分中的类成员。 2.private和protected之间只有在基类派生的类才会表现出来。派生类的成员可以直接访问基类的保护成员，但是不能直接访问基类的私有成员。提示： 1.最好对类的数据成员采用私有访问控制，不要使用保护访问控制。 2.对于成员函数来说，保护访问控制很有用，它让派生类能够访问公众不能使用的内部函数。 抽象基类（abstract base class）ABC-&gt;至少包含一个纯虚函数 在一个虚函数的声明语句的分号前加上 =0 ；就可以将一个虚函数变成纯虚函数，其中，=0只能出现在类内部的虚函数声明语句处。 纯虚函数只用声明，而不用定义，其存在就是为了提供接口，含有纯虚函数的类是抽象基类。我们不能直接创建一个抽象基类的对象，但可以创建其指针或者引用。 值得注意的是，你也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。但此时哪怕在外部定义了，也是纯虚函数，不能构建对象。 派生类构造函数只直接初始化它的直接基类。多继承的虚继承除外。 抽象类应该注意的地方 抽象类不能实例化，所以抽象类中不能有构造函数。 纯虚函数应该在派生类中重写，否则派生类也是抽象类，不能实例化。 抽象基类的作用 C++通过使用纯虚函数（pure virtual function）提供未实现的函数。纯虚函数声明的结尾处为=0， 1virtual double Area() const=0;//=0指出类是一个抽象基类，在类中可以不定义该函数 可以将ABC看作是一种必须的接口。ABC要求具体派生类覆盖其纯虚函数—迫使派生类遵顼ABC设置的接口规则。简单来说是：因为在派生类中必须重写纯虚函数，否则不能实例化该派生类。所以，派生类中必定会有重新定义的该函数的接口。 从两个类(具体类concrete)（如：Ellipse和Circle类）中抽象出他们的共性，将这些特性放到一个ABC中。然后从该ABC派生出的Ellipse和Circle类。 这样，便可以使用基类指针数组同时管理Ellipse和Circle对象，即可以使用多态方法* 友元 就像友元关系不能传递一样，友元关系同样不能继承，基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。 继承和动态内存分配(todo) 只有当一个类被用来做基类的时候才会把析构函数写成虚函数。 当基类和派生类都采用动态内存分配是，派生类的析构函数，复制构造函数，赋值运算符都必须使用相应的基类方法来处理基类 14C++中的代码重用（公有继承，包含对象的类，私有继承，多重继承，类模板）包含（containment）：包含对象成员的类本身是另外一个类的对象。这种方法称为包含（containment），组合（composition），或层次化（laying） 私有继承（还是has-a关系）基类的公有成员和保护成员都将成为派生类的私有成员。和公有继承一样，基类的私有成员是会被派生类继承但是不能被派生类访问。基类方法将不会成为派生类对象公有接口的一部分，但可以在派生类中使用它们。 1.初始化基类组件 和包含不同，对于继承类的新版本的构造函数将使用成员初始化列表语法，它使用类名（std::string，std::valarry）而不是成员名来表示构造函数 1234567891011121314//Student类私有继承两个类派生而来,本来包含的时候两个基类分别是name和scoreclass Student:private std::string,private std::valarry&lt;double&gt;{public:......};//如果是包含的构造函数Student(const char *str,const double *pd,int n):name(str),score(pd,n){}//继承类的构造函数 Student(const char *str,const double *pd,int n):std::string(str),std::valarry&lt;double&gt;(pd,n){} 2.访问基类的方法 a.包含书用对象（对象名）来调用方法 b.私有继承时，将使用类名和作用域解析运算符来调用方法 1234567double Student::Average() const{if(ArrayDb::size()&gt;0）//ArrayDb typedef为std::valarry&lt;double&gt; return ArrayDb::sum()/ArrayDb::size();else return 0;} 3.访问基类对象 使用私有继承时，该string对象没有名称。那么，student类的代码如何访问内部string对象呢？ 强制类型转换! 本来子到父自动类型提升,不需要强制类型转换。父到子才需要强制类型转换。但是下面是强制类型转换，原因在第4点那里写着。 由于Student类是从string类派生而来的，因此可以通过强制类型转换，将Student对象转换为S=string对象 123456//成员方法：打印出学生的名字//因为不是包含，只能通过强制类型转换const string &amp; Student::Name()const{retrun (const string &amp;) *this;} 4.访问基类友的元函数 用类名显式地限定函数名不适合友元函数，因为友元不属于类。不能通过这种方法访问基类。 解决：通过显示地转换为基类来调用正确的函数 1234osstream &amp; operator&lt;&lt;(ostream &amp; os,const Student &amp; stu){os &lt;&lt; \"Score for \"&lt;&lt;(const String &amp;) stu &lt;&lt;\":\\n\";//显式地将stu转换为string对象引用，进而调用基类方法} 引用不会自动转换为string引用原因： a.在私有继承中，未进行显示类型转换的派生类引用或指针，无法赋值给基类的引用或指针。 b.即使这个例子使用的是公有继承，也必须使用显示类型转换。原因之一是，如果不使用类型转换，下述代码将无法与函数原型匹配从而导致递归调用，os&lt;&lt;stu c.由于这个类使用的是多重继承，编译器将无法确定应转换成哪个基类，如果两个基类都提供函数operator&lt;&lt;()。 5.使用包含还是私有继承？通常，应使用包含来建立has-a关系；如果新需要访问原有的保护成员，或重新定义虚函数，则应使用私有继承。 6.保护继承 基类的公有成员和保护成员都将成为派生类的保护成员。 共同点：和私有继承一样，基类的接口在派生类中也是可用的，但在继承和结构之外是不可用的。 区别：使用私有继承时，第三代类将不能使用基类的接口，这是因为公有方法在派生类中将变成私有方法；使用保护继承时，基类的公有方法在第二代将变成保护的，因此第三代派生类可以使用它们。 特征 公有继承 保护继承 私有继承 公有成员变成 派生类的公有成员 派生类的保护成员 派生类的私有成员 保护成员变成 派生类的保护成员 派生类的保护成员 派生类的私有成员 私有成员变成 只能通过基类接口访问 只能通过基类接口访问 只能通过基类接口访问 能否隐式向上转换 是 是（但只能在派生类中） 否 7.使用using重新定义访问权限使用派生或私有派生时，基类的公有成员将成为保护成员或私有成员，假设要让基类方法在派生类外面可用 方法1，定义一个使用该基类方法的派生类方法 1234double Student::sum() const{return std::valarray&lt;double&gt;::sum();} 方法2，将函数调用包装在另外一个函数调用中，即使用一个using声明（就像空间名称一样） 1234567class Student::private std::string,private std::valarray&lt;double&gt;{...public: using std::valarray&lt;double&gt;::min; using std::valarray&lt;double&gt;::max;} //using声明只适用于继承，而不适用于包含//using声明只使用成员名—没有圆括号，函数特征表和返回类型 多重继承必须使用关键字public来限定每一个基类，这是因为，除非特别指出，否则编译器将认为是私有派生。（class 默认访问类型是私有，strcut默认访问类型是公有） 多重继承带来的两个主要问题： 1.从两个不同的基类继承同名方法。 2.从两个或更多相关的基类那里继承同一个类的多个实例。 123class Singer:public Worker{...};class Waiter:public Worker{...};class SingerWaiter:public Singer,public Waiter{...}; Singer和Waiter都继承一个Worker组件，因此SingerWaiter将包含两份Worker的拷贝–&gt;通常可以将派生来对象的地址赋给基类指针，但是现在将出现二义性。（基类指针调用基类方法时不知道调用哪个基类方法），第二个问题：比如worker类中有一个对象成员，那么就会出现 虚基类（virtual base class） 虚基类使得从多个类（他们的基类相同）派生出的对象只继承一个基类对象。1234class Singer:virtual public Worker{...};//virtual可以和public调换位置class Waiter:public virtual Worker{...;//然后将SingingWaiter定义为class SingingWaiter：public Singer,public Waiter{...}; 现在,SingingWaiter对象只包含Worker对象的一个副本 为什么不抛弃将基类声明为虚的这种方式，使虚行为成为MI的准则呢？（为什么不讲虚行为设为默认，而要手动设置） 第一，一些情况下，可能需要基类的多个拷贝； 第二，将基类作为虚的要求程序完成额外的计算，为不需要的工具付出代价是不应当的； 第三，这样做是有缺点的，为了使虚基类能够工作，需要对C++规则进行调整，必须以不同的方式编写一些代码。另外，使用虚基类还可能需要修改已有的代码 虚基类的构造函数（需要修改） 对于非虚基类，唯一可以出现在初始化列表的构造函数是即是基类构造函数。 对于虚基类，需要对类构造函数采用一种新的方法。 基类是虚的时候,禁止信息通过中间类自动传递给基类,因此向下面构造函数将初始化成员panache和voice，但wk参数中的信息将不会传递给子对象Waiter。然而，编译器必须在构造派生对象之前构造基类对象组件；在下面情况下，编译器将使用Worker的默认构造函数（即类型为Worker的参数没有用！而且调用了Worker的默认构造函数） 1SingingWaiter(const Worker &amp;wk,int p=0;int v=Singer:other):Waiter(wk,p),Singer(wk,v){}//flawed 如果不希望默认构造函数来构造虚基类对象，则需要显式地调用所需的基类构造函数。 1SingingWaiter(const Worker &amp;wk,int p=0;int v=Singer:other):Worker(wk),Waiter(wk,p),Singer(wk,v){} 上述代码将显式地调用构造函数worker(const Worker&amp;)。请注意，这种调用是合法的，对于虚基类，必须这样做；但对于非虚基类，则是非法的。 有关MI的问题 多重继承可能导致函数调用的二义性。 假如每个祖先（Singer，waiter）都有Show()函数。那么如何调用 1.可以使用作用域解析符来澄清编程者的意图： 12SingingWaiter newhire(\"Elise Hawks\",2005,6,soprano);newhire.Singer::Show();//using Singer Version 2.然而，更好的方法是在SingingWaiter中重新定义Show(),并指出要使用哪个show。 1P559～P560 1.混合使用虚基类和非虚基类 如果基类是虚基类，派生类将包含基类的一个子对象； 如果基类不是虚基类，派生类将包含多个子对象 当虚基类和非虚基类混合是，情况将如何呢？123456//有下面情况class C:virtual public B{...};//B为虚基类class D:virtual public B{...};//B为虚基类class X: public B{...}; //B为非虚基类class Y: public B{...}; //B为非虚基类class M:public C,public D,public X,public Y{...}; 这种情况下，类M从虚派生祖先C和D那里共继承了一个B类子对象，并从每一个非虚派生祖先X和Y分别继承了一个B类子对象。因此它(M)包含三个B类子对象。 当类通过多条虚途径和非虚途径继承了某个特定的基类时，该类包含一个表示所有的虚途径的基类子对象和分别表示各条非虚途径的多个基类子对象。(本例子中是1+2=3) 2.虚基类和支配(使用虚基类将改变C++解释二义性的方式) 使用非虚基类是，规则很简单，如果类从不同的类那里继承了两个或更多的同名函数（数据或方法），则使用该成员名是，如果没有用类名进行限定，将导致二义性。 但如果使用的是虚基类，则这样做不一定会导致二义性。这种情况下，如果某个名称优先于（dominates）其他所有名称，则使用它时，即使不使用限定符，也不会导致二义性。12345678910111213141516171819202122232425262728293031class B{public:short q();...};class C:virtual public B{public:long q();int omg();...};class D:public C{...}class E:virtual public B{private:int omg();...};class F: public D,public E{...}; 1.类C中的q()定义优先于类B中的q()定义，因为类C是从类B派生而来的。因此F中的方法可以使用q()来表示C::q().（父子类之间有优先级，子类大于父类） 2.任何一个omg()定义都不优先于其他omg()定义，因为C和E都不是对方的基类。所以，在F中使用非限定的omg()将导致二义性。 3.虚二义性规则与访问规则（pravite,public,protected）无关，也就是说即使E::omg是私有的，不能在F类中直接访问，但使用omg()仍将导致二义性。 类模板类模板 类模板和模板函数都是以template开头（当然也可以使用class），后跟类型参数；类型参数不能为空，多个类型参数用逗号隔开。 1234template &lt;typename 类型参数1，typename 类型参数2，typename 类型参数3&gt;class 类名{//TODO} 类模板中定义的类型参数可以用在函数声明和函数定义中， 类模板中定义的类型参数可以用在类型类声明和类实现中， 类模板的目的同样是将数据的类型参数化。 12345678910111213141516template &lt;class Type&gt;class Stack{private: enum {MAX=10}; Type items[MAX]; int top;public: Stack(); ……}template &lt;class Type&gt;Stack&lt;Type&gt;::Stack(){ top=0;} Type:泛型标识符，这里的type被称为类型参数。这意味着它们类似于变量，但赋给它们的不是数字，而只能是类型 相比于函数模板，类模板必须显式的提供所需的类型。 模板不是函数，它们不能单独编译。模板必须与特定的模板实例化(instantiation)请求一起使用,为此，最简单的方法是将所有模板信息放在一个文件中，并在要使用这些模板的文件中包含该头文件。 123//类声明Stack&lt;int&gt;将使用int替换模板中所有的TypeStack&lt;int&gt;kernels;Stack&lt;string&gt;colonels; 深入探讨模板模板具体化（instantiation）和实例化（specialization） 模板以泛型的方式描述类，而具体化是使用具体的类型生成类声明。 类模板具体化生成类声明 类实例化生成类对象 1.隐式实例化(implicit instantiation)他们声明一个或多个对象，指出所需的类型，而编译器使用通用模板提供的处方生成具体的类定义； 12345Array&lt;int,100&gt;stuff;//隐式实例化//在编译器处理对象之间，不会生成隐式实例化，如下Array&lt;double,30&gt;*pt;//a pointer,no object needed yet//下面语句导致编译器生成类定义，并根据该定义创建一个对象昂pt=new Array&lt;double,30&gt;; 2.显式实例化(explicit instantiation) 当使用关键字template并指出所需类型来声明类时，编译器将生成类声明的实例化 1template class ArrayTP&lt;string,100&gt;; 这种情况下，虽然没有指出创建或提及类对象，编译器也将生成类声明（包含方法定义）。和隐式实例化也将根据通用模板来生成具体化。 3.显式具体化(explicit specialization)—是特定类型（用于替换模板中的泛型）的定义格式：template&lt;&gt;class Classname{…};有时候，可能需要在特殊类型实例化是，对模板进行修改，使其行为不同。在这种情况下，可以创建显式实例化。 12345//原来的类模板template &lt;typename T&gt;class sortedArray{...//details omitted}; 当具体化模板和通用模板都与实例化请求匹配时，编译器将使用具体化版本。 12345//新的表示法提供一个专供const char*类型使用的SortedArray模板template&lt;&gt;class SortedArray&lt;const char*&gt;{...//details omitted}; 4.部分具体化(partical specialization) 部分限制模板的通用性 1234//general template 一般模板 template&lt;class T1,class T2&gt;class Pair{...};//specialization with T2 set to int部分具体化 template&lt;class T1&gt;class Pair&lt;T1,int&gt;{...}; 如果有多个模板可供选择，编译器将使用具体化程度最高的模板 123Pair&lt;double,double&gt;p1;//使用了一般的Pair类模板Pair&lt;double,int&gt;p2;//使用了部分具体化Pair&lt;T1,int&gt;Pair&lt;int,int&gt;p3//使用了显式实例化Pair&lt;int,int&gt; 也可以通过为指针提供特殊版本来部分具体化现有模板： 1234template&lt;class T&gt;class Feen{...};//一般版本的类模板template&lt;class T*&gt;class Feen{...};//部分具体化 将模板用作参数template&lt;template&lt;typename T&gt;class Thing&gt;class Crab 模板类和友元 模板类声明也可以有友元。模板的友元分为3类： 非模板友元： 约束(bound)模板友元，即友元的类型取决于类被实例化时的类型； 非约束(unbund)模板友元，即友元的所有具体化都是类的每一个具体化的友元。 模板类的非模板友元函数 在模板类中奖一个常规函数声明为友元：1234567template &lt;class T&gt;class HasFriend{public:friend void counts();...}; 上述声明指定counts()函数称为模板所有实例化的友元 counts()函数不是通过对象调用（它是友元不是成员函数），也没有对象参数，那么如何访问HasFriend对象？ 1.它可以访问全局对象 2.它可以使用全局指针访问非全局对象 3.可以创建自己的对象 4.可以访问独立于对象的模板类的静态成员函数 模板类的约束模板友元 1.首先，在类定义的前面声明每个模板函数 templatevoid counts();templatevoid report(T &amp;); 2.然后，在函数中再次将模板声明为友元。这些语句根据类模板参数的类型声明 1234567template&lt;typename TT&gt;class HasFriendT{...friend coid counts&lt;TT&gt;();friend coid report&lt;&gt;(HasFriendT&lt;TT&gt; &amp;);}; 3.为友元提供模板定义 模板类的非约束模板友元函数 前一节中的约束模板友元函数在类外面声明的模板的具体化。int类具体化获得int函数具体化，依此类推。通过类内部声明模板，可以创建非约束友元函数，即每个函数具体化都是每个类具体化的友元。对于非约束友元，友元模板类型参数与模板类类型参数是不同的：123456template&lt;typename T&gt;class ManyFriend{...template&lt;typename C,typename D&gt;friend void show2(C &amp;,D &amp;);}; 模板别名(C++11) 1.如果能为类型指定别名，浙江爱你个很方便，在模板设计中尤为如此。可使用typedef为模板具体化指定别名 1234567typedef std::array&lt;double,12&gt; arrd;typedef std::array&lt;int,12&gt; arri;typedef std::array&lt;std::string,12&gt; arrst;//使用arrd gallones；arri days;arrst months; 2.C++11新增了一项功能—使用模板提供一系列别名 12template&lt;typename T&gt;using arrtype=std::array&lt;T,12&gt;;//template aliases 这将arrtype定义为一个模板别名，可以用它来指定类型 123arrtype&lt;double&gt; gallones;arrtype&lt;int&gt; days;arrtype&lt;std::string&gt; months; C++11允许将语法using=用于非模板。用于非模板是，这种语法与常规typedef等价：12typedef const char *pc1; //typedef syntax/ 常规typedef语法using pc2=const char*; //using = syntax/ using =语法 可变参数模板(variadic template)18章 15友元、异常和其他友元类例子：模拟电视机和遥控器的简单程序 公有继承is-a关系并不适用。遥控器可以改变电视机的状态，这表明应将Remove类作为TV类的一个友元 友元声明 friend class Remote；—&gt;友元声明可以位于公有、私有或保护部分，其所在的位置无关紧要。该声明让整个类成为友元并不需要前向（实现）声明，因为友元语句本身已经指出Remote是一个类。 友元Remove可以使用TV类的所有成员 大多类方法都被定义为内联。代码中，除构造函数外，所有Remove方法都将一个TV对象引用作为参数，这表明遥控器必须针对特定的电视机 同一个遥控器可以控制不同的电视机 12345TV S42；TV S58(TV::ON);Remote grey;grey.set_chan(S42,10);grey.set_chan(S58,28); 友元成员函数 某一个类的成员函数作为另外一个类的友元函数 例子：将TV成员中Remote方法Remote::set_chan()，成为另外一个类的成员 12345class TV{friend void Remote::set_chan(TV&amp; t,int c);...}; 问题1：在编译器在TV类声明中看到Remote的一个方法被声明为TV类的友元之前，应先看到Remote类的声明和set_chan()方法的声明。 1234//排列次序应如下：class TV;//forward declarationclass Remote{...};class TV{...}; 问题2：Remote声明包含内联代码，例如：void onoff(TV &amp; t){t.onoff();}由于这将调用TV的一个方法，所以编译器此时必须看到一个TV的类声明，解决：使Remote声明中只包含方法声明，并将实际的定义放在TV类之后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt; class B{public : B() { myValue=2; std::cout&lt;&lt;\"B init\"&lt;&lt;std::endl; } ~B() { std::cout&lt;&lt;\"B end\"&lt;&lt;std::endl; } //这样做可以 /*B operator+(const B av) { B a; a.myValue=myValue+av.myValue; return a; }*/ //也可以这么做 friend B operator+(const B b1,const B b2); //------------------------------------------------ int GetMyValue() { return myValue; } //重载&lt;&lt; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os,B);private : int myValue;};B operator+(const B b1,const B b2){ B a; a.myValue=b1.myValue+b2.myValue; return a;}std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os,B b){ return os&lt;&lt;\"重载实现：\"&lt;&lt;b.myValue&lt;&lt;std::endl;}int main(){ B b1; std::cout&lt;&lt;b1; B b2; B b3=b1+b2; std::cout&lt;&lt;b3&lt;&lt;std::endl; std::cin.get(); return 0;} 内联函数的链接性是内部的，这意味着函数定义必须在使用函数的文件中，这个例子中内联定义位于头文件中，因此在使用函数的文件中包含头文件可确保将定义放在正确的地方。这可以将定义放在实现文件中，但必须删除关键字inline这样函数的链接性将是外部的 嵌套类 在另外一个类中声明的类被称为嵌套类（nested class） 包含类的成员函数可以创建和使用被嵌套的对象。而仅当声明位于公有部分，才能在包含类外面使用嵌套类，而且必须使用作用域解析运算符 访问权限：嵌套类、结构和美剧的作用域特征（三者相同） 声明位置 包含它的类是否可以使用它 从包含它的类派生而来的类是否可以使用它 在外部是否可以使用 私有部分 是 否 否 保护部分 是 是 否 公有部分 是 是 是，可以通过类限定符来使用 * 访问控制 1.类声明的位置决定了类的作用域或可见性 2.类可见后，访问控制规则（公有，保护，私有，友元）将决定程序对嵌套类成员的访问权限。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//在下面的程序中，我们创建了一个模板类用于实现Queue容器的部分功能，并且在模板类中潜逃使用了一个Node类。// queuetp.h -- queue template with a nested class#ifndef QUEUETP_H_#define QUEUETP_H_template &lt;class Item&gt;class QueueTP{private: enum {Q_SIZE = 10}; // Node is a nested class definition class Node { public: Item item; Node * next; Node(const Item &amp; i) : item(i), next(0) {} }; Node * front; // pointer to front of Queue Node * rear; // pointer to rear of Queue int items; // current number of items in Queue const int qsize; // maximum number of items in Queue QueueTP(const QueueTP &amp; q) : qsize(0) {} QueueTP &amp; operator=(const QueueTP &amp; q) { return *this; }public: QueueTP(int qs = Q_SIZE); ~QueueTP(); bool isempty() const { return items == 0; } bool isfull() const { return items == qsize; } int queuecount() const { return items; } bool enqueue(const Item &amp;item); // add item to end bool dequeue(Item &amp;item); // remove item from front};// QueueTP methodstemplate &lt;class Item&gt;QueueTP&lt;Item&gt;::QueueTP(int qs) : qsize(qs){ front = rear = 0; items = 0;}template &lt;class Item&gt;QueueTP&lt;Item&gt;::~QueueTP(){ Node * temp; while (front != 0) // while queue is not yet empty { temp = front; front = front-&gt;next; delete temp; }}// Add item to queuetemplate &lt;class Item&gt;bool QueueTP&lt;Item&gt;::enqueue(const Item &amp; item){ if (isfull()) return false; Node * add = new Node(item); // create node // on failure, new throws std::bad_alloc exception items ++; if (front == 0) // if queue is empty front = add; // place item at front else rear-&gt;next = add; // else place at rear rear = add; return true;}// Place front item into item variable and remove from queuetemplate &lt;class Item&gt;bool QueueTP&lt;Item&gt;::dequeue(Item &amp; item){ if (front == 0) return false; item = front-&gt;item; // set item to first item in queue items --; Node * temp = front; // save location of first item front = front-&gt;next; // reset front to next item delete temp; // delete former first item if (items == 0) rear = 0; return true;}#endif // QUEUETP_H_ 异常 意外情况 1.程序可能会试图打开一个不可用的文件2.请求过多内存3.遭遇不能容忍的值 1.调用abort()–原型在cstdlib（或stdlib.h）中 其典型实现是向标准错误流（即cerr使用的错误流）发送信息abnormalprogram termination（程序异常中止），然后终止程序。它返回一个随实现而异的值，告诉操作系统，处理失败。 调用abort()将直接终止程序（调用时，不进行任何清理工作） 使用方法：1.判断触发异常的条件 2.满足条件时调用abort() 1.exit():在调用时，会做大部分清理工作，但是决不会销毁局部对象，因为没有stack unwinding。会进行的清理工作包括：销毁所有static和global对象，清空所有缓冲区，关闭所有I／O通道。终止前会调用经由atexit()登录的函数，atexit如果抛出异常，则调用terminate()。 2.abort():调用时，不进行任何清理工作。直接终止程序。 3.retrun:调用时，进行stack unwinding，调用局部对象析构函数，清理局部对象。如果在main中，则之后再交由系统调用exit()。 return返回，可析构main或函数中的局部变量，尤其要注意局部对象，如不析构可能造成内存泄露。exit返回不析构main或函数中的局部变量，但执行收工函数，故可析构全局变量（对象）。abort不析构main或函数中的局部变量，也不执行收工函数，故全局和局部对象都不析构。所以，用return更能避免内存泄露，在C++中用abort和exit都不是好习惯。 2.返回错误代码一种比异常终止更灵活的方法是，使用函数的返回值来指出问题 3.异常机制 C++异常是对程序运行过程中发生的异常情况（例如被0除）的一种响应。异常提供了将控制权从程序的一个部分传递到另外一部分的途径 异常机制由三个部分组成1.引发异常123456double hmean(double a,double b){if(a==-b)throw \"bad heam() arguments:a=-b not allowed\";//throw关键字表示引发异常（实际上是跳转）return 2.0*a*b/(a+b);} 2.使用异常处理程序（exception handler）来捕获异常3.使用try块：try块标识其中特定异常可能会被激活的代码，它后面跟一个或多个的catch块 例子：12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt; using std::cout;using std::cin;using std::cerr; int fun(int &amp; a, int &amp; b){if(b == 0){ throw \"hello there have zero sorry\\n\"; //引发异常}return a / b;} int main(){ int a; int b; while(true) { cin &gt;&gt; a; cin &gt;&gt; b; try //try里面是可能引发异常代码块 { cout &lt;&lt; \" a / b = \"&lt;&lt; fun(a,b) &lt;&lt; \"\\n\"; } catch(const char *str) 接收异常,处理异常 { cout &lt;&lt; str; cerr &lt;&lt;\"除数为0\\n\"; //cerr不会到输出缓冲中 这样在紧急情况下也可以使用 } } system(\"pause\"); return 1;} 1.try:try块标识符其中特定的异常可能被激活的代码块,他后面跟一个或者多个catch块. 2.catch:类似于函数定义,但并不是函数定义,关键字catch表明这是给一个处理程序,里面的const cahr* str会接受throw传过来错误信息. 3.throw:抛出异常信息,类似于执行返回语句,因为它将终止函数的执行,但是它不是将控制权交给调用程序,而是导致程序沿着函数调用序列后退,知道找到包含try块的函数. 注意： 1.如果程序在try块外面调用fun(),将无法处理异常。 2.throw出的异常类型可以是字符串，或其他C++类型：通常为类类型 3.执行throw语句类似于执行返回语句，因为它也将终止函数的执行。 4.执行完try中的语句后，如果没有引发任何异常，则程序跳过try块后面的catch块，直接执行后面的第一条语句。 5.如果函数引发了异常，而没有try块或没有匹配处理程序时，将会发生什么情况。在默认情况下，程序最终调用abort()函数！ 4.将对象用作异常类型 P6225.栈解开（栈解退）stack unwind C++如何处理函数调用和返回的？ 1.程序将调用函数的地址（返回地址）放入到栈中。当被调用的函数执行完毕后，程序将使用该地址来确定从哪里开始执行。 2.函数调用将函数参数放入到栈中。在栈中，这些函数参数被视为自动变量。如果被调用的函数创建的自动变量，则这些自动变量也将被添加到栈中 3.如果被调用的函数调用了另外一个函数，则后者的信息将被添加到栈中，依此类推。 假设函数出现异常（而不是返回）而终止，则程序也将释放栈中的内存，但不会释放栈中的第一个地址后停止，而是继续释放，直到找到一个位于try块中的返回地址。随后，控制权将转到块尾的异常处理程序，而不是函数调用后的第一条语句，这个过程被称为栈解退。 exception类（头文件exception.h/except.h第一了exception类）C++可以把它用作其他异常类的基类 1.stdexcept 异常类（头文件stdexcept定义了其他几个异常类。） 该文件定义了1.logic_error类 2.runtime_error类他们都是以公有的方式从exception派生而来的。 1.logic_error类错误类型（domain_error、invalid_argument、length_error、out_of_bounds）。每个类都有一个类似于logic_error的构造函数，让您能够提供一个供方法what()返回的字符串。 2.runtime_error类错误类型（range_error、overflow_error、underflow_error）。每个类都有一个类似于runtime_error的构造函数，让您能够提供一个供方法what()返回的字符串。 2.bad-alloc异常和new(头文件new) 对于使用new导致的内存分配问题，C++的最新处理方式是让new引发bad_alloc异常。头文件new包含bad_alloc类的生命，他是从exception类公有派生而来的。但在以前，当无法分配请求的内存量时，new返回一个空指针。 3.异常类和继承 1.可以像标准C++库所做的那样，从一个异常类派生出另外一个。 2.可以在类定义中嵌套异常类声明类组合异常。 3.这种嵌套声明本身可被继承，还可用作基类。 RTTI(运行阶段类型识别)(Run-Time Type Identification) 旨在为程序运行阶段确定对象的类型提供一种标准方式 RTTI的工作原理 C++有三个支持RTTI的元素 1.如果可能的话，dynamic_cast运算符将使用一个指向基类的指针来生成指向派生类的指针；否则，该运算符返回0—空指针。 2.typeid运算符返回指出对象类型的值 3.type_info结构存储了有关特定类型的信息。 1.dynamic_cast运算符是最常用的RTTI组件 他不能回答“指针指向的是哪类对象”这样的问题，但能回答“是否可以安全地将对象的地址赋给特定类型的指针”这样的问题 用法：Superb* pm = dynamic_cast&lt;Super*&gt;(pg);其中pg指向一个对象 提出这样的问题：指针pg类型是否可被安全地转换为Super* ?如果可以返回对象地址，否则返回一个空指针。 2.typeid运算符和type_info类。 typeid运算符使得能够确定两个对象是否为同类型,使用：如果pg指向的是一个Magnification对象，则下述表达式的结果为bool值true，否则为false； 12345typeid(Magnification)==typeid(*pg)type_info类的实现岁厂商而异，但包含一个name()成员，该函数返回一个随实现而异的字符串；通常（但并非一定）是类的名称。例如下面的语句想爱你是指针pg指向的对象所属的类定义的字符串：​```C++cout&lt;&lt;\"Now Processing type\"&lt;&lt;typeid(*pg).name()&lt;&lt;\".\\n\"; 类型转换运算符 4个类型转换运算符:dynamic_cast\\const_cast\\static_cast\\reinterpret_cast 1.dynamic_cast(expression) 该运算符的用途是，使得能够在类层次结构中进行向上转换（由于is-a关系，这样的类型转换是安全的），不允许其他转换。 2.const_cast(expression) 该运算符用于执行只有一种用途的类型转换，即改变之const或volatile其语法与dynamic_cast运算符相同。 3.static_cast(expression) 4.reinterpret_cast(expression) 用于天生危险的类型转换。","link":"/2019/05/23/C++Notes/"}],"tags":[{"name":"CV-Source","slug":"CV-Source","link":"/tags/CV-Source/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"ICP","slug":"ICP","link":"/tags/ICP/"},{"name":"Registration","slug":"Registration","link":"/tags/Registration/"},{"name":"PoseEstimation","slug":"PoseEstimation","link":"/tags/PoseEstimation/"},{"name":"NDT","slug":"NDT","link":"/tags/NDT/"},{"name":"PCL","slug":"PCL","link":"/tags/PCL/"},{"name":"CUDA","slug":"CUDA","link":"/tags/CUDA/"},{"name":"ObjectDetection","slug":"ObjectDetection","link":"/tags/ObjectDetection/"}],"categories":[{"name":"CV-Source","slug":"CV-Source","link":"/categories/CV-Source/"},{"name":"编程","slug":"编程","link":"/categories/编程/"},{"name":"C++","slug":"编程/C","link":"/categories/编程/C/"},{"name":"PCL","slug":"PCL","link":"/categories/PCL/"},{"name":"CUDA","slug":"编程/CUDA","link":"/categories/编程/CUDA/"},{"name":"Registration","slug":"PCL/Registration","link":"/categories/PCL/Registration/"},{"name":"tutorial","slug":"PCL/tutorial","link":"/categories/PCL/tutorial/"},{"name":"ObjectDetection and PoseEstimation","slug":"ObjectDetection-and-PoseEstimation","link":"/categories/ObjectDetection-and-PoseEstimation/"},{"name":"tutorial","slug":"ObjectDetection-and-PoseEstimation/tutorial","link":"/categories/ObjectDetection-and-PoseEstimation/tutorial/"}]}